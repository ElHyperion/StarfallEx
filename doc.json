{"hooks":{"1":"EndEntityDriving","2":"EntityRemoved","3":"EntityTakeDamage","4":"FinishChat","5":"GravGunOnDropped","6":"GravGunOnPickedUp","7":"GravGunPunt","8":"Initialize","9":"KeyPress","10":"KeyRelease","11":"OnEntityCreated","12":"OnPhysgunFreeze","13":"OnPhysgunReload","14":"PhysgunDrop","15":"PhysgunPickup","16":"PlayerCanPickupWeapon","17":"PlayerDeath","18":"PlayerDisconnected","19":"PlayerEnteredVehicle","20":"PlayerHurt","21":"PlayerInitialSpawn","22":"PlayerLeaveVehicle","23":"PlayerNoClip","24":"PlayerSay","25":"PlayerSpawn","26":"PlayerSpray","27":"PlayerSwitchFlashlight","28":"PlayerSwitchWeapon","29":"PlayerUse","30":"PropBreak","31":"Removed","32":"StartChat","33":"StartEntityDriving","34":"calcview","35":"input","36":"inputPressed","37":"inputReleased","38":"net","39":"readcell","40":"remote","41":"render","42":"starfallUsed","43":"think","44":"tick","45":"writecell","render":{"description":"\nCalled when a frame is requested to be drawn.","code":["",""],"class":"hook","classForced":true,"name":"render","summary":"\nCalled when a frame is requested to be drawn.","client":true,"comment":["--- Called when a frame is requested to be drawn.","-- @name render","-- @class hook","-- @client"],"param":[]},"PhysgunPickup":{"description":"\nCalled when an entity gets picked up by a physgun","code":[""],"class":"hook","classForced":true,"name":"PhysgunPickup","summary":"\nCalled when an entity gets picked up by a physgun ","server":true,"client":true,"comment":["--- Called when an entity gets picked up by a physgun","-- @name PhysgunPickup","-- @class hook","-- @shared","-- @param ply Player picking up the entity","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up the entity","ent":"Entity being picked up"}},"GravGunOnPickedUp":{"description":"\nCalled when an entity is being picked up by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnPickedUp","summary":"\nCalled when an entity is being picked up by a gravity gun ","server":true,"comment":["--- Called when an entity is being picked up by a gravity gun","-- @name GravGunOnPickedUp","-- @class hook","-- @server","-- @param ply Player picking up an object","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up an object","ent":"Entity being picked up"}},"PlayerCanPickupWeapon":{"description":"\nCalled when a wants to pick up a weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerCanPickupWeapon","summary":"\nCalled when a wants to pick up a weapon ","server":true,"comment":["--- Called when a wants to pick up a weapon","-- @name PlayerCanPickupWeapon","-- @class hook","-- @server","-- @param ply Player","-- @param wep Weapon"],"param":{"1":"ply","2":"wep","ply":"Player","wep":"Weapon"}},"PlayerEnteredVehicle":{"description":"\nCalled when a players enters a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerEnteredVehicle","summary":"\nCalled when a players enters a vehicle ","server":true,"comment":["--- Called when a players enters a vehicle","-- @name PlayerEnteredVehicle","-- @class hook","-- @server","-- @param ply Player who entered a vehicle","-- @param vehicle Vehicle that was entered","-- @param num Role"],"param":{"1":"ply","2":"vehicle","3":"num","vehicle":"Vehicle that was entered","ply":"Player who entered a vehicle","num":"Role"}},"PlayerSpray":{"description":"\nCalled when a players sprays his logo","code":[""],"class":"hook","classForced":true,"name":"PlayerSpray","summary":"\nCalled when a players sprays his logo ","server":true,"comment":["--- Called when a players sprays his logo","-- @name PlayerSpray","-- @class hook","-- @server","-- @param ply Player that sprayed"],"param":{"1":"ply","ply":"Player that sprayed"}},"KeyRelease":{"description":"\nCalled when a player releases a key","code":[""],"class":"hook","classForced":true,"name":"KeyRelease","summary":"\nCalled when a player releases a key ","server":true,"client":true,"comment":["--- Called when a player releases a key","-- @name KeyRelease","-- @class hook","-- @shared","-- @param ply Player releasing the key","-- @param key The key being released"],"param":{"1":"ply","2":"key","ply":"Player releasing the key","key":"The key being released"}},"KeyPress":{"description":"\nCalled when a player presses a key","code":[""],"class":"hook","classForced":true,"name":"KeyPress","summary":"\nCalled when a player presses a key ","server":true,"client":true,"comment":["--- Called when a player presses a key","-- @name KeyPress","-- @class hook","-- @shared","-- @param ply Player pressing the key","-- @param key The key being pressed"],"param":{"1":"ply","2":"key","ply":"Player pressing the key","key":"The key being pressed"}},"FinishChat":{"description":"\nCalled when the local player closes their chat window.","code":[],"class":"hook","classForced":true,"name":"FinishChat","summary":"\nCalled when the local player closes their chat window.","client":true,"comment":["--- Called when the local player closes their chat window.","-- @name FinishChat","-- @class hook","-- @client"],"param":[]},"EntityTakeDamage":{"description":"\nCalled when an entity is damaged","code":[""],"class":"hook","classForced":true,"name":"EntityTakeDamage","summary":"\nCalled when an entity is damaged ","server":true,"comment":["--- Called when an entity is damaged","-- @name EntityTakeDamage","-- @class hook","-- @server","-- @param target Entity that is hurt","-- @param attacker Entity that attacked","-- @param inflictor Entity that inflicted the damage","-- @param amount How much damage","-- @param type Type of the damage","-- @param position Position of the damage","-- @param force Force of the damage"],"param":{"1":"target","2":"attacker","3":"inflictor","4":"amount","5":"type","6":"position","7":"force","inflictor":"Entity that inflicted the damage","position":"Position of the damage","amount":"How much damage","target":"Entity that is hurt","force":"Force of the damage","attacker":"Entity that attacked","type":"Type of the damage"}},"PlayerInitialSpawn":{"description":"\nCalled when a player spawns for the first time","code":[""],"class":"hook","classForced":true,"name":"PlayerInitialSpawn","summary":"\nCalled when a player spawns for the first time ","server":true,"comment":["--- Called when a player spawns for the first time","-- @name PlayerInitialSpawn","-- @class hook","-- @server","-- @param ply Player who spawned"],"param":{"1":"ply","ply":"Player who spawned"}},"PlayerSpawn":{"description":"\nCalled when a player spawns","code":[""],"class":"hook","classForced":true,"name":"PlayerSpawn","summary":"\nCalled when a player spawns ","server":true,"comment":["--- Called when a player spawns","-- @name PlayerSpawn","-- @class hook","-- @server","-- @param ply Player who spawned"],"param":{"1":"ply","ply":"Player who spawned"}},"OnPhysgunFreeze":{"description":"\nCalled when an entity is being frozen","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunFreeze","summary":"\nCalled when an entity is being frozen ","server":true,"comment":["--- Called when an entity is being frozen","-- @name OnPhysgunFreeze","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param physobj PhysObj of the entity","-- @param ent Entity being frozen","-- @param ply Player freezing the entity"],"param":{"1":"physgun","2":"physobj","3":"ent","4":"ply","physobj":"PhysObj of the entity","ply":"Player freezing the entity","physgun":"Entity of the physgun","ent":"Entity being frozen"}},"remote":{"description":"\nRemote hook. \nThis hook can be called from other instances","code":[""],"class":"hook","classForced":true,"name":"remote","summary":"\nRemote hook.","server":true,"client":true,"comment":["--- Remote hook.","-- This hook can be called from other instances","-- @name remote","-- @class hook","-- @shared","-- @param sender The entity that caused the hook to run","-- @param owner The owner of the sender","-- @param ... The payload that was supplied when calling the hook"],"param":{"1":"sender","2":"owner","3":"...","sender":"The entity that caused the hook to run","...":"The payload that was supplied when calling the hook","owner":"The owner of the sender"}},"PlayerDisconnected":{"description":"\nCalled when a player disconnects","code":[""],"class":"hook","classForced":true,"name":"PlayerDisconnected","summary":"\nCalled when a player disconnects ","server":true,"comment":["--- Called when a player disconnects","-- @name PlayerDisconnected","-- @class hook","-- @server","-- @param ply Player that disconnected"],"param":{"1":"ply","ply":"Player that disconnected"}},"PlayerSwitchWeapon":{"description":"\nCalled when a player switches their weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchWeapon","summary":"\nCalled when a player switches their weapon ","server":true,"client":true,"comment":["--- Called when a player switches their weapon","-- @name PlayerSwitchWeapon","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param oldwep Old weapon","-- @param newweapon New weapon"],"param":{"1":"ply","2":"oldwep","3":"newweapon","oldwep":"Old weapon","ply":"Player droppig the entity","newweapon":"New weapon"}},"OnPhysgunReload":{"description":"\nCalled when a player reloads his physgun","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunReload","summary":"\nCalled when a player reloads his physgun ","server":true,"comment":["--- Called when a player reloads his physgun","-- @name OnPhysgunReload","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param ply Player reloading the physgun"],"param":{"1":"physgun","2":"ply","physgun":"Entity of the physgun","ply":"Player reloading the physgun"}},"PlayerSwitchFlashlight":{"description":"\nCalled when a players turns their flashlight on or off","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchFlashlight","summary":"\nCalled when a players turns their flashlight on or off ","server":true,"comment":["--- Called when a players turns their flashlight on or off","-- @name PlayerSwitchFlashlight","-- @class hook","-- @server","-- @param ply Player switching flashlight","-- @param state New flashlight state. True if on."],"param":{"1":"ply","2":"state","ply":"Player switching flashlight","state":"New flashlight state. True if on."}},"PlayerUse":{"description":"\nCalled when a player holds their use key and looks at an entity. \nWill continuously run.","code":[""],"class":"hook","classForced":true,"name":"PlayerUse","summary":"\nCalled when a player holds their use key and looks at an entity.","param":{"1":"ply","2":"ent","ply":"Player using the entity","ent":"Entity being used"},"comment":["--- Called when a player holds their use key and looks at an entity.","-- Will continuously run.","-- @name PlayerUse","-- @server","-- @class hook","-- @param ply Player using the entity","-- @param ent Entity being used"],"server":true},"GravGunPunt":{"description":"\nCalled when a player punts with the gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunPunt","summary":"\nCalled when a player punts with the gravity gun ","server":true,"client":true,"comment":["--- Called when a player punts with the gravity gun","-- @name GravGunPunt","-- @class hook","-- @shared","-- @param ply Player punting the gravgun","-- @param ent Entity being punted"],"param":{"1":"ply","2":"ent","ply":"Player punting the gravgun","ent":"Entity being punted"}},"EndEntityDriving":{"description":"\nCalled when a player stops driving an entity","code":[""],"class":"hook","classForced":true,"name":"EndEntityDriving","summary":"\nCalled when a player stops driving an entity ","server":true,"client":true,"comment":["--- Called when a player stops driving an entity","-- @name EndEntityDriving","-- @class hook","-- @shared","-- @param ent Entity that had been driven","-- @param ply Player that drove the entity"],"param":{"1":"ent","2":"ply","ent":"Entity that had been driven","ply":"Player that drove the entity"}},"OnEntityCreated":{"description":"\nCalled when an entity gets created","code":[""],"class":"hook","classForced":true,"name":"OnEntityCreated","summary":"\nCalled when an entity gets created ","server":true,"client":true,"comment":["--- Called when an entity gets created","-- @name OnEntityCreated","-- @class hook","-- @shared","-- @param ent New entity"],"param":{"1":"ent","ent":"New entity"}},"StartChat":{"description":"\nCalled when the local player opens their chat window.","code":[""],"class":"hook","classForced":true,"name":"StartChat","summary":"\nCalled when the local player opens their chat window.","client":true,"comment":["--- Called when the local player opens their chat window.","-- @name StartChat","-- @class hook","-- @client"],"param":[]},"GravGunOnDropped":{"description":"\nCalled when an entity is being dropped by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnDropped","summary":"\nCalled when an entity is being dropped by a gravity gun ","server":true,"comment":["--- Called when an entity is being dropped by a gravity gun","-- @name GravGunOnDropped","-- @class hook","-- @server","-- @param ply Player dropping the object","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player dropping the object","ent":"Entity being dropped"}},"PlayerHurt":{"description":"\nCalled when a player gets hurt","code":[""],"class":"hook","classForced":true,"name":"PlayerHurt","summary":"\nCalled when a player gets hurt ","server":true,"client":true,"comment":["--- Called when a player gets hurt","-- @name PlayerHurt","-- @class hook","-- @shared","-- @param ply Player being hurt","-- @param attacker Entity causing damage to the player","-- @param newHealth New health of the player","-- @param damageTaken Amount of damage the player has taken"],"param":{"1":"ply","2":"attacker","3":"newHealth","4":"damageTaken","damageTaken":"Amount of damage the player has taken","attacker":"Entity causing damage to the player","ply":"Player being hurt","newHealth":"New health of the player"}},"writecell":{"classForced":true,"summary":"\nCalled when a high speed device writes to a wired SF chip ","comment":["--- Called when a high speed device writes to a wired SF chip","-- @name writecell","-- @class hook","-- @param address The address written to","-- @param data The data being written"],"code":[],"description":"\nCalled when a high speed device writes to a wired SF chip","class":"hook","name":"writecell","param":{"1":"address","2":"data","data":"The data being written","address":"The address written to"}},"readcell":{"ret":"The value read","description":"\nCalled when a high speed device reads from a wired SF chip","code":[""],"class":"hook","classForced":true,"name":"readcell","summary":"\nCalled when a high speed device reads from a wired SF chip ","server":true,"comment":["--- Called when a high speed device reads from a wired SF chip","-- @name readcell","-- @class hook","-- @server","-- @param address The address requested","-- @return The value read"],"param":{"1":"address","address":"The address requested"}},"PropBreak":{"description":"\nCalled when an entity is broken","code":[""],"class":"hook","classForced":true,"name":"PropBreak","summary":"\nCalled when an entity is broken ","server":true,"client":true,"comment":["--- Called when an entity is broken","-- @name PropBreak","-- @class hook","-- @shared","-- @param ply Player who broke it","-- @param ent Entity broken"],"param":{"1":"ply","2":"ent","ply":"Player who broke it","ent":"Entity broken"}},"PlayerNoClip":{"description":"\nCalled when a player toggles noclip","code":[""],"class":"hook","classForced":true,"name":"PlayerNoClip","summary":"\nCalled when a player toggles noclip ","server":true,"client":true,"comment":["--- Called when a player toggles noclip","-- @name PlayerNoClip","-- @class hook","-- @shared","-- @param ply Player toggling noclip","-- @param newState New noclip state. True if on."],"param":{"1":"ply","2":"newState","ply":"Player toggling noclip","newState":"New noclip state. True if on."}},"EntityRemoved":{"description":"\nCalled when an entity is removed","code":[""],"class":"hook","classForced":true,"name":"EntityRemoved","summary":"\nCalled when an entity is removed ","server":true,"client":true,"comment":["--- Called when an entity is removed","-- @name EntityRemoved","-- @class hook","-- @shared","-- @param ent Entity being removed"],"param":{"1":"ent","ent":"Entity being removed"}},"net":{"classForced":true,"summary":"\nCalled when a net message arrives ","comment":["--- Called when a net message arrives","-- @name net","-- @class hook","-- @param name Name of the arriving net message","-- @param len Length of the arriving net message in bytes","-- @param ply On server, the player that sent the message. Nil on client."],"code":[],"description":"\nCalled when a net message arrives","class":"hook","name":"net","param":{"1":"name","2":"len","3":"ply","len":"Length of the arriving net message in bytes","name":"Name of the arriving net message","ply":"On server, the player that sent the message. Nil on client."}},"PlayerSay":{"ret":"New text. \"\" to stop from displaying. Nil to keep original.","description":"\nCalled when a player sends a chat message","code":[""],"class":"hook","classForced":true,"name":"PlayerSay","summary":"\nCalled when a player sends a chat message ","server":true,"comment":["--- Called when a player sends a chat message","-- @name PlayerSay","-- @class hook","-- @server","-- @param ply Player that sent the message","-- @param text Content of the message","-- @param teamChat True if team chat","-- @return New text. \"\" to stop from displaying. Nil to keep original."],"param":{"1":"ply","2":"text","3":"teamChat","text":"Content of the message","ply":"Player that sent the message","teamChat":"True if team chat"}},"inputPressed":{"classForced":true,"summary":"\nCalled when a button is pressed ","comment":["---- Called when a button is pressed","--- @name inputPressed","--- @class hook","--- @param button Number of the button"],"code":[""],"description":"\nCalled when a button is pressed","class":"hook","name":"inputPressed","param":{"1":"button","button":"Number of the button"}},"Initialize":{"description":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","code":[""],"class":"hook","classForced":true,"name":"Initialize","summary":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","server":true,"comment":["--- Called after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","-- @name Initialize","-- @class hook","-- @server"],"param":[]},"Removed":{"description":"\nCalled when the starfall chip is removed","code":[""],"class":"hook","classForced":true,"name":"Removed","summary":"\nCalled when the starfall chip is removed ","server":true,"comment":["--- Called when the starfall chip is removed","-- @name Removed","-- @class hook","-- @server"],"param":[]},"tick":{"description":"\nTick hook. Called each game tick on both the server and client.","code":[""],"class":"hook","classForced":true,"name":"tick","summary":"\nTick hook.","server":true,"client":true,"comment":["--- Tick hook. Called each game tick on both the server and client.","-- @name tick","-- @class hook","-- @shared"],"param":[]},"think":{"description":"\nThink hook. Called each frame on the client and each game tick on the server.","code":[""],"class":"hook","classForced":true,"name":"think","summary":"\nThink hook.","server":true,"client":true,"comment":["--- Think hook. Called each frame on the client and each game tick on the server.","-- @name think","-- @class hook","-- @shared"],"param":[]},"StartEntityDriving":{"description":"\nCalled when a player starts driving an entity","code":[""],"class":"hook","classForced":true,"name":"StartEntityDriving","summary":"\nCalled when a player starts driving an entity ","server":true,"client":true,"comment":["--- Called when a player starts driving an entity","-- @name StartEntityDriving","-- @class hook","-- @shared","-- @param ent Entity being driven","-- @param ply Player that is driving the entity"],"param":{"1":"ent","2":"ply","ent":"Entity being driven","ply":"Player that is driving the entity"}},"inputReleased":{"classForced":true,"summary":"\nCalled when a button is released ","comment":["---- Called when a button is released","--- @name inputReleased","--- @class hook","--- @param button Number of the button"],"code":[],"description":"\nCalled when a button is released","class":"hook","name":"inputReleased","param":{"1":"button","button":"Number of the button"}},"calcview":{"ret":"table Table containing information for the camera. {origin=camera origin, angles=camera angles, fov=camera fov, znear=znear, zfar=zfar, drawviewer=drawviewer}","description":"\nCalled when the engine wants to calculate the player's view","code":[""],"class":"hook","classForced":true,"name":"calcview","summary":"\nCalled when the engine wants to calculate the player's view ","client":true,"comment":["--- Called when the engine wants to calculate the player's view","-- @name calcview","-- @class hook","-- @client","-- @param pos Current position of the camera","-- @param ang Current angles of the camera","-- @param fov Current fov of the camera","-- @param znear Current near plane of the camera","-- @param zfar Current far plane of the camera","-- @return table Table containing information for the camera. {origin=camera origin, angles=camera angles, fov=camera fov, znear=znear, zfar=zfar, drawviewer=drawviewer}"],"param":{"1":"pos","2":"ang","3":"fov","4":"znear","5":"zfar","fov":"Current fov of the camera","ang":"Current angles of the camera","zfar":"Current far plane of the camera","znear":"Current near plane of the camera","pos":"Current position of the camera"}},"PhysgunDrop":{"description":"\nCalled when an entity being held by a physgun gets dropped","code":[""],"class":"hook","classForced":true,"name":"PhysgunDrop","summary":"\nCalled when an entity being held by a physgun gets dropped ","server":true,"client":true,"comment":["--- Called when an entity being held by a physgun gets dropped","-- @name PhysgunDrop","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player droppig the entity","ent":"Entity being dropped"}},"input":{"classForced":true,"summary":"\nCalled when an input on a wired SF chip is written to ","comment":["--- Called when an input on a wired SF chip is written to","-- @name input","-- @class hook","-- @param input The input name","-- @param value The value of the input"],"code":[""],"description":"\nCalled when an input on a wired SF chip is written to","class":"hook","name":"input","param":{"1":"input","2":"value","input":"The input name","value":"The value of the input"}},"starfallUsed":{"classForced":true,"summary":"\nCalled when a player uses the screen ","comment":["--- Called when a player uses the screen","-- @name starfallUsed","-- @class hook","-- @param activator Player using the screen"],"code":[""],"description":"\nCalled when a player uses the screen","class":"hook","name":"starfallUsed","param":{"1":"activator","activator":"Player using the screen"}},"PlayerDeath":{"description":"\nCalled when a player dies","code":[""],"class":"hook","classForced":true,"name":"PlayerDeath","summary":"\nCalled when a player dies ","server":true,"comment":["--- Called when a player dies","-- @name PlayerDeath","-- @class hook","-- @server","-- @param ply Player who died","-- @param inflictor Entity used to kill the player","-- @param attacker Entity that killed the player"],"param":{"1":"ply","2":"inflictor","3":"attacker","inflictor":"Entity used to kill the player","ply":"Player who died","attacker":"Entity that killed the player"}},"PlayerLeaveVehicle":{"description":"\nCalled when a players leaves a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerLeaveVehicle","summary":"\nCalled when a players leaves a vehicle ","server":true,"comment":["--- Called when a players leaves a vehicle","-- @name PlayerLeaveVehicle","-- @class hook","-- @server","-- @param ply Player who left a vehicle","-- @param vehicle Vehicle that was left"],"param":{"1":"ply","2":"vehicle","ply":"Player who left a vehicle","vehicle":"Vehicle that was left"}}},"libraries":{"1":"bass","2":"builtin","3":"constraint","4":"coroutine","5":"fastlz","6":"file","7":"find","8":"game","9":"globaltables","10":"holograms","11":"hook","12":"http","13":"input","14":"joystick","15":"json","16":"net","17":"physenv","18":"prop","19":"quaternion","20":"render","21":"sounds","22":"team","23":"timer","24":"trace","25":"von","26":"wire","render":{"comment":["--- Render library. Screens are 512x512 units. Most functions require","-- that you be in the rendering hook to call, otherwise an error is","-- thrown. +x is right, +y is down","-- @entity starfall_screen","-- @field TEXT_ALIGN_LEFT","-- @field TEXT_ALIGN_CENTER","-- @field TEXT_ALIGN_RIGHT","-- @field TEXT_ALIGN_TOP","-- @field TEXT_ALIGN_BOTTOM"],"functions":{"1":"capturePixels","2":"clear","3":"createFont","4":"createRenderTarget","5":"cursorPos","6":"drawCircle","7":"drawLine","8":"drawPoly","9":"drawRect","10":"drawRectOutline","11":"drawRoundedBox","12":"drawRoundedBoxEx","13":"drawSimpleText","14":"drawText","15":"drawTexturedRect","16":"drawTexturedRectRotated","17":"drawTexturedRectUV","18":"getDefaultFont","19":"getRenderTargetMaterial","20":"getResolution","21":"getScreenEntity","22":"getScreenInfo","23":"getTextSize","24":"getTextureID","25":"parseMarkup","26":"popMatrix","27":"popViewMatrix","28":"pushMatrix","29":"pushViewMatrix","30":"readPixel","31":"selectRenderTarget","32":"setColor","33":"setFont","34":"setRGBA","35":"setRenderTargetTexture","36":"setTexture","37":"setTextureFromScreen","drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen or screen:GetClass()~=\"starfall_screen\" then return input.GetCursorPos() end","","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","","\tlocal Normal, Pos","\t-- Get monitor screen pos & size","","\tPos = screen:LocalToWorld( screen.Origin )","","\tNormal = -screen.Transform:GetUp():GetNormalized()","","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","","\tlocal A = Normal:Dot(Dir)","","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","","\tlocal B = Normal:Dot(Pos-Start) / A","\tif (B >= 0) then","\t\tlocal w = 512/screen.Aspect","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), screen.Transform:GetTranslation(), screen.Transform:GetAngles() )","\t\tlocal x = HitPos.x/screen.Scale","\t\tlocal y = HitPos.y/screen.Scale","\t\tif x < 0 or x > w or y < 0 or y > 512 then return nil end -- Aiming off the screen","\t\treturn x, y","\tend","","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix","-- @param world Should the transformation be relative to the screen or world? "],"code":["function render_library.pushMatrix(m, world)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tif not world and renderdata.renderEnt and renderdata.renderEnt.Transform then","\t\tnewmatrix = renderdata.renderEnt.Transform * newmatrix","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","2":"world","m":"The matrix","world":"Should the transformation be relative to the screen or world?"}},"drawRoundedBoxEx":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param tl Boolean Top left corner","-- @param tr Boolean Top right corner","-- @param bl Boolean Bottom left corner","-- @param br Boolean Bottom right corner"],"code":["function render_library.drawRoundedBoxEx ( r, x, y, w, h, tl, tr, bl, br )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( tl, \"boolean\" )","\tSF.CheckType( tr, \"boolean\" )","\tSF.CheckType( bl, \"boolean\" )","\tSF.CheckType( br, \"boolean\" )","\tdraw.RoundedBoxEx( r, x, y, w, h, currentcolor, tl, tr, bl, br )","end",""],"class":"function","name":"render_library.drawRoundedBoxEx","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","6":"tl","7":"tr","8":"bl","9":"br","tr":"Boolean Top right corner","tl":"Boolean Top left corner","r":"The corner radius","w":"Width","y":"Top left corner y coordinate","h":"Height","x":"Top left corner x coordinate","br":"Boolean Bottom right corner","bl":"Boolean Bottom left corner"}},"createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blur Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- Akbar","-- \\- Coolvetica","-- \\- Roboto","-- \\- Courier New","-- \\- Verdana","-- \\- Arial","-- \\- HalfLife2","-- \\- hl2mp","-- \\- csd","-- \\- Tahoma","-- \\- Trebuchet","-- \\- Trebuchet MS","-- \\- DejaVu Sans Mono","-- \\- Lucida Console","-- \\- Times New Roman"],"code":["","function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tfont = validfonts[string.lower(font)]","\tif not font then SF.throw( \"invalid font\", 2 ) end","","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end","defaultFont = render_library.createFont(\"Default\", 16, 400, false, false, false, false, 0)",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- Akbar \n- Coolvetica \n- Roboto \n- Courier New \n- Verdana \n- Arial \n- HalfLife2 \n- hl2mp \n- csd \n- Tahoma \n- Trebuchet \n- Trebuchet MS \n- DejaVu Sans Mono \n- Lucida Console \n- Times New Roman","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","outline":"Enable outline?","font":"Base font to use","blur":"Enable blur?","weight":"Font weight (default: 400)","shadow":"Enable drop shadow?","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target"],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024 ), false }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\trt[ 3 ] = CreateMaterial( \"StarfallCustomModel_\"..name..SF.instance.data.entity:EntIndex(), \"VertexLitGeneric\", {","\t\t[ \"$model\" ] = 1,","\t} )","\trt[3]:SetTexture(\"$basetexture\", rt[1])","\t","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"setTexture":{"comment":["--- Sets the texture","-- @param id Texture table. Get it with render.getTextureID"],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id then","\t\tif texturecache[ id ] then","\t\t\tsurface.SetMaterial( texturecache[ id ] )","\t\telseif texturecachehttp[ id ] then","\t\t\tsurface.SetMaterial( texturecachehttp[ id ] )","\t\telse","\t\t\tdraw.NoTexture()","\t\tend","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture table. Get it with render.getTextureID"}},"drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"parseMarkup":{"ret":"The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject","comment":["--- Constructs a markup object for quick styled text drawing.","-- @param markup The markup string to parse","-- @param maxsize The max width of the markup","-- @return The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject"],"code":["function render_library.parseMarkup( str, maxsize )","\tSF.CheckType( str, \"string\" )","\tSF.CheckType( maxsize, \"number\" )","\tlocal marked = markup.Parse( str, maxsize )","\tlocal markedindex = marked.__index","\treturn setmetatable(marked, {","\t\t__newindex = function() end,","\t\t__index = markedindex,","\t\t__metatable = \"\"","\t})","end",""],"class":"function","name":"render_library.parseMarkup","summary":"\nConstructs a markup object for quick styled text drawing.","private":false,"library":"render","description":"\nConstructs a markup object for quick styled text drawing.","param":{"1":"str","2":"maxsize","3":"markup","markup":"The markup string to parse","maxsize":"The max width of the markup"}},"getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawText":{"comment":["--- Draws text with newlines and tabs","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.DrawText( text, font, x, y, currentcolor, alignment )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text with newlines and tabs ","private":false,"library":"render","description":"\nDraws text with newlines and tabs","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}},"getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"drawSimpleText":{"comment":["--- Draws text more easily and quickly but no new lines or tabs.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param xalign Text x alignment","-- @param yalign Text y alignment"],"code":["function render_library.drawSimpleText ( x, y, text, xalign, yalign )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif xalign then SF.CheckType( xalign, \"number\" ) end","\tif yalign then SF.CheckType( yalign, \"number\" ) end","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.SimpleText( text, font, x, y, currentcolor, xalign, yalign )","end",""],"class":"function","name":"render_library.drawSimpleText","summary":"\nDraws text more easily and quickly but no new lines or tabs.","private":false,"library":"render","description":"\nDraws text more easily and quickly but no new lines or tabs.","param":{"1":"x","2":"y","3":"text","4":"xalign","5":"yalign","y":"Y coordinate","x":"X coordinate","text":"Text to draw","yalign":"Text y alignment","xalign":"Text x alignment"}},"drawRoundedBox":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRoundedBox ( r, x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tdraw.RoundedBox( r, x, y, w, h, currentcolor )","end",""],"class":"function","name":"render_library.drawRoundedBox","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","r":"The corner radius","w":"Width","h":"Height"}},"drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif name then","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\t\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\t\tif not data.usingRT then","\t\t\tdata.oldViewPort = {0, 0, ScrW(), ScrH()}","\t\t\trender.SetViewPort( 0, 0, 1024, 1024 )","\t\t\tcam.Start2D()","\t\t\trender.SetStencilEnable( false )","\t\tend","\t\trender.SetRenderTarget( rt )","\t\tdata.usingRT = true","\telse","\t\tif data.usingRT then","\t\t\trender.SetRenderTarget()","\t\t\tcam.End2D()","\t\t\trender.SetViewPort(unpack(data.oldViewPort))","\t\t\tdata.usingRT = false","\t\t\trender.SetStencilEnable( true )","\t\tend","\tend","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"getRenderTargetMaterial":{"ret":"Model material name. Send this to the server to set the entity's material.","comment":["--- Returns the model material name that uses the render target.","--- Alternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex() ","-- @param name Render target name","-- @return Model material name. Send this to the server to set the entity's material."],"code":["function render_library.getRenderTargetMaterial( name )","\tlocal data = SF.instance.data.render","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\treturn \"!\"..tostring(globalRTs[ rtname ][ 3 ])","\tend","end",""],"class":"function","name":"render_library.getRenderTargetMaterial","summary":"\nReturns the model material name that uses the render target.","private":false,"library":"render","description":"\nReturns the model material name that uses the render target. \nAlternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex()","param":{"1":"name","name":"Render target name"}},"getResolution":{"ret":["the X size of the current render context","the Y size of the current render context"],"comment":["--- Returns the render context's width and height","-- @class function","-- @return the X size of the current render context","-- @return the Y size of the current render context"],"code":["function render_library.getResolution()","\treturn SF.instance.data.render.renderEnt:GetResolution()","end",""],"class":"function","classForced":true,"name":"render_library.getResolution","summary":"\nReturns the render context's width and height ","private":false,"library":"render","description":"\nReturns the render context's width and height","param":[]},"clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","\tif SF.instance.data.render.usingRT then","\t\tif clr == nil then","\t\t\trender.Clear( 0, 0, 0, 255 )","\t\telse","\t\t\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\t\t\trender.Clear( clr.r, clr.g, clr.b, clr.a )","\t\tend","\tend","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},"setRGBA":{"comment":["--- Sets the draw color by RGBA values"],"code":["function render_library.setRGBA( r, g, b, a )","\tSF.CheckType( r, \"number\" ) SF.CheckType( g, \"number\" ) SF.CheckType( b, \"number\" ) SF.CheckType( a, \"number\" )","\tcurrentcolor = Color( r, g, b, a )","\tsurface.SetDrawColor( r, g, b, a )","\tsurface.SetTextColor( r, g, b, a )","end",""],"class":"function","name":"render_library.setRGBA","summary":"\nSets the draw color by RGBA values ","private":false,"library":"render","description":"\nSets the draw color by RGBA values","param":["r","g","b","a"]},"drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"getTextureID":{"ret":"Texture table. Use it with render.setTexture. Returns nil if max url textures is reached.","comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url","-- @param cb Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table","-- @param alignment Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","-- @return Texture table. Use it with render.setTexture. Returns nil if max url textures is reached."],"code":["function render_library.getTextureID ( tx, cb, alignment )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","","\t\tif alignment then","\t\t\tSF.CheckType( alignment, \"string\" )","\t\t\tlocal args = string.Split( alignment, \" \" )","\t\t\tlocal validargs = {[\"left\"]=true,[\"center\"]=true,[\"right\"]=true,[\"top\"]=true,[\"bottom\"]=true}","\t\t\tif #args ~= 1 and #args ~= 2 then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tfor i=1, #args do","\t\t\t\tif not validargs[args[i]] then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tend","\t\telse","\t\t\talignment = \"center\"","\t\tend","\t\t","\t\tlocal instance = SF.instance","","\t\tlocal tbl = {}","\t\ttexturecachehttp[ tbl ] = LoadURLMaterial( tx, alignment, function()","\t\t\tif cb then","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( cb, tbl, tx )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend)","\t\tif not texturecachehttp[ tbl ] then return end","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tif not mat then return end","\t\t\tlocal cacheentry = sfCreateMaterial( \"SF_TEXTURE_\" .. id )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","2":"cb","3":"alignment","tx":"Texture file path, or a http url","alignment":"Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","cb":"Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table"}},"getScreenEntity":{"ret":"Entity of the screen or hud being rendered","comment":["--- Returns the entity currently being rendered to","-- @return Entity of the screen or hud being rendered"],"code":["function render_library.getScreenEntity()","\treturn SF.Entities.Wrap( SF.instance.data.render.renderEnt )","end",""],"class":"function","name":"render_library.getScreenEntity","summary":"\nReturns the entity currently being rendered to ","private":false,"library":"render","description":"\nReturns the entity currently being rendered to","param":[]},"setFont":{"comment":["--- Sets the font","-- @param font The font to use","-- @usage Use a font created by render.createFont or use one of these already defined fonts:","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- Default","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet24","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- HudNumbers","-- \\- DermaDefault","-- \\- DermaDefaultBold","-- \\- DermaLarge"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","summary":"\nSets the font ","name":"render_library.setFont","library":"render","private":false,"usage":"Use a font created by render.createFont or use one of these already defined fonts: \n- DebugFixed \n- DebugFixedSmall \n- Default \n- Marlett \n- Trebuchet18 \n- Trebuchet24 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- HudNumbers \n- DermaDefault \n- DermaDefaultBold \n- DermaLarge","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as world offsets, dimentions, and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @param e The screen to get info from.","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo( e )","\tlocal screen = SF.Entities.Unwrap( e )","\tif screen then","\t\treturn SF.Sanitize( screen.ScreenInfo )","\tend","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as world offsets, dimentions, and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as world offsets, dimentions, and rotation. \nNote: this does a table copy so move it out of your draw hook","param":{"1":"e","e":"The screen to get info from."}},"drawRect":{"comment":["--- Draws a rectangle using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"popViewMatrix":{"comment":["--- Pops a view matrix from the matrix stack."],"code":["function render_library.popViewMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\t","\tcam.End()","\tview_matrix_stack = view_matrix_stack - 1","end",""],"class":"function","name":"render_library.popViewMatrix","summary":"\nPops a view matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a view matrix from the matrix stack.","param":[]},"setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\tRT_Material:SetTexture( \"$basetexture\", globalRTs[ rtname ][ 1 ] )","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"pushViewMatrix":{"comment":["--- Pushes a perspective matrix onto the view matrix stack.","-- @param tbl The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"],"code":["function render_library.pushViewMatrix(tbl)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\tif tbl.type ~= \"2D\" and tbl.type ~= \"3D\" then SF.throw( \"Camera type must be \\\"3D\\\" or \\\"2D\\\"\", 2 ) end","\t","\tlocal newtbl = {}","\tfor k, v in pairs(tbl) do","\t\tif viewmatrix_checktypes[k] then","\t\t\tSF.CheckType( v, viewmatrix_checktypes[k] )","\t\t\tnewtbl[k] = v","\t\telse","\t\t\tSF.throw( \"Invalid key found in view matrix: \" .. k, 2 )","\t\tend","\tend","\tif newtbl.origin then newtbl.origin = SF.Vectors.Unwrap( newtbl.origin ) end","\tif newtbl.angles then newtbl.angles = SF.Angles.Unwrap( newtbl.angles ) end","\tif newtbl.offcenter then","\t\tSF.CheckType( tbl.offcenter.left, \"number\" )","\t\tSF.CheckType( tbl.offcenter.right, \"number\" )","\t\tSF.CheckType( tbl.offcenter.bottom, \"number\" )","\t\tSF.CheckType( tbl.offcenter.top, \"number\" )","\tend","\tif newtbl.ortho then","\t\tSF.CheckType( tbl.ortho.left, \"number\" )","\t\tSF.CheckType( tbl.ortho.right, \"number\" )","\t\tSF.CheckType( tbl.ortho.bottom, \"number\" )","\t\tSF.CheckType( tbl.ortho.top, \"number\" )","\tend","\t","\tcam.Start(newtbl)","\tview_matrix_stack = view_matrix_stack + 1","end",""],"class":"function","name":"render_library.pushViewMatrix","summary":"\nPushes a perspective matrix onto the view matrix stack.","private":false,"library":"render","description":"\nPushes a perspective matrix onto the view matrix stack.","param":{"1":"tbl","tbl":"The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"}},"popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end","","","local viewmatrix_checktypes =","{","\tx = \"number\", y = \"number\", w = \"number\", h = \"number\", type = \"string\",","\torigin = SF.Vectors.Metatable, angles = SF.Angles.Metatable, fov = \"number\",","\taspect = \"number\", zfar = \"number\", znear = \"number\", subrect = \"boolean\",","\tbloomtone = \"boolean\", offcenter = \"table\", ortho = \"table\"","}"],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"drawPoly":{"comment":["--- Draws a polygon.","-- @param poly Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"],"code":["function render_library.drawPoly(poly)","\tSF.CheckType(poly,\"table\")","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon.","param":{"1":"poly","poly":"Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"}},"capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\tif SF.instance.data.render.usingRT then","\t\trender.CapturePixels()","\tend","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"setTextureFromScreen":{"comment":["--- Sets the texture of a screen entity","-- @param ent Screen entity"],"code":["function render_library.setTextureFromScreen ( ent )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","","\tent = SF.Entities.Unwrap( ent )","\tif IsValid( ent ) and ent.GPU and ent.GPU.RT then","\t\tRT_Material:SetTexture(\"$basetexture\", ent.GPU.RT)","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","","end",""],"class":"function","name":"render_library.setTextureFromScreen","summary":"\nSets the texture of a screen entity ","private":false,"library":"render","description":"\nSets the texture of a screen entity","param":{"1":"ent","ent":"Screen entity"}}},"class":"library","summary":"\nRender library.","code":["","local render_library, _ = SF.Libraries.RegisterLocal(\"render\")","","render_library.TEXT_ALIGN_LEFT = TEXT_ALIGN_LEFT","render_library.TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER","render_library.TEXT_ALIGN_RIGHT = TEXT_ALIGN_RIGHT","render_library.TEXT_ALIGN_TOP = TEXT_ALIGN_TOP","render_library.TEXT_ALIGN_BOTTOM = TEXT_ALIGN_BOTTOM",""],"fields":[],"name":"render","description":"\nRender library. Screens are 512x512 units. Most functions require \nthat you be in the rendering hook to call, otherwise an error is \nthrown. +x is right, +y is down","entity":"starfall_screen","libtbl":"render_library","tables":[],"field":{"1":"TEXT_ALIGN_LEFT","2":"TEXT_ALIGN_CENTER","3":"TEXT_ALIGN_RIGHT","4":"TEXT_ALIGN_TOP","5":"TEXT_ALIGN_BOTTOM","TEXT_ALIGN_CENTER":"","TEXT_ALIGN_TOP":"","TEXT_ALIGN_BOTTOM":"","TEXT_ALIGN_LEFT":"","TEXT_ALIGN_RIGHT":""}},"quaternion":{"comment":["--- Quaternion library","-- @shared"],"functions":{"1":"New","2":"abs","3":"conj","4":"exp","5":"inv","6":"log","7":"qMod","8":"qRotation","9":"qRotation","10":"qi","11":"qj","12":"qk","13":"rotationAngle","14":"rotationAxis","15":"rotationEulerAngle","16":"rotationVector","17":"slerp","18":"vec","conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},"New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]}},"class":"library","summary":"\nQuaternion library ","code":["local quat_lib, quat_lib_metamethods = SF.Libraries.Register(\"quaternion\")","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Quaternion Support","-- Converted from Wiremod's E2 Quaternion library for general lua use","-- Original code for use by Bubbus","-- Permission received for use from Bubbus by Radon","-- http:\\\\wiki.wiremod.com/?title=Expression2#Quaternion","--","-- Credits to Radon for addition to Starfall","-- Credits to Divran for painful amounts of testing","]]","","-- faster access to some math library functions","local math = math -- Because global lookups suck","local setmetatable = setmetatable","local abs   = math.abs","local Round = math.Round","local sqrt  = math.sqrt","local exp   = math.exp","local log   = math.log","local sin   = math.sin","local cos   = math.cos","local sinh  = math.sinh","local cosh  = math.cosh","local acos  = math.acos","local min \t= math.min","","local delta = wire_expression2_delta or 0.0000001000000","","local isValid = IsValid","","local deg2rad = math.pi/180","local rad2deg = 180/math.pi",""],"fields":[],"name":"quaternion","client":true,"description":"\nQuaternion library","libtbl":"quat_lib","tables":[],"server":true},"bass":{"comment":["--- Bass library.","-- @client"],"functions":{"1":"loadFile","2":"loadURL","loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}}},"class":"library","summary":"\nBass library.","fields":[],"name":"bass","client":true,"description":"\nBass library.","libtbl":"bass_library","tables":[],"code":["local bass_library, _ = SF.Libraries.Register( \"bass\" )","","SF.Bass.Wrap = wrap","SF.Bass.Unwrap = unwrap","SF.Bass.Methods = bass_methods","SF.Bass.Metatable = bass_metamethods","","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.bass = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.bass.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tif s:IsValid() then","\t\t\ts:Stop()","\t\tend","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""]},"json":{"comment":["--- JSON library","-- @shared"],"functions":{"1":"decode","2":"encode","encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"class":"library","summary":"\nJSON library ","code":["local json_library, _ = SF.Libraries.Register( \"json\" )","local util = util",""],"fields":[],"name":"json","client":true,"description":"\nJSON library","libtbl":"json_library","tables":[],"server":true},"prop":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"createSent","4":"propsLeft","5":"setPropClean","6":"spawnRate","canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and instance.data.props.burst:check()>1","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\t","\t\tSF.setPos( entity, pos )","\t\tSF.setAng( entity, ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\t","\tif SF.Props.personalquota:GetInt() < 0 then return -1 end","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"setPropClean":{"comment":["--- Sets whether the chip should remove created props when the chip is removed","-- @param on Boolean whether the props should be cleaned or not"],"code":["function props_library.setPropClean( on )","\tSF.instance.data.props.clean = on","end",""],"class":"function","name":"props_library.setPropClean","summary":"\nSets whether the chip should remove created props when the chip is removed ","private":false,"library":"prop","description":"\nSets whether the chip should remove created props when the chip is removed","param":{"1":"on","on":"Boolean whether the props should be cleaned or not"}},"create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tprint(instance.data.props.burst:check())","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tSF.setPos( propent, pos )","\tSF.setAng( propent, ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},"spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end",""],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","code":["local props_library, props_library_metamethods = SF.Libraries.Register(\"prop\")","","local vunwrap = SF.UnwrapObject","","SF.Props = {}","","SF.Props.personalquota = CreateConVar( \"sf_props_personalquota\", \"-1\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts for a single instance\" )","","SF.Props.burstmax = CreateConVar( \"sf_props_burstmax\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Props.burstrate = CreateConVar( \"sf_props_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","-- Register privileges","SF.Permissions.registerPrivilege( \"prop.create\", \"Create prop\", \"Allows the user to create props\" )","","-- Table with player keys that automatically cleans when player leaves.","local plyCount = SF.EntityTable(\"playerProps\")","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.props = {","\t\tprops = {},","\t\tburst = SF.BurstObject( SF.Props.burstrate:GetFloat(), SF.Props.burstmax:GetFloat() )","\t}","","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tif inst.data.props.clean ~= false then --Return true on nil too","\t\tfor prop, _ in pairs(inst.data.props.props) do","\t\t\tlocal propent = SF.Entities.Unwrap(prop)","\t\t\tif IsValid(propent) then","\t\t\t\tpropent:Remove()","\t\t\tend","\t\tend","\tend","\t","\tinst.data.props.props = nil","end)","","local function propOnDestroy(propent, propdata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not propdata.props then return end","\tlocal prop = SF.Entities.Wrap(propent)","\tif propdata.props[prop] then","\t\tpropdata.props[prop] = nil","\tend","end",""],"fields":[],"name":"prop","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"props_library","tables":[],"server":true},"sounds":{"comment":["--- Sounds library.","-- @shared"],"functions":{"1":"create","create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}}},"class":"library","summary":"\nSounds library.","code":["local sound_library, _ = SF.Libraries.Register( \"sounds\" )","","SF.Sounds.Wrap = wrap","SF.Sounds.Unwrap = unwrap","SF.Sounds.Methods = sound_methods","SF.Sounds.Metatable = sound_metamethods","","-- Register Privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"sound.create\", \"Sound\", \"Allows the user to create sounds\" )","\tP.registerPrivilege( \"sound.modify\", \"Sound\", \"Allows the user to modify created sounds\" )","end","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.sounds = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.sounds.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tunwrap( s ):Stop()","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""],"fields":[],"name":"sounds","client":true,"description":"\nSounds library.","libtbl":"sound_library","tables":[],"server":true},"team":{"comment":["--- Library for retreiving information about teams","-- @shared"],"functions":{"1":"bestAutoJoinTeam","2":"exists","3":"getAllTeams","4":"getColor","5":"getJoinable","6":"getName","7":"getNumDeaths","8":"getNumFrags","9":"getNumPlayers","10":"getPlayers","11":"getScore","bestAutoJoinTeam":{"ret":"index of the best team to join","description":"\nReturns team with least players","code":["team_library.bestAutoJoinTeam = team.BestAutoJoinTeam",""],"class":"function","classForced":true,"name":"team_library.bestAutoJoinTeam","summary":"\nReturns team with least players ","library":"team","comment":["--- Returns team with least players","-- @name team_library.bestAutoJoinTeam","-- @class function","-- @return index of the best team to join"],"param":[]},"getScore":{"ret":"Number score of the team","description":"\nReturns the score of a team","code":["team_library.getScore =  team.GetScore",""],"class":"function","classForced":true,"name":"team_library.getScore","summary":"\nReturns the score of a team ","library":"team","comment":["--- Returns the score of a team","-- @name team_library.getScore","-- @class function","-- @param ind Index of the team","-- @return Number score of the team"],"param":{"1":"ind","ind":"Index of the team"}},"getNumDeaths":{"ret":"number of deaths","description":"\nReturns number of deaths of all players on a team","code":["team_library.getNumDeaths = team.TotalDeaths",""],"class":"function","classForced":true,"name":"team_library.getNumDeaths","summary":"\nReturns number of deaths of all players on a team ","library":"team","comment":["--- Returns number of deaths of all players on a team","-- @name team_library.getNumDeaths","-- @class function","-- @param ind Index of the team","-- @return number of deaths"],"param":{"1":"ind","ind":"Index of the team"}},"getAllTeams":{"ret":"table containing team information","comment":["--- Returns a table containing team information","-- @return table containing team information"],"code":["function team_library.getAllTeams()","\treturn SF.Sanitize(team.GetAllTeams())","end",""],"class":"function","name":"team_library.getAllTeams","summary":"\nReturns a table containing team information ","private":false,"library":"team","description":"\nReturns a table containing team information","param":[]},"getJoinable":{"ret":"boolean","description":"\nReturns whether or not a team can be joined","code":["team_library.getJoinable = team.Joinable",""],"class":"function","classForced":true,"name":"team_library.getJoinable","summary":"\nReturns whether or not a team can be joined ","library":"team","comment":["--- Returns whether or not a team can be joined","-- @name team_library.getJoinable","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"exists":{"ret":"boolean","description":"\nReturns whether or not the team exists","code":["team_library.exists = team.Valid",""],"class":"function","classForced":true,"name":"team_library.exists","summary":"\nReturns whether or not the team exists ","library":"team","comment":["--- Returns whether or not the team exists","-- @name team_library.exists","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"getColor":{"ret":"Color of the team","comment":["--- Returns the color of a team","-- @param ind Index of the team","-- @return Color of the team"],"code":["function team_library.getColor(ind)","\treturn cwrap(team.GetColor(ind)) ","end",""],"class":"function","name":"team_library.getColor","summary":"\nReturns the color of a team ","private":false,"library":"team","description":"\nReturns the color of a team","param":{"1":"ind","ind":"Index of the team"}},"getNumFrags":{"ret":"number of frags","description":"\nReturns number of frags of all players on a team","code":["team_library.getNumFrags = team.TotalFrags",""],"class":"function","classForced":true,"name":"team_library.getNumFrags","summary":"\nReturns number of frags of all players on a team ","library":"team","comment":["--- Returns number of frags of all players on a team","-- @name team_library.getNumFrags","-- @class function","-- @param ind Index of the team","-- @return number of frags"],"param":{"1":"ind","ind":"Index of the team"}},"getNumPlayers":{"ret":"number of players","description":"\nReturns number of players on a team","code":["team_library.getNumPlayers = team.NumPlayers",""],"class":"function","classForced":true,"name":"team_library.getNumPlayers","summary":"\nReturns number of players on a team ","library":"team","comment":["--- Returns number of players on a team","-- @name team_library.getNumPlayers","-- @class function","-- @param ind Index of the team","-- @return number of players"],"param":{"1":"ind","ind":"Index of the team"}},"getPlayers":{"ret":"Table of players","comment":["--- Returns the table of players on a team","-- @param ind Index of the team","-- @return Table of players"],"code":["function team_library.getPlayers(ind)","\treturn SF.Sanitize(team.GetPlayers(ind))","end",""],"class":"function","name":"team_library.getPlayers","summary":"\nReturns the table of players on a team ","private":false,"library":"team","description":"\nReturns the table of players on a team","param":{"1":"ind","ind":"Index of the team"}},"getName":{"ret":"String name of the team","description":"\nReturns the name of a team","code":["team_library.getName = team.GetName",""],"class":"function","classForced":true,"name":"team_library.getName","summary":"\nReturns the name of a team ","library":"team","comment":["--- Returns the name of a team","-- @name team_library.getName","-- @class function","-- @param ind Index of the team","-- @return String name of the team"],"param":{"1":"ind","ind":"Index of the team"}}},"class":"library","summary":"\nLibrary for retreiving information about teams ","code":["local team_library, team_library_metamethods = SF.Libraries.Register(\"team\")","local cwrap, cunwrap","SF.Libraries.AddHook(\"postload\", function()","\tcwrap = SF.Color.Wrap","\tcunwrap = SF.Color.Unwrap","end)",""],"fields":[],"name":"team","client":true,"description":"\nLibrary for retreiving information about teams","libtbl":"team_library","tables":[],"server":true},"trace":{"comment":["--- Provides functions for doing line/AABB traces","-- @shared","-- @field MAT_ANTLION","-- @field MAT_BLOODYFLESH","-- @field MAT_CONCRETE","-- @field MAT_DIRT","-- @field MAT_FLESH","-- @field MAT_GRATE","-- @field MAT_ALIENFLESH","-- @field MAT_CLIP","-- @field MAT_PLASTIC","-- @field MAT_METAL","-- @field MAT_SAND","-- @field MAT_FOLIAGE","-- @field MAT_COMPUTER","-- @field MAT_SLOSH","-- @field MAT_TILE","-- @field MAT_VENT","-- @field MAT_WOOD","-- @field MAT_GLASS","-- @field HITGROUP_GENERIC","-- @field HITGROUP_HEAD","-- @field HITGROUP_CHEST","-- @field HITGROUP_STOMACH","-- @field HITGROUP_LEFTARM","-- @field HITGROUP_RIGHTARM","-- @field HITGROUP_LEFTLEG","-- @field HITGROUP_RIGHTLEG","-- @field HITGROUP_GEAR","-- @field MASK_SPLITAREAPORTAL","-- @field MASK_SOLID_BRUSHONLY","-- @field MASK_WATER","-- @field MASK_BLOCKLOS","-- @field MASK_OPAQUE","-- @field MASK_VISIBLE","-- @field MASK_DEADSOLID","-- @field MASK_PLAYERSOLID_BRUSHONLY","-- @field MASK_NPCWORLDSTATIC","-- @field MASK_NPCSOLID_BRUSHONLY","-- @field MASK_CURRENT","-- @field MASK_SHOT_PORTAL","-- @field MASK_SOLID","-- @field MASK_BLOCKLOS_AND_NPCS","-- @field MASK_OPAQUE_AND_NPCS","-- @field MASK_VISIBLE_AND_NPCS","-- @field MASK_PLAYERSOLID","-- @field MASK_NPCSOLID","-- @field MASK_SHOT_HULL","-- @field MASK_SHOT","-- @field MASK_ALL","-- @field CONTENTS_EMPTY","-- @field CONTENTS_SOLID","-- @field CONTENTS_WINDOW","-- @field CONTENTS_AUX","-- @field CONTENTS_GRATE","-- @field CONTENTS_SLIME","-- @field CONTENTS_WATER","-- @field CONTENTS_BLOCKLOS","-- @field CONTENTS_OPAQUE","-- @field CONTENTS_TESTFOGVOLUME","-- @field CONTENTS_TEAM4","-- @field CONTENTS_TEAM3","-- @field CONTENTS_TEAM1","-- @field CONTENTS_TEAM2","-- @field CONTENTS_IGNORE_NODRAW_OPAQUE","-- @field CONTENTS_MOVEABLE","-- @field CONTENTS_AREAPORTAL","-- @field CONTENTS_PLAYERCLIP","-- @field CONTENTS_MONSTERCLIP","-- @field CONTENTS_CURRENT_0","-- @field CONTENTS_CURRENT_90","-- @field CONTENTS_CURRENT_180","-- @field CONTENTS_CURRENT_270","-- @field CONTENTS_CURRENT_UP","-- @field CONTENTS_CURRENT_DOWN","-- @field CONTENTS_ORIGIN","-- @field CONTENTS_MONSTER","-- @field CONTENTS_DEBRIS","-- @field CONTENTS_DETAIL","-- @field CONTENTS_TRANSLUCENT","-- @field CONTENTS_LADDER","-- @field CONTENTS_HITBOX"],"functions":{"1":"trace","2":"traceHull","traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\tlocal data = util.TraceHull( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}},"trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\tlocal data = util.TraceLine( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","endpos":"End position"}}},"class":"library","summary":"\nProvides functions for doing line/AABB traces ","field":{"1":"MAT_ANTLION","2":"MAT_BLOODYFLESH","3":"MAT_CONCRETE","4":"MAT_DIRT","5":"MAT_FLESH","6":"MAT_GRATE","7":"MAT_ALIENFLESH","8":"MAT_CLIP","9":"MAT_PLASTIC","10":"MAT_METAL","11":"MAT_SAND","12":"MAT_FOLIAGE","13":"MAT_COMPUTER","14":"MAT_SLOSH","15":"MAT_TILE","16":"MAT_VENT","17":"MAT_WOOD","18":"MAT_GLASS","19":"HITGROUP_GENERIC","20":"HITGROUP_HEAD","21":"HITGROUP_CHEST","22":"HITGROUP_STOMACH","23":"HITGROUP_LEFTARM","24":"HITGROUP_RIGHTARM","25":"HITGROUP_LEFTLEG","26":"HITGROUP_RIGHTLEG","27":"HITGROUP_GEAR","28":"MASK_SPLITAREAPORTAL","29":"MASK_SOLID_BRUSHONLY","30":"MASK_WATER","31":"MASK_BLOCKLOS","32":"MASK_OPAQUE","33":"MASK_VISIBLE","34":"MASK_DEADSOLID","35":"MASK_PLAYERSOLID_BRUSHONLY","36":"MASK_NPCWORLDSTATIC","37":"MASK_NPCSOLID_BRUSHONLY","38":"MASK_CURRENT","39":"MASK_SHOT_PORTAL","40":"MASK_SOLID","41":"MASK_BLOCKLOS_AND_NPCS","42":"MASK_OPAQUE_AND_NPCS","43":"MASK_VISIBLE_AND_NPCS","44":"MASK_PLAYERSOLID","45":"MASK_NPCSOLID","46":"MASK_SHOT_HULL","47":"MASK_SHOT","48":"MASK_ALL","49":"CONTENTS_EMPTY","50":"CONTENTS_SOLID","51":"CONTENTS_WINDOW","52":"CONTENTS_AUX","53":"CONTENTS_GRATE","54":"CONTENTS_SLIME","55":"CONTENTS_WATER","56":"CONTENTS_BLOCKLOS","57":"CONTENTS_OPAQUE","58":"CONTENTS_TESTFOGVOLUME","59":"CONTENTS_TEAM4","60":"CONTENTS_TEAM3","61":"CONTENTS_TEAM1","62":"CONTENTS_TEAM2","63":"CONTENTS_IGNORE_NODRAW_OPAQUE","64":"CONTENTS_MOVEABLE","65":"CONTENTS_AREAPORTAL","66":"CONTENTS_PLAYERCLIP","67":"CONTENTS_MONSTERCLIP","68":"CONTENTS_CURRENT_0","69":"CONTENTS_CURRENT_90","70":"CONTENTS_CURRENT_180","71":"CONTENTS_CURRENT_270","72":"CONTENTS_CURRENT_UP","73":"CONTENTS_CURRENT_DOWN","74":"CONTENTS_ORIGIN","75":"CONTENTS_MONSTER","76":"CONTENTS_DEBRIS","77":"CONTENTS_DETAIL","78":"CONTENTS_TRANSLUCENT","79":"CONTENTS_LADDER","80":"CONTENTS_HITBOX","MASK_DEADSOLID":"","MASK_BLOCKLOS":"","CONTENTS_EMPTY":"","MASK_OPAQUE":"","CONTENTS_IGNORE_NODRAW_OPAQUE":"","MASK_VISIBLE":"","HITGROUP_LEFTLEG":"","MASK_PLAYERSOLID_BRUSHONLY":"","HITGROUP_RIGHTARM":"","CONTENTS_CURRENT_DOWN":"","CONTENTS_OPAQUE":"","MAT_TILE":"","MAT_FOLIAGE":"","HITGROUP_HEAD":"","MASK_SHOT":"","MAT_COMPUTER":"","CONTENTS_TEAM3":"","MASK_SPLITAREAPORTAL":"","CONTENTS_CURRENT_UP":"","MAT_CONCRETE":"","MAT_CLIP":"","MAT_WOOD":"","MAT_ANTLION":"","MASK_NPCSOLID_BRUSHONLY":"","CONTENTS_DEBRIS":"","MASK_SHOT_PORTAL":"","HITGROUP_STOMACH":"","MAT_SLOSH":"","CONTENTS_PLAYERCLIP":"","MASK_NPCWORLDSTATIC":"","MASK_OPAQUE_AND_NPCS":"","MAT_BLOODYFLESH":"","MASK_BLOCKLOS_AND_NPCS":"","CONTENTS_TEAM1":"","HITGROUP_CHEST":"","CONTENTS_AREAPORTAL":"","HITGROUP_GENERIC":"","MAT_METAL":"","HITGROUP_GEAR":"","MAT_VENT":"","MAT_PLASTIC":"","CONTENTS_CURRENT_180":"","MAT_ALIENFLESH":"","MAT_FLESH":"","MAT_GLASS":"","CONTENTS_HITBOX":"","CONTENTS_LADDER":"","CONTENTS_MONSTER":"","CONTENTS_ORIGIN":"","CONTENTS_TEAM2":"","CONTENTS_DETAIL":"","CONTENTS_GRATE":"","MASK_NPCSOLID":"","CONTENTS_MOVEABLE":"","CONTENTS_TRANSLUCENT":"","CONTENTS_CURRENT_270":"","MASK_VISIBLE_AND_NPCS":"","CONTENTS_SOLID":"","CONTENTS_MONSTERCLIP":"","MAT_SAND":"","CONTENTS_SLIME":"","CONTENTS_CURRENT_0":"","CONTENTS_WINDOW":"","MASK_PLAYERSOLID":"","MASK_ALL":"","CONTENTS_BLOCKLOS":"","MASK_WATER":"","MASK_SOLID_BRUSHONLY":"","HITGROUP_RIGHTLEG":"","CONTENTS_CURRENT_90":"","CONTENTS_AUX":"","MASK_CURRENT":"","MAT_DIRT":"","CONTENTS_TEAM4":"","CONTENTS_TESTFOGVOLUME":"","CONTENTS_WATER":"","MASK_SOLID":"","MASK_SHOT_HULL":"","HITGROUP_LEFTARM":"","MAT_GRATE":""},"code":["local trace_library, _ = SF.Libraries.Register(\"trace\")","","-- Material Enumeration","trace_library.MAT_ANTLION = MAT_ANTLION","trace_library.MAT_BLOODYFLESH = MAT_BLOODYFLESH","trace_library.MAT_CONCRETE = MAT_CONCRETE","trace_library.MAT_DIRT = MAT_DIRT","trace_library.MAT_FLESH = MAT_FLESH","trace_library.MAT_GRATE = MAT_GRATE","trace_library.MAT_ALIENFLESH = MAT_ALIENFLESH","trace_library.MAT_CLIP = MAT_CLIP","trace_library.MAT_PLASTIC = MAT_PLASTIC","trace_library.MAT_METAL = MAT_METAL","trace_library.MAT_SAND = MAT_SAND","trace_library.MAT_FOLIAGE = MAT_FOLIAGE","trace_library.MAT_COMPUTER = MAT_COMPUTER","trace_library.MAT_SLOSH = MAT_SLOSH","trace_library.MAT_TILE = MAT_TILE","trace_library.MAT_VENT = MAT_VENT","trace_library.MAT_WOOD = MAT_WOOD","trace_library.MAT_GLASS = MAT_GLASS","","-- Hithroup Enumeration","trace_library.HITGROUP_GENERIC = HITGROUP_GENERIC","trace_library.HITGROUP_HEAD = HITGROUP_HEAD","trace_library.HITGROUP_CHEST = HITGROUP_CHEST","trace_library.HITGROUP_STOMACH = HITGROUP_STOMACH","trace_library.HITGROUP_LEFTARM = HITGROUP_LEFTARM","trace_library.HITGROUP_RIGHTARM = HITGROUP_RIGHTARM","trace_library.HITGROUP_LEFTLEG = HITGROUP_LEFTLEG","trace_library.HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG","trace_library.HITGROUP_GEAR = HITGROUP_GEAR","","-- Mask Enumerations","trace_library.MASK_SPLITAREAPORTAL = MASK_SPLITAREAPORTAL","trace_library.MASK_SOLID_BRUSHONLY = MASK_SOLID_BRUSHONLY","trace_library.MASK_WATER = MASK_WATER","trace_library.MASK_BLOCKLOS = MASK_BLOCKLOS","trace_library.MASK_OPAQUE = MASK_OPAQUE","trace_library.MASK_VISIBLE = MASK_VISIBLE","trace_library.MASK_DEADSOLID = MASK_DEADSOLID","trace_library.MASK_PLAYERSOLID_BRUSHONLY = MASK_PLAYERSOLID_BRUSHONLY","trace_library.MASK_NPCWORLDSTATIC = MASK_NPCWORLDSTATIC","trace_library.MASK_NPCSOLID_BRUSHONLY = MASK_NPCSOLID_BRUSHONLY","trace_library.MASK_CURRENT = MASK_CURRENT","trace_library.MASK_SHOT_PORTAL = MASK_SHOT_PORTAL","trace_library.MASK_SOLID = MASK_SOLID","trace_library.MASK_BLOCKLOS_AND_NPCS = MASK_BLOCKLOS_AND_NPCS","trace_library.MASK_OPAQUE_AND_NPCS = MASK_OPAQUE_AND_NPCS","trace_library.MASK_VISIBLE_AND_NPCS = MASK_VISIBLE_AND_NPCS","trace_library.MASK_PLAYERSOLID = MASK_PLAYERSOLID","trace_library.MASK_NPCSOLID = MASK_NPCSOLID","trace_library.MASK_SHOT_HULL = MASK_SHOT_HULL","trace_library.MASK_SHOT = MASK_SHOT","trace_library.MASK_ALL = MASK_ALL","","-- Content Enumerations","trace_library.CONTENTS_EMPTY = CONTENTS_EMPTY","trace_library.CONTENTS_SOLID = CONTENTS_SOLID","trace_library.CONTENTS_WINDOW = CONTENTS_WINDOW","trace_library.CONTENTS_AUX = CONTENTS_AUX","trace_library.CONTENTS_GRATE = CONTENTS_GRATE","trace_library.CONTENTS_SLIME = CONTENTS_SLIME","trace_library.CONTENTS_WATER = CONTENTS_WATER","trace_library.CONTENTS_BLOCKLOS = CONTENTS_BLOCKLOS","trace_library.CONTENTS_OPAQUE = CONTENTS_OPAQUE","trace_library.CONTENTS_TESTFOGVOLUME = CONTENTS_TESTFOGVOLUME","trace_library.CONTENTS_TEAM4 = CONTENTS_TEAM4","trace_library.CONTENTS_TEAM3 = CONTENTS_TEAM3","trace_library.CONTENTS_TEAM1 = CONTENTS_TEAM1","trace_library.CONTENTS_TEAM2 = CONTENTS_TEAM2","trace_library.CONTENTS_IGNORE_NODRAW_OPAQUE = CONTENTS_IGNORE_NODRAW_OPAQUE","trace_library.CONTENTS_MOVEABLE = CONTENTS_MOVEABLE","trace_library.CONTENTS_AREAPORTAL = CONTENTS_AREAPORTAL","trace_library.CONTENTS_PLAYERCLIP = CONTENTS_PLAYERCLIP","trace_library.CONTENTS_MONSTERCLIP = CONTENTS_MONSTERCLIP","trace_library.CONTENTS_CURRENT_0 = CONTENTS_CURRENT_0","trace_library.CONTENTS_CURRENT_90 = CONTENTS_CURRENT_90","trace_library.CONTENTS_CURRENT_180 = CONTENTS_CURRENT_180","trace_library.CONTENTS_CURRENT_270 = CONTENTS_CURRENT_270","trace_library.CONTENTS_CURRENT_UP = CONTENTS_CURRENT_UP","trace_library.CONTENTS_CURRENT_DOWN = CONTENTS_CURRENT_DOWN","trace_library.CONTENTS_ORIGIN = CONTENTS_ORIGIN","trace_library.CONTENTS_MONSTER = CONTENTS_MONSTER","trace_library.CONTENTS_DEBRIS = CONTENTS_DEBRIS","trace_library.CONTENTS_DETAIL = CONTENTS_DETAIL","trace_library.CONTENTS_TRANSLUCENT = CONTENTS_TRANSLUCENT","trace_library.CONTENTS_LADDER = CONTENTS_LADDER","trace_library.CONTENTS_HITBOX = CONTENTS_HITBOX","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"trace\", \"Trace\", \"Allows the user to start traces\" )","end","","-- Local functions","","local wrap","local unwrap","","local function postload()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","end","SF.Libraries.AddHook(\"postload\",postload)","","local function convertFilter(filter)","\tlocal unwrapped = unwrap(filter)","\tif unwrapped then","\t\treturn {unwrapped}","\telse","\t\tlocal l = {}","\t\tlocal count = 1","\t\tfor i=1,#filter do","\t\t\tlocal unwrapped = unwrap(filter[i])","\t\t\tif unwrapped then","\t\t\t\tl[count] = unwrapped","\t\t\t\tcount = count + 1","\t\t\tend","\t\tend","\t\treturn l","\tend","end",""],"fields":[],"name":"trace","client":true,"description":"\nProvides functions for doing line/AABB traces","libtbl":"trace_library","tables":[],"server":true},"coroutine":{"comment":["--- Coroutine library","-- @shared"],"functions":{"1":"create","2":"resume","3":"running","4":"status","5":"wait","6":"wrap","7":"yield","resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},"running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn SF.instance.data.coroutines[ thread ]","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedThread","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tSF.CheckType( time, \"number\" )","\tcoroutine.wait( time )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}},"class":"library","summary":"\nCoroutine library ","code":["local coroutine_library, _ = SF.Libraries.Register( \"coroutine\" )","local coroutine = coroutine","","local _, thread_metamethods = SF.Typedef( \"thread\" )","local wrap, unwrap = SF.CreateWrapper( thread_metamethods, true, false )","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.coroutines = setmetatable( {}, { __mode = \"v\" } )","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor thread, wrapped in pairs(instance.data.coroutines) do","\t\tlocal unwrapped = unwrap( wrapped )","\t\tunwrapped.thread = nil","\t\tunwrapped.func = nil","\t\tinstance.data.coroutines[ thread ] = nil","\tend","end)","","","local function createCoroutine ( func )","\t-- Can't use coroutine.create, because of a bug that prevents halting the program when it exceeds quota","","\t-- Hack to get the coroutine from a wrapped function. Necessary because coroutine.create is not available","\tlocal wrappedFunc = coroutine.wrap( function() return func( coroutine.yield( coroutine.running() ) ) end ) ","\t","\tlocal thread = wrappedFunc()","","\tlocal wrappedThread = wrap( { thread = thread, func = wrappedFunc } )","\t","\tSF.instance.data.coroutines[ thread ] = wrappedThread","\t","\treturn wrappedFunc, wrappedThread","end",""],"fields":[],"name":"coroutine","client":true,"description":"\nCoroutine library","libtbl":"coroutine_library","tables":[],"server":true},"wire":{"comment":["--- Wire library. Handles wire inputs/outputs, wirelinks, etc."],"functions":{"1":"adjustInputs","2":"adjustOutputs","3":"create","4":"delete","5":"getInputs","6":"getOutputs","7":"getWirelink","8":"self","adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}}},"class":"library","fields":[],"name":"wire","summary":"\nWire library.","description":"\nWire library. Handles wire inputs/outputs, wirelinks, etc.","libtbl":"wire_library","tables":{"1":"ports","ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]}},"code":["local wire_library, wire_metamethods = SF.Libraries.Register( \"wire\" )","","function wire_metamethods.onLoad ( instance )","\tif not WireLib then return end","\tlocal ent = instance.data.entity","\tif ent.Inputs == nil then","\t\tWireLib.CreateInputs( ent, {} )","\tend","\tif ent.Outputs == nil then","\t\tWireLib.CreateOutputs( ent, {} )","\tend","","\tfunction ent:TriggerInput ( key, value )","\t\tself:runScriptHook( \"input\", key, SF.Wire.InputConverters[ self.Inputs[ key ].Type ]( value ) )","\tend","","\tfunction ent:ReadCell ( address )","\t\tlocal ret = tonumber( self:runScriptHookForResult( \"readcell\", address ) ) or 0","\t\treturn ret","\tend","","\tfunction ent:WriteCell ( address, data )","\t\tlocal ret = self:runScriptHookForResult( \"writecell\", address, data )","\t\treturn ret==nil or ret==true","\tend","","end","","SF.Wire = {}","SF.Wire.Library = wire_library",""]},"joystick":{"comment":["--- Joystick library.","-- @client"],"functions":{"1":"getAxis","2":"getButton","3":"getName","4":"getPov","5":"numAxes","6":"numButtons","7":"numJoysticks","8":"numPovs","numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},"getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}},"class":"library","summary":"\nJoystick library.","fields":[],"name":"joystick","client":true,"description":"\nJoystick library.","libtbl":"joystick_library","tables":[],"code":["local joystick_library, _ = SF.Libraries.Register(\"joystick\")","","","if file.Exists(\"lua/bin/gmcl_joystick_win32.dll\", \"GAME\") then","\trequire(\"joystick\")","end","","local next_updates = {}","","local function refresh( enum )","\tenum = math.Clamp( enum, 0, 12 )","\tlocal next_update = next_updates[ enum ] or 0","\tif CurTime()>next_update then","\t\tnext_updates[ enum ] = CurTime() + 0.0303","\t\tjoystick.refresh( enum )","\tend","end",""]},"fastlz":{"comment":["--- FastLZ library","-- @shared"],"functions":{"1":"compress","2":"decompress","decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}},"compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}}},"class":"library","summary":"\nFastLZ library ","code":["local fastlz_library, _ = SF.Libraries.Register( \"fastlz\" )","local util = util",""],"fields":[],"name":"fastlz","client":true,"description":"\nFastLZ library","libtbl":"fastlz_library","tables":[],"server":true},"holograms":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Holograms\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"hologramsLeft","canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return false end","\treturn plyCount[ SF.instance.player ] < SF.Holograms.personalquota:GetInt()","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","\tSF.CheckType( pos, vec_meta )","\tSF.CheckType( ang, ang_meta )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","\tif scale then","\t\tSF.CheckType( scale, vec_meta )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = aunwrap( ang )","","\tlocal instance = SF.instance","\tlocal holodata = instance.data.holograms","\t","\tif plyCount[ instance.player ] >= SF.Holograms.personalquota:GetInt() then ","\t\tSF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 ) ","\tend","","\tlocal holoent = ents.Create( \"starfall_hologram\" )","\tif holoent and holoent:IsValid() then","\t\tSF.setPos( holoent, pos )","\t\tSF.setAng( holoent, ang )","\t\tholoent:SetModel( model )","\t\tholoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","\t\tholoent:Spawn()","","\t\tif CPPI then","\t\t\tholoent:CPPISetOwner( instance.player )","\t\tend","\t\t","\t\tif scale then","\t\t\tholoent:SetScale( scale )","\t\tend","","\t\tholodata.holos[ holoent ] = true","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t\t","\t\treturn wrap( holoent )","\tend","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},"hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\treturn SF.Holograms.personalquota:GetInt() - plyCount[ SF.instance.player ]","end"],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","code":["local holograms_library, holograms_library_metamethods = SF.Libraries.Register(\"holograms\")",""],"fields":[],"name":"holograms","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","libtbl":"holograms_library","tables":[],"server":true},"game":{"comment":["--- Game functions","-- @shared"],"functions":{"1":"getGamemode","2":"getHostname","3":"getMap","4":"getMaxPlayers","5":"isDedicated","6":"isLan","7":"isSinglePlayer","getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},"getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]}},"class":"library","summary":"\nGame functions ","code":["local game_lib, _ = SF.Libraries.Register( \"game\" )",""],"fields":[],"name":"game","client":true,"description":"\nGame functions","libtbl":"game_lib","tables":[],"server":true},"net":{"comment":["--- Net message library. Used for sending data from the server to the client and back"],"functions":{"1":"getBytesLeft","2":"readAngle","3":"readBit","4":"readColor","5":"readData","6":"readDouble","7":"readEntity","8":"readFloat","9":"readInt","10":"readMatrix","11":"readStream","12":"readString","13":"readUInt","14":"readVector","15":"send","16":"start","17":"writeAngle","18":"writeBit","19":"writeColor","20":"writeData","21":"writeDouble","22":"writeEntity","23":"writeFloat","24":"writeInt","25":"writeMatrix","26":"writeStream","27":"writeString","28":"writeUInt","29":"writeVector","writeVector":{"comment":["--- Writes an vector to the net message","-- @shared","-- @param t The vector to be written"],"code":["","function net_library.writeVector( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Vector\"] )","","\twrite( instance, \"Vector\", 12, SF.Vectors.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an vector to the net message ","library":"net","name":"net_library.writeVector","server":true,"private":false,"client":true,"description":"\nWrites an vector to the net message","param":{"1":"t","t":"The vector to be written"}},"readColor":{"ret":"The color that was read","comment":["--- Reads a color from the net message","-- @shared","-- @return The color that was read"],"code":["","function net_library.readColor()","\treturn SF.Color.Wrap( net.ReadColor() )","end",""],"class":"function","summary":"\nReads a color from the net message ","library":"net","name":"net_library.readColor","server":true,"private":false,"client":true,"description":"\nReads a color from the net message","param":[]},"readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tif not instance.data.net.burst:use( instance.data.net.size ) then","\t\tSF.throw( \"Net message exceeds limit!\", 3 )","\tend","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tnet[ data[ i ][ 1 ] ]( unpack( data[ i ][ 2 ] ) )","\tend","","\tif SERVER then","\t\tlocal sendfunc, newtarget","","\t\tif target then","\t\t\tif target[1] then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tlocal pl = SF.Entities.Unwrap( target[ i ] )","\t\t\t\t\tif IsValid( pl ) and pl:IsPlayer() then","\t\t\t\t\t\tnt[ #nt + 1 ] = pl","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\t\tif not IsValid( newtarget ) or not newtarget:IsPlayer() then SF.throw( \"Invalid player\", 2 ) end","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","","\tinstance.data.net.size = 0","\tinstance.data.net.data = {}","\tinstance.data.net.started = false","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"writeAngle":{"comment":["--- Writes an angle to the net message","-- @shared","-- @param t The angle to be written"],"code":["","function net_library.writeAngle( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Angle\"] )","","\twrite( instance, \"Angle\", 12, SF.Angles.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an angle to the net message ","library":"net","name":"net_library.writeAngle","server":true,"private":false,"client":true,"description":"\nWrites an angle to the net message","param":{"1":"t","t":"The angle to be written"}},"writeStream":{"comment":["--- Streams a large 20MB string. ","-- @shared","-- @param str The string to be written"],"code":["function net_library.writeStream( str )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( str, \"string\" )","\twrite( instance, \"Stream\", 8, str )","\treturn true","end",""],"class":"function","summary":"\nStreams a large 20MB string.","library":"net","name":"net_library.writeStream","server":true,"private":false,"client":true,"description":"\nStreams a large 20MB string.","param":{"1":"str","str":"The string to be written"}},"readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", 1, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"writeMatrix":{"comment":["--- Writes an matrix to the net message","-- @shared","-- @param t The matrix to be written"],"code":["","function net_library.writeMatrix( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"VMatrix\"] )","","\twrite( instance, \"Matrix\", 64, SF.VMatrix.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an matrix to the net message ","library":"net","name":"net_library.writeMatrix","server":true,"private":false,"client":true,"description":"\nWrites an matrix to the net message","param":{"1":"t","t":"The matrix to be written"}},"readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"getBytesLeft":{"ret":"number of bytes that can be sent","comment":["--- Returns available bandwidth in bytes","-- @return number of bytes that can be sent"],"code":["function net_library.getBytesLeft()","\treturn SF.instance.data.net.burst:check() - SF.instance.data.net.size","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tif ent.instance then","\t\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\t\tend","\tend","end)",""],"class":"function","name":"net_library.getBytesLeft","summary":"\nReturns available bandwidth in bytes ","private":false,"library":"net","description":"\nReturns available bandwidth in bytes","param":[]},"readEntity":{"ret":"The entity that was read","comment":["--- Reads a entity from the net message","-- @shared","-- @return The entity that was read"],"code":["","function net_library.readEntity()","\treturn SF.WrapObject( net.ReadEntity() )","end",""],"class":"function","summary":"\nReads a entity from the net message ","library":"net","name":"net_library.readEntity","server":true,"private":false,"client":true,"description":"\nReads a entity from the net message","param":[]},"writeEntity":{"comment":["--- Writes an entity to the net message","-- @shared","-- @param t The entity to be written"],"code":["","function net_library.writeEntity( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Entity\"] )","","\twrite( instance, \"Entity\", 2, SF.UnwrapObject( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an entity to the net message ","library":"net","name":"net_library.writeEntity","server":true,"private":false,"client":true,"description":"\nWrites an entity to the net message","param":{"1":"t","t":"The entity to be written"}},"readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},"writeColor":{"comment":["--- Writes an color to the net message","-- @shared","-- @param t The color to be written"],"code":["","function net_library.writeColor( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Color\"] )","","\twrite( instance, \"Color\", 4, SF.Color.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an color to the net message ","library":"net","name":"net_library.writeColor","server":true,"private":false,"client":true,"description":"\nWrites an color to the net message","param":{"1":"t","t":"The color to be written"}},"readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"readVector":{"ret":"The vector that was read","comment":["--- Reads a vector from the net message","-- @shared","-- @return The vector that was read"],"code":["","function net_library.readVector()","\treturn SF.Vectors.Wrap( net.ReadVector() )","end",""],"class":"function","summary":"\nReads a vector from the net message ","library":"net","name":"net_library.readVector","server":true,"private":false,"client":true,"description":"\nReads a vector from the net message","param":[]},"readStream":{"comment":["--- Reads a large string stream from the net message","-- @shared","-- @param cb Callback to run when the stream is finished. The first parameter in the callback is the data."],"code":["","function net_library.readStream( cb )","\tSF.CheckType( cb, \"function\" )","\tlocal instance = SF.instance","\tif streams[instance.player] then SF.throw( \"The previous stream must finish before reading another.\", 2 ) end","\tstreams[instance.player] = true","\t","\tnet.ReadStream( ( SERVER and instance.player or nil ), function( data )","\t\tlocal ok, msg, traceback = instance:runFunction( cb, data )","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\t\tstreams[instance.player] = false","\tend )","end",""],"class":"function","summary":"\nReads a large string stream from the net message ","library":"net","name":"net_library.readStream","server":true,"private":false,"client":true,"description":"\nReads a large string stream from the net message","param":{"1":"cb","cb":"Callback to run when the stream is finished. The first parameter in the callback is the data."}},"writeString":{"comment":["--- Writes a string to the net message. Null characters will terminate the string.","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", #t, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message.","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message. Null characters will terminate the string.","param":{"1":"t","t":"The string to be written"}},"readAngle":{"ret":"The angle that was read","comment":["--- Reads an angle from the net message","-- @shared","-- @return The angle that was read"],"code":["","function net_library.readAngle()","\treturn SF.Angles.Wrap( net.ReadAngle() )","end",""],"class":"function","summary":"\nReads an angle from the net message ","library":"net","name":"net_library.readAngle","server":true,"private":false,"client":true,"description":"\nReads an angle from the net message","param":[]},"writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", 4, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}},"writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", 8, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.started then SF.throw( \"net message was already started\", 2 ) end","","\tinstance.data.net.started = true","\tinstance.data.net.size = 8 -- 8 bytes overhead","\tinstance.data.net.data = {}","","\twrite( instance, \"String\", #name, name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"writeData":{"comment":["--- Writes string containing null characters to the net message","-- @shared","-- @param t The string to be written","-- @param n How much of the string to write"],"code":["","function net_library.writeData( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Data\", n, t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites string containing null characters to the net message ","library":"net","name":"net_library.writeData","server":true,"private":false,"client":true,"description":"\nWrites string containing null characters to the net message","param":{"1":"t","2":"n","n":"How much of the string to write","t":"The string to be written"}},"readData":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @param n How many characters are in the data","-- @return The string that was read"],"code":["","function net_library.readData( n )","\tSF.CheckType( n, \"number\" )","\tn = math.Clamp( n, 0, 64000 )","\treturn net.ReadData( n )","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readData","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":{"1":"n","n":"How many characters are in the data"}},"readMatrix":{"ret":"The matrix that was read","comment":["--- Reads a matrix from the net message","-- @shared","-- @return The matrix that was read"],"code":["","function net_library.readMatrix()","\treturn SF.VMatrix.Wrap( net.ReadMatrix() )","end",""],"class":"function","summary":"\nReads a matrix from the net message ","library":"net","name":"net_library.readMatrix","server":true,"private":false,"client":true,"description":"\nReads a matrix from the net message","param":[]}},"class":"library","fields":[],"name":"net","summary":"\nNet message library.","description":"\nNet message library. Used for sending data from the server to the client and back","libtbl":"net_library","tables":[],"code":["local net_library, _ = SF.Libraries.Register(\"net\")","","local burst_limit = CreateConVar( \"sf_net_burstmax\", \"10\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\"The net message burst limit in kB.\" )","","local burst_rate = CreateConVar( \"sf_net_burstrate\", \"5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\t\"Regen rate of net message burst in kB/sec.\" )","","","local streams = SF.EntityTable(\"playerStreams\")","","local function write( instance, type, size, ... )","\tinstance.data.net.size = instance.data.net.size + size","","\tinstance.data.net.data[#instance.data.net.data+1] = { \"Write\" .. type, {...} }","end","","local instances = {}","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.net = {","\t\tstarted = false,","\t\tburst = SF.BurstObject( burst_rate:GetFloat()*1000, burst_limit:GetFloat()*1000 ),","\t\tsize = 0,","\t\tdata = {},","\t}","end)","","SF.Libraries.AddHook( \"cleanup\", function ( instance )","\tinstance.data.net.started = false","\tinstance.data.net.data = {}","end )","","if SERVER then","\tutil.AddNetworkString( \"SF_netmessage\" )","end",""]},"von":{"comment":["--- vON Library","-- @shared"],"functions":{"1":"deserialize","2":"serialize","serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable({},_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}},"deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable({},_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}}},"class":"library","summary":"\nvON Library ","code":["local von, _ = SF.Libraries.Register(\"von\")","","local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable","local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next","","","","--[[    This section contains localized functions which (de)serialize","        variables according to the types found.                          ]]","","","","--\tThis is kept away from the table for speed.","function d_findVariable(s, i, len, lastType, jobstate)","\tlocal i, c, typeRead, val = i or 1","","\t--\tKeep looping through the string.","\twhile true do","\t\t--\tStop at the end. Throw an error. This function MUST NOT meet the end!","\t\tif i > len then","\t\t\tSF.throw( \"vON: Reached end of string, cannot form proper variable.\", 3 )","\t\tend","","\t\t--\tCache the character. Nobody wants to look for the same character ten times.","\t\tc = sub(s, i, i)","","\t\t--\tIf it just read a type definition, then a variable HAS to come after it.","\t\tif typeRead then","\t\t\t--\tAttempt to deserialize a variable of the freshly read type.","\t\t\tval, i = _deserialize[lastType](s, i, len, false, jobstate)","\t\t\t--\tReturn the value read, the index of the last processed character, and the type of the last read variable.","\t\t\treturn val, i, lastType","","\t\t--\t@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.","\t\telseif c == \"@\" then","\t\t\treturn nil, i, lastType","","\t\t--\t$ means a table reference will follow - a number basically.","\t\telseif c == \"$\" then","\t\t\tlastType = \"table_reference\"","\t\t\ttypeRead = true","","\t\t--\tn means a number will follow. Base 10... :C","\t\telseif c == \"n\" then","\t\t\tlastType = \"number\"","\t\t\ttypeRead = true","","\t\t--\tb means boolean flags.","\t\telseif c == \"b\" then","\t\t\tlastType = \"boolean\"","\t\t\ttypeRead = true","","\t\t--\t' means the start of a string.","\t\telseif c == \"'\" then","\t\t\tlastType = \"string\"","\t\t\ttypeRead = true","","\t\t--\t\" means the start of a string prior to version 1.2.0.","\t\telseif c == \"\\\"\" then","\t\t\tlastType = \"oldstring\"","\t\t\ttypeRead = true","","\t\t--\t{ means the start of a table!","\t\telseif c == \"{\" then","\t\t\tlastType = \"table\"","\t\t\ttypeRead = true","","","--[[    Garry's Mod types go here    ]]","","\t\t--\te means an entity ID will follow.","\t\telseif c == \"e\" then","\t\t\tlastType = \"Entity\"","\t\t\ttypeRead = true","--[[","\t\t--\tc means a vehicle ID will follow.","\t\telseif c == \"c\" then","\t\t\tlastType = \"Vehicle\"","\t\t\ttypeRead = true","","\t\t--\tw means a weapon entity ID will follow.","\t\telseif c == \"w\" then","\t\t\tlastType = \"Weapon\"","\t\t\ttypeRead = true","","\t\t--\tx means a NPC ID will follow.","\t\telseif c == \"x\" then","\t\t\tlastType = \"NPC\"","\t\t\ttypeRead = true","--]]","\t\t--\tp means a player ID will follow.","\t\t--\tKept for backwards compatibility.","\t\telseif c == \"p\" then","\t\t\tlastType = \"Entity\"","\t\t\ttypeRead = true","","\t\t--\tv means a vector will follow. 3 numbers.","\t\telseif c == \"v\" then","\t\t\tlastType = \"Vector\"","\t\t\ttypeRead = true","","\t\t--\ta means an Euler angle will follow. 3 numbers.","\t\telseif c == \"a\" then","\t\t\tlastType = \"Angle\"","\t\t\ttypeRead = true","","--[[    Garry's Mod types end here    ]]","","","\t\t--\tIf no type has been found, attempt to deserialize the last type read.","\t\telseif lastType then","\t\t\tval, i = _deserialize[lastType](s, i, len, false, jobstate)","\t\t\treturn val, i, lastType","","\t\t--\tThis will occur if the very first character in the vON code is wrong.","\t\telse","\t\t\tSF.throw( \"vON: Malformed data... Can't find a proper type definition. Char#\" .. i .. \":\" .. c, 3 )","\t\tend","","\t\t--\tMove the pointer one step forward.","\t\ti = i + 1","\tend","end","","--\tThis is kept away from the table for speed.","--\tYeah, ton of parameters.","function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)","\t","\tlocal unwrap = SF.UnwrapObject( data )","\tif unwrap then data = unwrap end","","\tlocal tp = type(data)","","\tif jobstate[1] and jobstate[2][data] then","\t\ttp = \"table_reference\"","\tend","","\t--\tBasically, if the type changes.","\tif lastType ~= tp then","\t\t--\tRemember the new type. Caching the type is useless.","\t\tlastType = tp","","\t\tif _serialize[lastType] then","\t\t\t--\tReturn the serialized data and the (new) last type.","\t\t\t--\tThe second argument, which is true now, means that the data type was just changed.","\t\t\treturn _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType","\t\telse","\t\t\tSF.throw(\"vON: No serializer defined for type \\\"\" .. lastType .. \"\\\"!\", 3)","\t\tend","\tend","","\t--\tOtherwise, simply serialize the data.","\treturn _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType","end","","","","--[[    This section contains the tables with the functions necessary","        for decoding basic Lua data types.                               ]]","","","","_deserialize = {","--\tWell, tables are very loose...","--\tThe first table doesn't have to begin and end with { and }.","\t[\"table\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\tif sub(s, i, i) == \"#\" then","\t\t\tlocal e = find(s, \"#\", i + 2, true)","","\t\t\tif e then","\t\t\t\tlocal id = tonumber(sub(s, i + 1, e - 1))","","\t\t\t\tif id then","\t\t\t\t\tif jobstate[1][id] and not jobstate[2] then","\t\t\t\t\t\tSF.throw(\"vON: There already is a table of reference #\" .. id .. \"! Missing an option maybe?\", 3)","\t\t\t\t\tend","","\t\t\t\t\tjobstate[1][id] = ret","","\t\t\t\t\ti = e + 1","\t\t\t\telse","\t\t\t\t\tSF.throw(\"vON: Malformed table! Reference ID starting at char #\" .. i .. \" doesn't contain a number!\", 3)","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: Malformed table! Cannot find end of reference ID start at char #\" .. i .. \"!\", 3)","\t\t\tend","\t\tend","","\t\t--\tKeep looping.","\t\twhile true do","\t\t\t--\tUntil it meets the end.","\t\t\tif i > len then","\t\t\t\t--\tYeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.","\t\t\t\tif unnecessaryEnd then","\t\t\t\t\treturn ret, i","","\t\t\t\t--\tOtherwise, the data has to be damaged.","\t\t\t\telse","\t\t\t\t\tSF.throw( \"vON: Reached end of string, incomplete table definition.\", 2 )","\t\t\t\tend","\t\t\tend","","\t\t\t--\tCache the character.","\t\t\tc = sub(s, i, i)","\t\t\t--print(i, \"table char:\", c, tostring(unnecessaryEnd))","","\t\t\t--\tIf it's the end of a table definition, return.","\t\t\tif c == \"}\" then","\t\t\t\treturn ret, i","","\t\t\t--\tIf it's the component separator, switch to key:value pairs.","\t\t\telseif c == \"~\" then","\t\t\t\tnumeric = false","","\t\t\telseif c == \";\" then","\t\t\t\t--\tLol, nothing!","\t\t\t\t--\tRemenant from numbers, for faster parsing.","","\t\t\t--\tOK, now, if it's on the numeric component, simply add everything encountered.","\t\t\telseif numeric then","\t\t\t\t--\tFind a variable and it's value","\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\t--\tAdd it to the table.","\t\t\t\tret[ind] = val","","\t\t\t\tind = ind + 1","","\t\t\t--\tOtherwise, if it's the key:value component...","\t\t\telse","\t\t\t\t--\tIf a value is expected...","\t\t\t\tif expectValue then","\t\t\t\t\t--\tRead it.","\t\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\t\t--\tAdd it?","\t\t\t\t\tret[key] = val","\t\t\t\t\t--\tClean up.","\t\t\t\t\texpectValue, key = false, nil","","\t\t\t\t--\tIf it's the separator...","\t\t\t\telseif c == \":\" then","\t\t\t\t\t--\tExpect a value next.","\t\t\t\t\texpectValue = true","","\t\t\t\t--\tBut, if there's a key read already...","\t\t\t\telseif key then","\t\t\t\t\t--\tThen this is malformed.","\t\t\t\t\tSF.throw( \"vON: Malformed table... Two keys declared successively? Char#\" .. i .. \":\" .. c, 2 )","","\t\t\t\t--\tOtherwise the key will be read.","\t\t\t\telse","\t\t\t\t\t--\tI love multi-return and multi-assignement.","\t\t\t\t\tkey, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\tend","\t\t\tend","","\t\t\ti = i + 1","\t\tend","","\t\treturn nil, i","\tend,","","--\tJust a number which points to a table.","\t[\"table_reference\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\tlocal n = tonumber(sub(s, i, a - 1))","","\t\t\tif n then","\t\t\t\treturn jobstate[1][n] or SF.throw(\"vON: Table reference does not point to a (yet) known table!\", 3), a - 1","\t\t\telse","\t\t\t\tSF.throw(\"vON: Table reference definition does not contain a valid number!\", 3)","\t\t\tend","\t\tend","","\t\t--\tUsing %D breaks identification of negative numbers. :(","","\t\tSF.throw(\"vON: Number definition started... Found no end.\", 3)","\tend,","","","--\tNumbers are weakly defined.","--\tThe declaration is not very explicit. It'll do it's best to parse the number.","--\tHas various endings: \\n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.","\t[\"number\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\treturn tonumber(sub(s, i, a - 1)) or SF.throw(\"vON: Number definition does not contain a valid number!\", 3), a - 1","\t\tend","","\t\tSF.throw( \"vON: Number definition started... Found no end.\", 3 )","\tend,","","","--\tA boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.","--\tAny other attempt at boolean declaration will result in a failure.","\t[\"boolean\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal c = sub(s,i,i)","\t\t--\tOnly one character is needed.","","\t\t--\tIf it's 1, then it's true","\t\tif c == \"1\" then","\t\t\treturn true, i","","\t\t--\tIf it's 0, then it's false.","\t\telseif c == \"0\" then","\t\t\treturn false, i","\t\tend","","\t\t--\tAny other supposely \"boolean\" is just a sign of malformed data.","\t\tSF.throw( \"vON: Invalid value on boolean type... Char#\" .. i .. \": \" .. c, 3 )","\tend,","","","--\tStrings prior to 1.2.0","\t[\"oldstring\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 2), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: Old string definition started... Found no end.\", 3)","\t\t\tend","\t\tend","\tend,","","--\tStrings after 1.2.0","\t[\"string\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 1), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: String definition started... Found no end.\", 3)","\t\t\tend","\t\tend","\tend,","}","","","","_serialize = {","--\tUh. Nothing to comment.","--\tTon of parameters.","--\tMakes stuff faster than simply passing it around in locals.","--\ttable.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.","\t[\"table\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--print(string.format(\"data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s\", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))","","\t\tlocal result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals, locals and locals.","\t\t","\t\t--\tFirst thing to be done is separate the numeric and key:value components of the given table in two tables.","\t\t--\tpairs(data) is slower than next, data as far as my tests tell me.","\t\tfor k, v in next, data do","\t\t\t--\tSkip the numeric keyz.","\t\t\tif type(k) ~= \"number\" or k < 1 or k > len or (k % 1 ~= 0) then\t--\tk % 1 == 0 is, as proven by personal benchmarks,","\t\t\t\tkeyvals[#keyvals + 1] = k\t\t\t\t\t\t\t\t\t--\tthe quickest way to check if a number is an integer.","\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--\tk % 1 ~= 0 is the fastest way to check if a number","\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--\tis NOT an integer. > is proven slower.","","\t\tkeyvalsLen = #keyvals","","\t\t--\tMain chunk - no initial character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"{\"","\t\tend","","\t\tif jobstate[1] and jobstate[1][data] then","\t\t\tif jobstate[2][data] then","\t\t\t\tSF.throw(\"vON: Table #\" .. jobstate[1][data] .. \" written twice..?\", 2)","\t\t\tend","","\t\t\tresult[#result + 1] = \"#\"","\t\t\tresult[#result + 1] = jobstate[1][data]","\t\t\tresult[#result + 1] = \"#\"","","\t\t\tjobstate[2][data] = true","\t\tend","","\t\t--\tAdd numeric values.","\t\tif len > 0 then","\t\t\tfor i = 1, len do","\t\t\t\tval, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tIf there are key:value pairs.","\t\tif keyvalsLen > 0 then","\t\t\t--\tInsert delimiter.","\t\t\tresult[#result + 1] = \"~\"","","\t\t\t--\tInsert key:value pairs.","\t\t\tfor _i = 1, keyvalsLen do","\t\t\t\tkeyvalsProgress = keyvalsProgress + 1","","\t\t\t\tval, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)","","\t\t\t\tresult[#result + 1] = val..\":\"","","\t\t\t\tval, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)","\t\t\t\t","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tMain chunk needs no ending character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"}\"","\t\tend","","\t\treturn concat(result)","\tend,","","--\tNumber which points to table.","\t[\"table_reference\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\tdata = jobstate[1][data]","","\t\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"$\"..data","\t\t\telse","\t\t\t\treturn \"$\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn data","\t\telse","\t\t\treturn data..\";\"","\t\tend","\tend,","","","--\tNormal concatenations is a lot faster with small strings than table.concat","--\tAlso, not so branched-ish.","\t[\"number\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"n\"..data","\t\t\telse","\t\t\t\treturn \"n\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn data","\t\telse","\t\t\treturn data..\";\"","\t\tend","\tend,","","","--\tI hope gsub is fast enough.","\t[\"string\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\tif sub(data, #data, #data) == \"\\\\\" then\t--\tHah, old strings fix this best.","\t\t\treturn \"\\\"\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"v\\\"\"","\t\tend","","\t\treturn \"'\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"\\\"\"","\tend,","","","--\tFastest.","\t[\"boolean\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--\tPrefix if we must.","\t\tif mustInitiate then","\t\t\tif data then","\t\t\t\treturn \"b1\"","\t\t\telse","\t\t\t\treturn \"b0\"","\t\t\tend","\t\tend","","\t\tif data then","\t\t\treturn \"1\"","\t\telse","\t\t\treturn \"0\"","\t\tend","\tend,","","","--\tFastest.","\t[\"nil\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\treturn \"@\"","\tend,","}","","","","--[[    This section handles additions necessary for Garry's Mod.    ]]","","","","if gmod then\t--\tLuckily, a specific table named after the game is present in Garry's Mod.","\tlocal Entity = Entity","","","","\tlocal extra_deserialize = {","--\tEntities are stored simply by the ID. They're meant to be transfered, not stored anyway.","--\tExactly like a number definition, except it begins with \"e\".","\t\t[\"Entity\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\treturn SF.WrapObject(Entity(tonumber(sub(s, i, a - 1)))), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Entity ID definition started... Found no end.\", 3)","\t\tend,","","","--\tA pair of 3 numbers separated by a comma (,).","\t\t[\"Vector\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a, x, y, z = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\tx = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\ty = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\tz = tonumber(sub(s, i, a - 1))","\t\t\tend","","\t\t\tif x and y and z then","\t\t\t\treturn SF.Vectors.Wrap(Vector(x, y, z)), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Vector definition started... Found no end.\",3)","\t\tend,","","","--\tA pair of 3 numbers separated by a comma (,).","\t\t[\"Angle\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a, p, y, r = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\tp = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\ty = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\tr = tonumber(sub(s, i, a - 1))","\t\t\tend","","\t\t\tif p and y and r then","\t\t\t\treturn SF.Angles.Wrap(Angle(p, y, r)), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Angle definition started... Found no end.\",3)","\t\tend,","\t}","","\tlocal extra_serialize = {","--\tSame as numbers, except they start with \"e\" instead of \"n\".","\t\t[\"Entity\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tdata = data:EntIndex()","","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"e\"..data","\t\t\t\telse","\t\t\t\t\treturn \"e\"..data..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data","\t\t\telse","\t\t\t\treturn data..\";\"","\t\t\tend","\t\tend,","","","--\t3 numbers separated by a comma.","\t\t[\"Vector\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"v\"..data.x..\",\"..data.y..\",\"..data.z","\t\t\t\telse","\t\t\t\t\treturn \"v\"..data.x..\",\"..data.y..\",\"..data.z..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data.x..\",\"..data.y..\",\"..data.z","\t\t\telse","\t\t\t\treturn data.x..\",\"..data.y..\",\"..data.z..\";\"","\t\t\tend","\t\tend,","","","--\t3 numbers separated by a comma.","\t\t[\"Angle\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"a\"..data.p..\",\"..data.y..\",\"..data.r","\t\t\t\telse","\t\t\t\t\treturn \"a\"..data.p..\",\"..data.y..\",\"..data.r..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data.p..\",\"..data.y..\",\"..data.r","\t\t\telse","\t\t\t\treturn data.p..\",\"..data.y..\",\"..data.r..\";\"","\t\t\tend","\t\tend,","\t}","","\tfor k, v in pairs(extra_serialize) do","\t\t_serialize[k] = v","\tend","","\tfor k, v in pairs(extra_deserialize) do","\t\t_deserialize[k] = v","\tend","","\tlocal extraEntityTypes = { \"Vehicle\", \"Weapon\", \"NPC\", \"Player\", \"NextBot\" }","","\tfor i = 1, #extraEntityTypes do","\t\t_serialize[extraEntityTypes[i]] = _serialize.Entity","\tend","end","","","","--[[    This section exposes the functions of the library.    ]]","","","","local function checkTableForRecursion(tab, checked, assoc)","\tlocal id = checked.ID","","\tif not checked[tab] and not assoc[tab] then","\t\tassoc[tab] = id","\t\tchecked.ID = id + 1","\telse","\t\tchecked[tab] = true","\tend","","\tfor k, v in pairs(tab) do","\t\tif type(k) == \"table\" and not checked[k] then","\t\t\tcheckTableForRecursion(k, checked, assoc)","\t\tend","\t\t","\t\tif type(v) == \"table\" and not checked[v] then","\t\t\tcheckTableForRecursion(v, checked, assoc)","\t\tend","\tend","end","","","","local _s_table = _serialize.table","local _d_table = _deserialize.table","","_d_meta = {","\t__call = function(self, str, allowIdRewriting)","\t\tif type(str) == \"string\" then","\t\t\treturn _d_table(str, nil, #str, true, {{}, allowIdRewriting})","\t\tend","\t\tSF.throw( \"vON: You must deserialize a string, not a \" .. type( str ), 2 )","\tend,","\t__newindex = function() end,","\t__metatable = false","}","_s_meta = {","\t__call = function(self, data, checkRecursion)","\t\tif type(data) == \"table\" then","\t\t\tif checkRecursion then","\t\t\t\tlocal assoc, checked = {}, {ID = 1}","","\t\t\t\tcheckTableForRecursion(data, checked, assoc)","","\t\t\t\treturn _s_table(data, nil, nil, nil, nil, true, {assoc, {}})","\t\t\tend","","\t\t\treturn _s_table(data, nil, nil, nil, nil, true, {false})","\t\tend","\t\tSF.throw( \"vON: You must serialize a table, not a \" .. type( data ), 2 )","\tend,","\t__newindex = function() end,","\t__metatable = false","}",""],"fields":[],"name":"von","client":true,"description":"\nvON Library","libtbl":"von","tables":[],"server":true},"builtin":{"description":"\nBuilt in values. These don't need to be loaded; they are in the default environment.","code":["","-- ------------------------- Lua Ports ------------------------- --","-- This part is messy because of LuaDoc stuff.","","local function pascalToCamel ( t, r )","\tlocal r = r or {}","\tfor k, v in pairs( t ) do","\t\tk = k:gsub( \"^%l\", string.lower )","\t\tr[ k ] = v","\tend","\treturn r","end",""],"summary":"\nBuilt in values.","class":"library","tables":{"1":"IN_KEY","2":"KEY","3":"MOUSE","4":"bit","5":"math","6":"os","7":"string","8":"table","IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown:","-- ALT1,","-- ALT2,","-- ATTACK,","-- ATTACK2,","-- BACK,","-- DUCK,","-- FORWARD,","-- JUMP,","-- LEFT,","-- MOVELEFT,","-- MOVERIGHT,","-- RELOAD,","-- RIGHT,","-- SCORE,","-- SPEED,","-- USE,","-- WALK,","-- ZOOM,","-- GRENADE1,","-- GRENADE2,","-- WEAPON1,","-- WEAPON2,","-- BULLRUSH,","-- CANCEL,","-- RUN","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"string":{"description":"\nString library http://wiki.garrysmod.com/page/Category:string","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nString library http://wiki.garrysmod.com/page/Category:string ","library":"builtin","comment":["--- String library http://wiki.garrysmod.com/page/Category:string","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"os":{"description":"\nThe os library. http://wiki.garrysmod.com/page/Category:os","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nThe os library.","library":"builtin","comment":["--- The os library. http://wiki.garrysmod.com/page/Category:os","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"table":{"description":"\nTable library. http://wiki.garrysmod.com/page/Category:table","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","local bit_methods, bit_metatable = SF.Typedef(\"Library: bit\")","filterGmodLua(bit,bit_methods)","bit_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nTable library.","library":"builtin","comment":["--- Table library. http://wiki.garrysmod.com/page/Category:table","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"math":{"description":"\nThe math library. http://wiki.garrysmod.com/page/Category:math","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nThe math library.","library":"builtin","comment":["--- The math library. http://wiki.garrysmod.com/page/Category:math","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"bit":{"description":"\nBit library. http://wiki.garrysmod.com/page/Category:bit","code":["SF.DefaultEnvironment.bit = setmetatable({},bit_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.bit","summary":"\nBit library.","library":"builtin","comment":["--- Bit library. http://wiki.garrysmod.com/page/Category:bit","-- @name SF.DefaultEnvironment.bit","-- @class table"],"param":[]},"MOUSE":{"description":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library:","-- MOUSE1,","-- LEFT,","-- MOUSE2,","-- RIGHT,","-- MOUSE3,","-- MIDDLE,","-- MOUSE4,","-- 4,","-- MOUSE5,","-- 5,","-- MWHEELUP,","-- WHEEL_UP,","-- MWHEELDOWN,","-- WHEEL_DOWN,","-- COUNT,","-- FIRST,","-- LAST","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"KEY":{"description":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library:","-- FIRST,","-- NONE,","-- 0,","-- 1,","-- 2,","-- 3,","-- 4,","-- 5,","-- 6,","-- 7,","-- 8,","-- 9,","-- A,","-- B,","-- C,","-- D,","-- E,","-- F,","-- G,","-- H,","-- I,","-- J,","-- K,","-- L,","-- M,","-- N,","-- O,","-- P,","-- Q,","-- R,","-- S,","-- T,","-- U,","-- V,","-- W,","-- X,","-- Y,","-- Z,","-- KP_INS,","-- PAD_0,","-- KP_END,","-- PAD_1,","-- KP_DOWNARROW ,","-- PAD_2,","-- KP_PGDN,","-- PAD_3,","-- KP_LEFTARROW,","-- PAD_4,","-- KP_5 ,","-- PAD_5,","-- KP_RIGHTARROW,","-- PAD_6,","-- KP_HOME,","-- PAD_7,","-- KP_UPARROW,","-- PAD_8,","-- KP_PGUP,","-- PAD_9,","-- PAD_DIVIDE,","-- KP_SLASH,","-- KP_MULTIPLY,","-- PAD_MULTIPLY,","-- KP_MINUS,","-- PAD_MINUS,","-- KP_PLUS,","-- PAD_PLUS,","-- KP_ENTER,","-- PAD_ENTER,","-- KP_DEL,","-- PAD_DECIMAL,","-- LBRACKET,","-- RBRACKET,","-- SEMICOLON,","-- APOSTROPHE,","-- BACKQUOTE,","-- COMMA,","-- PERIOD,","-- SLASH,","-- BACKSLASH,","-- MINUS,","-- EQUAL,","-- ENTER,","-- SPACE,","-- BACKSPACE,","-- TAB,","-- CAPSLOCK,","-- NUMLOCK,","-- ESCAPE,","-- SCROLLLOCK,","-- INS,","-- INSERT,","-- DEL,","-- DELETE,","-- HOME,","-- END,","-- PGUP,","-- PAGEUP,","-- PGDN,","-- PAGEDOWN,","-- PAUSE,","-- BREAK,","-- SHIFT,","-- LSHIFT,","-- RSHIFT,","-- ALT,","-- LALT,","-- RALT,","-- CTRL,","-- LCONTROL,","-- RCTRL,","-- RCONTROL,","-- LWIN,","-- RWIN,","-- APP,","-- UPARROW,","-- UP,","-- LEFTARROW,","-- LEFT,","-- DOWNARROW,","-- DOWN,","-- RIGHTARROW,","-- RIGHT,","-- F1,","-- F2,","-- F3,","-- F4,","-- F5,","-- F6,","-- F7,","-- F8,","-- F9,","-- F10,","-- F11,","-- F12,","-- CAPSLOCKTOGGLE,","-- NUMLOCKTOGGLE,","-- SCROLLLOCKTOGGLE,","-- LAST,","-- COUNT","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]}},"functions":{"1":"assert","2":"chip","3":"concmd","4":"dodir","5":"dofile","6":"entity","7":"error","8":"getLibraries","9":"getfenv","10":"getmetatable","11":"ipairs","12":"isValid","13":"loadstring","14":"next","15":"owner","16":"pairs","17":"player","18":"printMesssage","19":"printTable","20":"quotaAverage","21":"quotaMax","22":"quotaUsed","23":"require","24":"requiredir","25":"setClipboardText","26":"setName","27":"setSoftQuota","28":"setfenv","29":"setmetatable","30":"throw","31":"tonumber","32":"tostring","33":"try","34":"type","35":"unpack","chip":{"ret":"Starfall entity","description":"\nReturns the entity representing a processor that this script is running on.","code":["SF.DefaultEnvironment.chip = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.chip","summary":"\nReturns the entity representing a processor that this script is running on.","library":"builtin","comment":["--- Returns the entity representing a processor that this script is running on.","-- @name SF.DefaultEnvironment.chip","-- @class function","-- @return Starfall entity"],"param":[]},"tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"setClipboardText":{"comment":["\t--- Sets clipboard text. Only works on the owner of the chip.","\t-- @param txt Text to set to the clipboard"],"code":["\tfunction SF.DefaultEnvironment.setClipboardText( txt )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( txt, \"string\" )","\t\tSetClipboardText( txt )","\tend","\t"],"class":"function","name":"SF.DefaultEnvironment.setClipboardText","summary":"\nSets clipboard text.","private":false,"library":"builtin","description":"\nSets clipboard text. Only works on the owner of the chip.","param":{"1":"txt","txt":"Text to set to the clipboard"}},"unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"isValid":{"ret":"If it is valid","comment":["--- Returns if the table has an isValid function and isValid returns true.","--@param object Table to check","--@return If it is valid"],"code":["function SF.DefaultEnvironment.isValid( object )","","\tif ( !object ) then return false end","\tif ( !object.isValid ) then return false end","","\treturn object:isValid()","","end","","local _KEY = {","\t[ \"FIRST\" ] = 0,","\t[ \"NONE\" ] = 0,","\t[ \"0\" ] = 1,","\t[ \"1\" ] = 2,","\t[ \"2\" ] = 3,","\t[ \"3\" ] = 4,","\t[ \"4\" ] = 5,","\t[ \"5\" ] = 6,","\t[ \"6\" ] = 7,","\t[ \"7\" ] = 8,","\t[ \"8\" ] = 9,","\t[ \"9\" ] = 10,","\t[ \"A\" ] = 11,","\t[ \"B\" ] = 12,","\t[ \"C\" ] = 13,","\t[ \"D\" ] = 14,","\t[ \"E\" ] = 15,","\t[ \"F\" ] = 16,","\t[ \"G\" ] = 17,","\t[ \"H\" ] = 18,","\t[ \"I\" ] = 19,","\t[ \"J\" ] = 20,","\t[ \"K\" ] = 21,","\t[ \"L\" ] = 22,","\t[ \"M\" ] = 23,","\t[ \"N\" ] = 24,","\t[ \"O\" ] = 25,","\t[ \"P\" ] = 26,","\t[ \"Q\" ] = 27,","\t[ \"R\" ] = 28,","\t[ \"S\" ] = 29,","\t[ \"T\" ] = 30,","\t[ \"U\" ] = 31,","\t[ \"V\" ] = 32,","\t[ \"W\" ] = 33,","\t[ \"X\" ] = 34,","\t[ \"Y\" ] = 35,","\t[ \"Z\" ] = 36,","\t[ \"KP_INS\" ] = 37,","\t[ \"PAD_0\" ] = 37,","\t[ \"KP_END\" ] = 38,","\t[ \"PAD_1\" ] = 38,","\t[ \"KP_DOWNARROW \" ] = 39,","\t[ \"PAD_2\" ] = 39,","\t[ \"KP_PGDN\" ] = 40,","\t[ \"PAD_3\" ] = 40,","\t[ \"KP_LEFTARROW\" ] = 41,","\t[ \"PAD_4\" ] = 41,","\t[ \"KP_5 \" ] = 42,","\t[ \"PAD_5\" ] = 42,","\t[ \"KP_RIGHTARROW\" ] = 43,","\t[ \"PAD_6\" ] = 43,","\t[ \"KP_HOME\" ] = 44,","\t[ \"PAD_7\" ] = 44,","\t[ \"KP_UPARROW\" ] = 45,","\t[ \"PAD_8\" ] = 45,","\t[ \"KP_PGUP\" ] = 46,","\t[ \"PAD_9\" ] = 46,","\t[ \"PAD_DIVIDE\" ] = 47,","\t[ \"KP_SLASH\" ] = 47,","\t[ \"KP_MULTIPLY\" ] = 48,","\t[ \"PAD_MULTIPLY\" ] = 48,","\t[ \"KP_MINUS\" ] = 49,","\t[ \"PAD_MINUS\" ] = 49,","\t[ \"KP_PLUS\" ] = 50,","\t[ \"PAD_PLUS\" ] = 50,","\t[ \"KP_ENTER\" ] = 51,","\t[ \"PAD_ENTER\" ] = 51,","\t[ \"KP_DEL\" ] = 52,","\t[ \"PAD_DECIMAL\" ] = 52,","\t[ \"[\" ] = 53,","\t[ \"LBRACKET\" ] = 53,","\t[ \"]\" ] = 54,","\t[ \"RBRACKET\" ] = 54,","\t[ \"SEMICOLON\" ] = 55,","\t[ \"'\" ] = 56,","\t[ \"APOSTROPHE\" ] = 56,","\t[ \"`\" ] = 57,","\t[ \"BACKQUOTE\" ] = 57,","\t[ \",\" ] = 58,","\t[ \"COMMA\" ] = 58,","\t[ \".\" ] = 59,","\t[ \"PERIOD\" ] = 59,","\t[ \"/\" ] = 60,","\t[ \"SLASH\" ] = 60,","\t[ \"\\\\\" ] = 61,","\t[ \"BACKSLASH\" ] = 61,","\t[ \"-\" ] = 62,","\t[ \"MINUS\" ] = 62,","\t[ \"=\" ] = 63,","\t[ \"EQUAL\" ] = 63,","\t[ \"ENTER\" ] = 64,","\t[ \"SPACE\" ] = 65,","\t[ \"BACKSPACE\" ] = 66,","\t[ \"TAB\" ] = 67,","\t[ \"CAPSLOCK\" ] = 68,","\t[ \"NUMLOCK\" ] = 69,","\t[ \"ESCAPE\" ] = 70,","\t[ \"SCROLLLOCK\" ] = 71,","\t[ \"INS\" ] = 72,","\t[ \"INSERT\" ] = 72,","\t[ \"DEL\" ] = 73,","\t[ \"DELETE\" ] = 73,","\t[ \"HOME\" ] = 74,","\t[ \"END\" ] = 75,","\t[ \"PGUP\" ] = 76,","\t[ \"PAGEUP\" ] = 76,","\t[ \"PGDN\" ] = 77,","\t[ \"PAGEDOWN\" ] = 77,","\t[ \"PAUSE\" ] = 78,","\t[ \"BREAK\" ] = 78,","\t[ \"SHIFT\" ] = 79,","\t[ \"LSHIFT\" ] = 79,","\t[ \"RSHIFT\" ] = 80,","\t[ \"ALT\" ] = 81,","\t[ \"LALT\" ] = 81,","\t[ \"RALT\" ] = 82,","\t[ \"CTRL\" ] = 83,","\t[ \"LCONTROL\" ] = 83,","\t[ \"RCTRL\" ] = 84,","\t[ \"RCONTROL\" ] = 84,","\t[ \"LWIN\" ] = 85,","\t[ \"RWIN\" ] = 86,","\t[ \"APP\" ] = 87,","\t[ \"UPARROW\" ] = 88,","\t[ \"UP\" ] = 88,","\t[ \"LEFTARROW\" ] = 89,","\t[ \"LEFT\" ] = 89,","\t[ \"DOWNARROW\" ] = 90,","\t[ \"DOWN\" ] = 90,","\t[ \"RIGHTARROW\" ] = 91,","\t[ \"RIGHT\" ] = 91,","\t[ \"F1\" ] = 92,","\t[ \"F2\" ] = 93,","\t[ \"F3\" ] = 94,","\t[ \"F4\" ] = 95,","\t[ \"F5\" ] = 96,","\t[ \"F6\" ] = 97,","\t[ \"F7\" ] = 98,","\t[ \"F8\" ] = 99,","\t[ \"F9\" ] = 100,","\t[ \"F10\" ] = 101,","\t[ \"F11\" ] = 102,","\t[ \"F12\" ] = 103,","\t[ \"CAPSLOCKTOGGLE\" ] = 104,","\t[ \"NUMLOCKTOGGLE\" ] = 105,","\t[ \"SCROLLLOCKTOGGLE\" ] = 106,","\t[ \"LAST\" ] = 106,","\t[ \"COUNT\" ] = 106","}",""],"class":"function","name":"SF.DefaultEnvironment.isValid","summary":"\nReturns if the table has an isValid function and isValid returns true.","private":false,"library":"builtin","description":"\nReturns if the table has an isValid function and isValid returns true.","param":{"1":"object","object":"Table to check"}},"pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as owner() on the server. On the client, returns the local player","code":["SF.DefaultEnvironment.player = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.player","summary":"\nSame as owner() on the server.","library":"builtin","comment":["--- Same as owner() on the server. On the client, returns the local player","-- @name SF.DefaultEnvironment.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]},"requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}},"getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if CLIENT then\t"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},"dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"entity":{"ret":"entity","description":"\nReturns the entity with index 'num'","code":["SF.DefaultEnvironment.entity = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.entity","summary":"\nReturns the entity with index 'num' ","library":"builtin","comment":["--- Returns the entity with index 'num'","-- @name SF.DefaultEnvironment.entity","-- @class function","-- @param num Entity index","-- @return entity"],"param":{"1":"num","num":"Entity index"}},"type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"printMesssage":{"comment":["\t--- Prints a message to your chat, console, or the center of your screen.","\t-- @param mtype How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","\t-- @param text The message text."],"code":["\tfunction SF.DefaultEnvironment.printMesssage( mtype, text )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( text, \"string\" )","\t\tSF.instance.player:PrintMessage( mtype, text )","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end","","-- Prints a message to the player's chat.","-- @shared","-- @param ... Values to print","function SF.DefaultEnvironment.print(...)","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tlocal str = \"\"","\tlocal tbl = {n=select('#', ...), ...}","\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t( SERVER and SF.instance.player or LocalPlayer() ):ChatPrint(str)","end",""],"class":"function","name":"SF.DefaultEnvironment.printMesssage","summary":"\nPrints a message to your chat, console, or the center of your screen.","private":false,"library":"builtin","description":"\nPrints a message to your chat, console, or the center of your screen.","param":{"1":"mtype","2":"text","mtype":"How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","text":"The message text."}},"printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"owner":{"ret":"Owner entity","description":"\nReturns whoever created the chip","code":["SF.DefaultEnvironment.owner = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.owner","summary":"\nReturns whoever created the chip ","library":"builtin","comment":["--- Returns whoever created the chip","-- @name SF.DefaultEnvironment.owner","-- @class function","-- @return Owner entity"],"param":[]},"getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\tlocal fenv = getfenv(2)","\tif fenv ~= _G then return fenv end","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" or getfenv( func ) == _G then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"setName":{"comment":["\t--- Sets the chip's display name","\t-- @client","\t-- @param name Name"],"code":["\tfunction SF.DefaultEnvironment.setName( name )","\t\tSF.CheckType( name, \"string\" )","\t\tlocal e = SF.instance.data.entity","\t\tif IsValid( e ) then","\t\t\te.name = name","\t\tend","\tend","\t"],"class":"function","summary":"\nSets the chip's display name ","name":"SF.DefaultEnvironment.setName","library":"builtin","private":false,"client":true,"description":"\nSets the chip's display name","param":{"1":"name","name":"Name"}},"dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"setSoftQuota":{"comment":["--- Sets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","-- @param quota The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50% "],"code":["function SF.DefaultEnvironment.setSoftQuota ( quota )","\tSF.CheckType( quota, \"number\" )","\tself.cpu_softquota = quota","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original)","\tfor name, func in pairs(lib) do","\t\tif not type(name)==\"string\" then continue end","\t\tname = name:gsub(\"^[A-Z]\", string.lower)","\t\toriginal[name] = func","\tend","end","","-- String library","local string_methods, string_metatable = SF.Typedef(\"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.setSoftQuota","summary":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","private":false,"library":"builtin","description":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","param":{"1":"quota","quota":"The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50%"}}},"classForced":true,"fields":{"1":"CLIENT","2":"SERVER","CLIENT":{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},"SERVER":{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]}},"name":"builtin","libtbl":"SF.DefaultEnvironment","server":true,"client":true,"comment":["--- Built in values. These don't need to be loaded; they are in the default environment.","-- @name builtin","-- @shared","-- @class library","-- @libtbl SF.DefaultEnvironment"],"param":[]},"timer":{"comment":["--- Deals with time and timers.","-- @shared"],"functions":{"1":"adjust","2":"create","3":"curtime","4":"exists","5":"frametime","6":"getTimersLeft","7":"pause","8":"realtime","9":"remove","10":"simple","11":"start","12":"stop","13":"systime","14":"unpause","simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\ttimer_library.create(\"\", delay, 1, func, true)","end",""],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn \"sftimer_\"..tostring(instance)..\"_\"..name","end","","local simple_int = 0","local function mangle_simpletimer_name(instance)","\tsimple_int = simple_int + 1","\treturn \"sftimersimple_\"..tostring(instance)..\"_\"..simple_int","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},"systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.adjust(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tif func then SF.CheckType(func,\"function\") end","\t","\ttimer.Adjust(mangle_timer_name(SF.instance,name), delay, reps, func)","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func, simple)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tif instance.data.timer_count > max_timers:GetInt() then SF.throw( \"Max timers exceeded!\", 2 ) end","\tinstance.data.timer_count = instance.data.timer_count + 1","\t","\tlocal timername","\tif simple then","\t\ttimername = mangle_simpletimer_name(instance)","\telse","\t\ttimername = mangle_timer_name(instance,name)","\tend","\t","\tlocal function timercb()","\t\tif reps ~= 0 then","\t\t\treps = reps - 1","\t\t\tif reps==0 then","\t\t\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\t\t\tinstance.data.timers[timername] = nil","\t\t\tend","\t\tend","\t\t","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend","\t","\ttimer.Create(timername, math.max(delay, 0.001), reps, timercb )","\t","\tinstance.data.timers[timername] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","5":"simple","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"getTimersLeft":{"ret":"Number of available timers","comment":["--- Returns number of available timers","-- @return Number of available timers"],"code":["function timer_library.getTimersLeft()","\treturn max_timers:GetInt() - SF.instance.data.timer_count","end","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","\tinstance.data.timer_count = 0","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor name,_ in pairs(instance.data.timers) do","\t\ttimer.Remove(name)","\tend","end)"],"class":"function","name":"timer_library.getTimersLeft","summary":"\nReturns number of available timers ","private":false,"library":"timer","description":"\nReturns number of available timers","param":[]},"stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]}},"class":"library","summary":"\nDeals with time and timers.","code":["local timer_library, _ = SF.Libraries.Register(\"timer\")","local max_timers = CreateConVar( \"sf_maxtimers\", \"200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED}, \"The max number of timers that can be created\" )","","-- ------------------------- Time ------------------------- --",""],"fields":[],"name":"timer","client":true,"description":"\nDeals with time and timers.","libtbl":"timer_library","tables":[],"server":true},"hook":{"comment":["--- Deals with hooks","-- @shared"],"functions":{"1":"add","2":"remove","3":"run","4":"runRemote","runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal results = {}","\tfor k, _ in pairs( recipients ) do","","\t\tlocal result = { k:runScriptHookForResult( \"remote\", SF.WrapObject( instance.data.entity ), SF.WrapObject( instance.player ), ... ) }","\t\tlocal ok = table.remove( result, 1 )","","\t\tif ok and result[1] then","\t\t\tresults[ #results + 1 ] = result","\t\telse","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\tend","","\tend","\treturn results","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tif not instance.hooks[ hookname ] then continue end","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","","\t\tlocal ok = ret[1]","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, {unpack(ret, 2)}, ... )","\t\t\t\tif sane ~= nil then result = { sane } end","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 2 ], ret[ 3 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},"run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}}},"class":"library","summary":"\nDeals with hooks ","code":["local hook_library, _ = SF.Libraries.Register( \"hook\" )","local registered_instances = {}",""],"fields":[],"name":"hook","client":true,"description":"\nDeals with hooks","libtbl":"hook_library","tables":[],"server":true},"find":{"comment":["--- Find library. Finds entities in various shapes.","-- @shared"],"functions":{"1":"all","2":"allPlayers","3":"byClass","4":"byModel","5":"inBox","6":"inCone","7":"inSphere","inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},"byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}}},"class":"library","summary":"\nFind library.","code":["local find_library, _ = SF.Libraries.Register(\"find\")","","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"find\", \"Find\", \"Allows the user to access the find library\" )","end","","local function convert(results, func)","\tif func then SF.CheckType(func,\"function\") end","\tlocal wrap = SF.WrapObject","\t","\tlocal t = {}","\tlocal count = 1","\tfor i=1,#results do","\t\tlocal e = wrap(results[i])","\t\tif not func or func(e) then","\t\t\tt[count] = e","\t\t\tcount = count + 1","\t\tend","\tend","\treturn t","end",""],"fields":[],"name":"find","client":true,"description":"\nFind library. Finds entities in various shapes.","libtbl":"find_library","tables":[],"server":true},"globaltables":{"comment":["--- Cross-instance tables","-- @shared"],"functions":[],"class":"library","summary":"\nCross-instance tables ","code":["local gtables_library, gtables_metamethods = SF.Libraries.Register(\"globaltables\")","","SF.GlobalTables = {}","","SF.GlobalTables.Global = {}","SF.GlobalTables.Players = {}",""],"fields":[],"name":"globaltables","client":true,"description":"\nCross-instance tables","libtbl":"gtables_library","tables":{"1":"global","2":"player","global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},"player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}},"server":true},"physenv":{"comment":["--- Physenv functions","-- @shared"],"functions":{"1":"getAirDensity","2":"getGravity","3":"getPerformanceSettings","getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},"getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]}},"class":"library","summary":"\nPhysenv functions ","code":["local physenv_lib, _ = SF.Libraries.Register( \"physenv\" )",""],"fields":[],"name":"physenv","client":true,"description":"\nPhysenv functions","libtbl":"physenv_lib","tables":[],"server":true},"input":{"comment":["---- Input library.","--- @client"],"functions":{"1":"getCursorPos","2":"getKeyName","3":"isControlDown","4":"isKeyDown","5":"isShiftDown","6":"lookupBinding","getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["---- Gets the position of the mouse","--- @return The x position of the mouse","--- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end","","local function runInputHook( hookname, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif SF.Permissions.check( instance.player, nil, \"input\" ) then","\t\t","\t\t","\t\t\tlocal ok, err, tr = instance:runScriptHook( hookname, key )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"Hook 'input' errored with \" .. err, tr )","\t\t\tend","\t\tend","\tend","end","","function PlayerButtonDown(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputPressed\", button )","\tend","end","","function PlayerButtonUp(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputReleased\", button )","\tend","end","","hook.Add( \"PlayerButtonDown\", \"SF_PlayerButtonDown\", PlayerButtonDown)","hook.Add( \"PlayerButtonUp\", \"SF_PlayerButtonUp\", PlayerButtonUp)",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["---- Gets the first key that is bound to the command passed","--- @param binding The name of the bind","--- @return The id of the first key bound","--- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","binding":"The name of the bind"}},"getKeyName":{"ret":"The name of the key","comment":["---- Gets the name of a key from the id","--- @param key The key id, see input","--- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input"}},"isKeyDown":{"ret":"True if the key is down","comment":["---- Gets whether a key is down","--- @param key The key id, see input","--- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input"}},"isControlDown":{"ret":"True if the control key is down","comment":["---- Gets whether the control key is down","--- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"isShiftDown":{"ret":"True if the shift key is down","comment":["---- Gets whether the shift key is down","--- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]}},"class":"library","summary":"\nInput library.","fields":[],"name":"input","client":true,"description":"\nInput library.","libtbl":"input_methods","tables":[],"code":["local input_methods, input_metamethods = SF.Libraries.Register( \"input\" )","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"input\", \"Input\", \"Allows the user to use the input library\" )","end",""]},"file":{"comment":["--- File functions. Allows modification of files.","-- @client"],"functions":{"1":"append","2":"createDir","3":"delete","4":"exists","5":"find","6":"read","7":"write","read":{"ret":"Contents, or nil if error","comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"write":{"ret":"True if OK, nil if error","comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"wb\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"delete":{"ret":"True if successful, nil if error","comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"append":{"comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file."],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"ab\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end",""],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"find":{"ret":["Table of file names","Table of directory names"],"comment":["--- Enumerates a directory","-- @param path The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'","-- @param sorting Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","-- @return Table of file names","-- @return Table of directory names"],"code":["function file_library.find ( path, sorting )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif sorting then SF.CheckType( sorting, \"string\" ) end","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Find( \"sf_filedata/\" .. path, \"DATA\", sorting )","end"],"class":"function","name":"file_library.find","summary":"\nEnumerates a directory ","private":false,"library":"file","description":"\nEnumerates a directory","param":{"1":"path","2":"sorting","sorting":"Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","path":"The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'"}},"exists":{"ret":"True if exists, false if not, nil if error","comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"class":"library","summary":"\nFile functions.","fields":[],"name":"file","client":true,"description":"\nFile functions. Allows modification of files.","libtbl":"file_library","tables":[],"code":["local file_library, _ = SF.Libraries.Register( \"file\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"file.read\", \"Read files\", \"Allows the user to read files from data/sf_filedata directory\" )","\tP.registerPrivilege( \"file.write\", \"Write files\", \"Allows the user to write files to data/sf_filedata directory\" )","\tP.registerPrivilege( \"file.exists\", \"File existence check\", \"Allows the user to determine whether a file in data/sf_filedata exists\" )","end","","file.CreateDir( \"sf_filedata/\" )",""]},"constraint":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @server"],"functions":{"1":"axis","2":"ballsocket","3":"ballsocketadv","4":"breakAll","5":"breakType","6":"elastic","7":"getTable","8":"nocollide","9":"rope","10":"setElasticLength","11":"setRopeLength","12":"slider","13":"weld","ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( frictionv, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = width or 0","\tstrech = strech and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( const, \"number\" )","\tSF.CheckType( damp, \"number\" )","\tSF.CheckType( rdamp, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", math.Clamp( width, 0, 50), strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\tSF.CheckType( friction, \"number\" )","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = width or 0","\trigid = rigid and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( length, \"number\" )","\tSF.CheckType( addlength, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, math.Clamp( width, 0, 50), material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},"ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = width or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( width, \"number\" )","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, math.Clamp( width, 0, 50), \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","fields":[],"name":"constraint","code":["local constraint_library, constraint_library_metamethods = SF.Libraries.Register(\"constraint\")","","local vwrap = SF.WrapObject","local vunwrap = SF.UnwrapObject","local ewrap, eunwrap, ents_metatable","","SF.Libraries.AddHook(\"postload\", function()","\tewrap = SF.Entities.Wrap","\teunwrap = SF.Entities.Unwrap","\tents_metatable = SF.Entities.Metatable","end)","","local function checkConstraint(e, t)","\tif e then","\t\tif e:IsValid() then","\t\t\tif not SF.Permissions.check( SF.instance.player, e, t ) then","\t\t\t\tSF.throw( \"Insufficient permissions\", 3 )","\t\t\tend","\t\telseif not e:IsWorld() then","\t\t\tSF.throw( \"Invalid Entity\", 3 )","\t\tend","\telse","\t\tSF.throw( \"Invalid Entity\", 3 )","\tend","end","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"constraints.weld\", \"Weld\", \"Allows the user to weld two entities\" )","\tP.registerPrivilege( \"constraints.axis\", \"Axis\", \"Allows the user to axis two entities\" )","\tP.registerPrivilege( \"constraints.ballsocket\", \"Ballsocket\", \"Allows the user to ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.ballsocketadv\", \"BallsocketAdv\", \"Allows the user to advanced ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.slider\", \"Slider\", \"Allows the user to slider two entities\" )","\tP.registerPrivilege( \"constraints.rope\", \"Rope\", \"Allows the user to rope two entities\" )","\tP.registerPrivilege( \"constraints.elastic\", \"Elastic\", \"Allows the user to elastic two entities\" )","\tP.registerPrivilege( \"constraints.nocollide\", \"Nocollide\", \"Allows the user to nocollide two entities\" )","\tP.registerPrivilege( \"constraints.any\", \"Any\", \"General constraint functions\" )","end",""],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"constraint_library","tables":[],"server":true},"http":{"comment":["--- Http library. Requests content from urls.","-- @shared"],"functions":{"1":"canRequest","2":"get","3":"post","post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}},"canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}}},"class":"library","summary":"\nHttp library.","code":["local http_library, _ = SF.Libraries.Register( \"http\" )","local http_interval = CreateConVar( \"sf_http_interval\", \"0.5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"Interval in seconds in which one http request can be made\" )","local http_max_active = CreateConVar( \"sf_http_max_active\", \"3\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"The maximum amount of active http requests at the same time\" )","","local http_server_allowed, http_client_allowed","if SERVER then","\thttp_server_allowed = CreateConVar( \"sf_http_allowsv\", \"0\", { FCVAR_ARCHIVE, FCVAR_SERVER_CAN_EXECUTE }, \"Should http be allowed to run on the server?\" )","else","\thttp_client_allowed = CreateConVar( \"sf_http_allowcl\", \"0\", { FCVAR_ARCHIVE }, \"Should http from other starfalls be allowed?\" )","end","-- Initializes the lastRequest variable to a value which ensures that the first call to httpRequestReady returns true","-- and the \"active requests counter\" to 0","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.http = {","\t\tlastRequest = 0,","\t\tactive = 0","\t}","end )","","-- Returns an error when a http request was already triggered in the current interval","-- or the maximum amount of simultaneous requests is currently active, returns true otherwise","local function httpRequestReady ( instance )","\tlocal httpData = instance.data.http","\tif CurTime() - httpData.lastRequest < http_interval:GetFloat() or httpData.active >= http_max_active:GetInt() then","\t\tSF.throw( \"You can't run a new http request yet\", 2 )","\tend","\treturn true","end","","-- Runs the appropriate callback after a http request","local function runCallback ( instance, callback, ... )","\tif callback then","\t\tlocal args = { ... }","\t\tif IsValid( instance.data.entity ) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, unpack( args ) )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"http callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend","\tinstance.data.http.active = instance.data.http.active - 1","end",""],"fields":[],"name":"http","client":true,"description":"\nHttp library. Requests content from urls.","libtbl":"http_library","tables":[],"server":true}},"files":{"1":"callback.lua","2":"compiler.lua","3":"database.lua","4":"editor.lua","5":"instance.lua","6":"libraries.lua","7":"libs_cl/bass.lua","8":"libs_cl/file.lua","9":"libs_cl/joystick.lua","10":"libs_cl/render.lua","11":"libs_sh/angles.lua","12":"libs_sh/builtins.lua","13":"libs_sh/color.lua","14":"libs_sh/coroutine.lua","15":"libs_sh/entities.lua","16":"libs_sh/fastlz.lua","17":"libs_sh/find.lua","18":"libs_sh/game.lua","19":"libs_sh/globaltables.lua","20":"libs_sh/hook.lua","21":"libs_sh/http.lua","22":"libs_sh/input.lua","23":"libs_sh/json.lua","24":"libs_sh/net.lua","25":"libs_sh/physenv.lua","26":"libs_sh/players.lua","27":"libs_sh/quaternion.lua","28":"libs_sh/sounds.lua","29":"libs_sh/team.lua","30":"libs_sh/timer.lua","31":"libs_sh/trace.lua","32":"libs_sh/vectors.lua","33":"libs_sh/vehicles.lua","34":"libs_sh/vmatrix.lua","35":"libs_sh/von.lua","36":"libs_sh/weapons.lua","37":"libs_sv/constraint.lua","38":"libs_sv/entities.lua","39":"libs_sv/holograms.lua","40":"libs_sv/npc.lua","41":"libs_sv/prop.lua","42":"libs_sv/wire.lua","43":"netstream.lua","44":"permissions/core.lua","45":"permissions/provider.lua","46":"permissions/providers_cl/files.lua","47":"permissions/providers_cl/input.lua","48":"permissions/providers_sh/placeholder.lua","49":"permissions/providers_sv/CPPI.lua","50":"permissions/providers_sv/default.lua","51":"preprocessor.lua","52":"sfderma.lua","53":"sfhelper.lua","54":"sflib.lua","libs_sh/quaternion.lua":{"libraries":{"1":"quaternion","quaternion":{"comment":["--- Quaternion library","-- @shared"],"functions":{"1":"New","2":"abs","3":"conj","4":"exp","5":"inv","6":"log","7":"qMod","8":"qRotation","9":"qRotation","10":"qi","11":"qj","12":"qk","13":"rotationAngle","14":"rotationAxis","15":"rotationEulerAngle","16":"rotationVector","17":"slerp","18":"vec","conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},"New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]}},"class":"library","summary":"\nQuaternion library ","code":["local quat_lib, quat_lib_metamethods = SF.Libraries.Register(\"quaternion\")","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Quaternion Support","-- Converted from Wiremod's E2 Quaternion library for general lua use","-- Original code for use by Bubbus","-- Permission received for use from Bubbus by Radon","-- http:\\\\wiki.wiremod.com/?title=Expression2#Quaternion","--","-- Credits to Radon for addition to Starfall","-- Credits to Divran for painful amounts of testing","]]","","-- faster access to some math library functions","local math = math -- Because global lookups suck","local setmetatable = setmetatable","local abs   = math.abs","local Round = math.Round","local sqrt  = math.sqrt","local exp   = math.exp","local log   = math.log","local sin   = math.sin","local cos   = math.cos","local sinh  = math.sinh","local cosh  = math.cosh","local acos  = math.acos","local min \t= math.min","","local delta = wire_expression2_delta or 0.0000001000000","","local isValid = IsValid","","local deg2rad = math.pi/180","local rad2deg = 180/math.pi",""],"fields":[],"name":"quaternion","client":true,"description":"\nQuaternion library","libtbl":"quat_lib","tables":[],"server":true}},"type":"file","name":"libs_sh/quaternion.lua","functions":{"1":"argTypesToQuat[\"Angle\"]","2":"argTypesToQuat[\"Entity\"]","3":"argTypesToQuat[\"Vector\"]","4":"argTypesToQuat[\"VectorVector\"]","5":"argTypesToQuat[\"number\"]","6":"argTypesToQuat[\"numberVector\"]","7":"argTypesToQuat[\"numbernumbernumbernumber\"]","8":"quat_lib.New","9":"quat_lib.abs","10":"quat_lib.conj","11":"quat_lib.exp","12":"quat_lib.inv","13":"quat_lib.log","14":"quat_lib.qMod","15":"quat_lib.qRotation","16":"quat_lib.qRotation","17":"quat_lib.qi","18":"quat_lib.qj","19":"quat_lib.qk","20":"quat_lib.rotationAngle","21":"quat_lib.rotationAxis","22":"quat_lib.rotationEulerAngle","23":"quat_lib.rotationVector","24":"quat_lib.slerp","25":"quat_lib.vec","26":"quat_methods:conj","27":"quat_methods:forward","28":"quat_methods:i","29":"quat_methods:j","30":"quat_methods:k","31":"quat_methods:r","32":"quat_methods:real","33":"quat_methods:right","34":"quat_methods:up","argTypesToQuat[\"numbernumbernumbernumber\"]":{"summary":"\nConverts 4 numbers to a Quaternion format for generation ","description":"\nConverts 4 numbers to a Quaternion format for generation","comment":["--- Converts 4 numbers to a Quaternion format for generation"],"code":["argTypesToQuat[\"numbernumbernumbernumber\"] = function(a,b,c,d)","\treturn quicknew(a,b,c,d)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numbernumbernumbernumber\"]","param":["a","b","c","d"]},"quat_lib.conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"quat_lib.qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"quat_lib.rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]},"quat_methods:forward":{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},"quat_lib.abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"quat_methods:r":{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},"quat_lib.qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"quat_methods:i":{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},"argTypesToQuat[\"number\"]":{"summary":"\nConverts a number to a Quaternion format for generation ","description":"\nConverts a number to a Quaternion format for generation","comment":["--- Converts a number to a Quaternion format for generation"],"code":["argTypesToQuat[\"number\"] = function(num)","\treturn quicknew(num, 0, 0, 0)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"number\"]","param":["num"]},"quat_lib.rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"argTypesToQuat[\"Vector\"]":{"summary":"\nConverts a Vector to a Quaternion format for generation ","description":"\nConverts a Vector to a Quaternion format for generation","comment":["--- Converts a Vector to a Quaternion format for generation"],"code":["argTypesToQuat[\"Vector\"] = function(vec)","\treturn quicknew(0, vec.x, vec.y, vec.z)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Vector\"]","param":["vec"]},"quat_methods:conj":{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},"argTypesToQuat[\"Entity\"]":{"summary":"\nConverts an Entity to a Quaternion format for generation ","description":"\nConverts an Entity to a Quaternion format for generation","comment":["--- Converts an Entity to a Quaternion format for generation"],"code":["argTypesToQuat[\"Entity\"] = function(ent)","\tent = SF.UnwrapObject( ent )","\t","\tif not isValid( ent ) then","\t\treturn quicknew( 0, 0, 0, 0 )","\tend","","\tlocal ang = ent:GetAngles()","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end","","argTypesToQuat[\"Vehicle\"] = argTypesToQuat[\"Entity\"]","argTypesToQuat[\"Weapon\"] = argTypesToQuat[\"Entity\"]","","",""],"private":false,"class":"function","name":"argTypesToQuat[\"Entity\"]","param":["ent"]},"quat_lib.qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"argTypesToQuat[\"VectorVector\"]":{"summary":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them ","description":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them","comment":["--- Converts two Vectors to a Quaternion format for generation using Cross product and the angle between them"],"code":["argTypesToQuat[\"VectorVector\"] = function(forward,up)","\tlocal x = Vector(forward.x, forward.y, forward.z)","\tlocal z = Vector(up.x, up.y, up.z)","\tlocal y = z:Cross(x):GetNormalized() --up x forward = left","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tlocal roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = y.z","\tif dot < 0 then roll = -roll end","","\tlocal p, y, r = ang.p, ang.y, roll","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"VectorVector\"]","param":["forward","up"]},"quat_lib.rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"quat_lib.qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"quat_lib.inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"quat_methods:real":{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},"quat_lib.vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"quat_lib.slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"quat_methods:k":{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},"quat_lib.log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"quat_lib.exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"argTypesToQuat[\"numberVector\"]":{"summary":"\nConverts a Number/Vector combination to a Quaternion format for generation ","description":"\nConverts a Number/Vector combination to a Quaternion format for generation","comment":["--- Converts a Number/Vector combination to a Quaternion format for generation"],"code":["argTypesToQuat[\"numberVector\"] = function(num,vec)","\treturn quicknew(num, vec.x, vec.y, vec.z) -- TODO Cannot change protect metatable? fix this","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numberVector\"]","param":["num","vec"]},"quat_methods:up":{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]},"argTypesToQuat[\"Angle\"]":{"summary":"\nConverts an Angle to a Quaternion format for generation ","description":"\nConverts an Angle to a Quaternion format for generation","comment":["--- Converts an Angle to a Quaternion format for generation"],"code":["argTypesToQuat[\"Angle\"] = function(ang)","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Angle\"]","param":["ang"]},"quat_methods:j":{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},"quat_lib.qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"quat_lib.New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"quat_methods:right":{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},"quat_lib.rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]}},"doc":[{"summary":"\nQuaternion library ","description":"\nQuaternion library","comment":["--- Quaternion library"],"code":[""]},{"comment":["--- Quaternion library","-- @shared"],"functions":{"1":"New","2":"abs","3":"conj","4":"exp","5":"inv","6":"log","7":"qMod","8":"qRotation","9":"qRotation","10":"qi","11":"qj","12":"qk","13":"rotationAngle","14":"rotationAxis","15":"rotationEulerAngle","16":"rotationVector","17":"slerp","18":"vec","conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},"New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]}},"class":"library","summary":"\nQuaternion library ","code":["local quat_lib, quat_lib_metamethods = SF.Libraries.Register(\"quaternion\")","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Quaternion Support","-- Converted from Wiremod's E2 Quaternion library for general lua use","-- Original code for use by Bubbus","-- Permission received for use from Bubbus by Radon","-- http:\\\\wiki.wiremod.com/?title=Expression2#Quaternion","--","-- Credits to Radon for addition to Starfall","-- Credits to Divran for painful amounts of testing","]]","","-- faster access to some math library functions","local math = math -- Because global lookups suck","local setmetatable = setmetatable","local abs   = math.abs","local Round = math.Round","local sqrt  = math.sqrt","local exp   = math.exp","local log   = math.log","local sin   = math.sin","local cos   = math.cos","local sinh  = math.sinh","local cosh  = math.cosh","local acos  = math.acos","local min \t= math.min","","local delta = wire_expression2_delta or 0.0000001000000","","local isValid = IsValid","","local deg2rad = math.pi/180","local rad2deg = 180/math.pi",""],"fields":[],"name":"quaternion","client":true,"description":"\nQuaternion library","libtbl":"quat_lib","tables":[],"server":true},{"comment":["--- Quaternion type"],"code":["local quat_methods, quat_metamethods = SF.Typedef(\"Quaternion\")","--[[quat_metamethods = {__index = quat_lib}","quat_lib.__metatable = quat_metamethods","quat_metamethods.__type = \"Quaternion\"","setmetatable(quat_lib, quat_metamethods)]]","","--****************************** Helper functions ******************************--","","local function quicknew(r, i, j, k)","\tlocal new = {r, i, j, k}","\tsetmetatable( new, quat_metamethods )","\treturn new","end","","local function qmul(lhs, rhs)","\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\treturn quicknew(","\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t)","end","","local function qexp(q)","\tlocal m = sqrt(q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tlocal u","\tif m ~= 0 then","\t\tu = { q[2]*sin(m)/m, q[3]*sin(m)/m, q[4]*sin(m)/m }","\telse","\t\tu = { 0, 0, 0 }","\tend","\tlocal r = exp(q[1])","\treturn quicknew( r*cos(m), r*u[1], r*u[2], r*u[3] )","end","","local function qlog(q)","\tlocal l = sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tif l == 0 then return { -1e+100, 0, 0, 0 } end","\tlocal u = { q[1]/l, q[2]/l, q[3]/l, q[4]/l }","\tlocal a = acos(u[1])","\tlocal m = sqrt(u[2]*u[2] + u[3]*u[3] + u[4]*u[4])","\tif abs(m) > delta then","\t\treturn quicknew( log(l), a*u[2]/m, a*u[3]/m, a*u[4]/m )","\telse","\t\treturn quicknew( log(l), 0, 0, 0 )  --when m is 0, u[2], u[3] and u[4] are 0 too","\tend","end","","--******************************************************************************--","","local argTypesToQuat = {}"],"typtbl":"quat_methods","fields":[],"name":"Quaternion","summary":"\nQuaternion type ","description":"\nQuaternion type","class":"class","methods":{"1":"conj","2":"forward","3":"i","4":"j","5":"k","6":"r","7":"real","8":"right","9":"up","conj":{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},"r":{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},"right":{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},"real":{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},"i":{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},"k":{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},"j":{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},"forward":{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},"up":{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]}}},{"summary":"\nConverts a number to a Quaternion format for generation ","description":"\nConverts a number to a Quaternion format for generation","comment":["--- Converts a number to a Quaternion format for generation"],"code":["argTypesToQuat[\"number\"] = function(num)","\treturn quicknew(num, 0, 0, 0)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"number\"]","param":["num"]},{"summary":"\nConverts 4 numbers to a Quaternion format for generation ","description":"\nConverts 4 numbers to a Quaternion format for generation","comment":["--- Converts 4 numbers to a Quaternion format for generation"],"code":["argTypesToQuat[\"numbernumbernumbernumber\"] = function(a,b,c,d)","\treturn quicknew(a,b,c,d)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numbernumbernumbernumber\"]","param":["a","b","c","d"]},{"summary":"\nConverts a Vector to a Quaternion format for generation ","description":"\nConverts a Vector to a Quaternion format for generation","comment":["--- Converts a Vector to a Quaternion format for generation"],"code":["argTypesToQuat[\"Vector\"] = function(vec)","\treturn quicknew(0, vec.x, vec.y, vec.z)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Vector\"]","param":["vec"]},{"summary":"\nConverts an Angle to a Quaternion format for generation ","description":"\nConverts an Angle to a Quaternion format for generation","comment":["--- Converts an Angle to a Quaternion format for generation"],"code":["argTypesToQuat[\"Angle\"] = function(ang)","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Angle\"]","param":["ang"]},{"summary":"\nConverts a Number/Vector combination to a Quaternion format for generation ","description":"\nConverts a Number/Vector combination to a Quaternion format for generation","comment":["--- Converts a Number/Vector combination to a Quaternion format for generation"],"code":["argTypesToQuat[\"numberVector\"] = function(num,vec)","\treturn quicknew(num, vec.x, vec.y, vec.z) -- TODO Cannot change protect metatable? fix this","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numberVector\"]","param":["num","vec"]},{"summary":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them ","description":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them","comment":["--- Converts two Vectors to a Quaternion format for generation using Cross product and the angle between them"],"code":["argTypesToQuat[\"VectorVector\"] = function(forward,up)","\tlocal x = Vector(forward.x, forward.y, forward.z)","\tlocal z = Vector(up.x, up.y, up.z)","\tlocal y = z:Cross(x):GetNormalized() --up x forward = left","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tlocal roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = y.z","\tif dot < 0 then roll = -roll end","","\tlocal p, y, r = ang.p, ang.y, roll","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"VectorVector\"]","param":["forward","up"]},{"summary":"\nConverts an Entity to a Quaternion format for generation ","description":"\nConverts an Entity to a Quaternion format for generation","comment":["--- Converts an Entity to a Quaternion format for generation"],"code":["argTypesToQuat[\"Entity\"] = function(ent)","\tent = SF.UnwrapObject( ent )","\t","\tif not isValid( ent ) then","\t\treturn quicknew( 0, 0, 0, 0 )","\tend","","\tlocal ang = ent:GetAngles()","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end","","argTypesToQuat[\"Vehicle\"] = argTypesToQuat[\"Entity\"]","argTypesToQuat[\"Weapon\"] = argTypesToQuat[\"Entity\"]","","",""],"private":false,"class":"function","name":"argTypesToQuat[\"Entity\"]","param":["ent"]},{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]},{"comment":["--- Returns quaternion for rotation about axis <axis> by angle <ang>"],"code":["function quat_lib.qRotation(axis, ang)","\tlocal ax = axis","\tax:Normalize()","\tlocal ang2 = ang*deg2rad*0.5","","\treturn quicknew( cos(ang2), ax.x*sin(ang2), ax.y*sin(ang2), ax.z*sin(ang2) )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nReturns quaternion for rotation about axis <axis> by angle <ang> ","private":false,"library":"quaternion","description":"\nReturns quaternion for rotation about axis <axis> by angle <ang>","param":["axis","ang"]},{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]},{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]}],"tables":[],"description":"\nQuaternion library","summary":"\nQuaternion library "},"callback.lua":{"libraries":[],"type":"file","name":"callback.lua","functions":{"1":"P:addListener","2":"P:dispatch","3":"P:removeListener","4":"SF.Callback.new","P:addListener":{"summary":"\nAdds a listener to the callback object's storage ","description":"\nAdds a listener to the callback object's storage","comment":["--- Adds a listener to the callback object's storage","-- @param func the callback function that will be called when data is returned"],"code":["function P:addListener( func )","\tself.listeners[func] = func","end",""],"private":false,"class":"function","name":"P:addListener","param":{"1":"func","func":"the callback function that will be called when data is returned"}},"P:dispatch":{"ret":"if any function errors, returns the error message","comment":["--- Calls all of the stored listeners, passing them the data you pass","-- @param ... data","-- @return if any function errors, returns the error message"],"code":["function P:dispatch( ... )","\tlocal error = nil","\tfor _, listener in pairs(self.listeners) do","\t\terror = pcall( listener, ... )","\tend","\t","\treturn error","end",""],"class":"function","name":"P:dispatch","private":false,"summary":"\nCalls all of the stored listeners, passing them the data you pass ","description":"\nCalls all of the stored listeners, passing them the data you pass","param":{"1":"...","...":"data"}},"SF.Callback.new":{"summary":"\n \nConstructor \n ","description":"\n \nConstructor \n","comment":["---------------------------------------------------------------------","-- Constructor","---------------------------------------------------------------------"],"code":["function SF.Callback.new()","\tlocal table = {}","\ttable.listeners = {}","\tsetmetatable( table, P_meta )","\t","\treturn table","end"],"private":false,"class":"function","name":"SF.Callback.new","param":[]},"P:removeListener":{"summary":"\nRemoves a listener from the callback object's storage ","description":"\nRemoves a listener from the callback object's storage","comment":["--- Removes a listener from the callback object's storage","-- @param func the function you want to remove from listening"],"code":["function P:removeListener( func )","\tself.listeners[func] = nil","end",""],"private":false,"class":"function","name":"P:removeListener","param":{"1":"func","func":"the function you want to remove from listening"}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF callback class.","---------------------------------------------------------------------"],"code":["","-- Initialize the class, and set it's __index value to itself.","local P, P_meta = SF.Typedef(\"Callback\")","P_meta.__newindex = function()","\treturn","end","","-- Store the class on starfall global table.","SF.Callback = {}",""],"summary":"\n \nSF callback class.","description":"\n \nSF callback class. \n","param":[]},{"summary":"\n \nMethods \n ","description":"\n \nMethods \n","comment":["---------------------------------------------------------------------","-- Methods","---------------------------------------------------------------------"],"code":[""]},{"summary":"\nAdds a listener to the callback object's storage ","description":"\nAdds a listener to the callback object's storage","comment":["--- Adds a listener to the callback object's storage","-- @param func the callback function that will be called when data is returned"],"code":["function P:addListener( func )","\tself.listeners[func] = func","end",""],"private":false,"class":"function","name":"P:addListener","param":{"1":"func","func":"the callback function that will be called when data is returned"}},{"summary":"\nRemoves a listener from the callback object's storage ","description":"\nRemoves a listener from the callback object's storage","comment":["--- Removes a listener from the callback object's storage","-- @param func the function you want to remove from listening"],"code":["function P:removeListener( func )","\tself.listeners[func] = nil","end",""],"private":false,"class":"function","name":"P:removeListener","param":{"1":"func","func":"the function you want to remove from listening"}},{"ret":"if any function errors, returns the error message","comment":["--- Calls all of the stored listeners, passing them the data you pass","-- @param ... data","-- @return if any function errors, returns the error message"],"code":["function P:dispatch( ... )","\tlocal error = nil","\tfor _, listener in pairs(self.listeners) do","\t\terror = pcall( listener, ... )","\tend","\t","\treturn error","end",""],"class":"function","name":"P:dispatch","private":false,"summary":"\nCalls all of the stored listeners, passing them the data you pass ","description":"\nCalls all of the stored listeners, passing them the data you pass","param":{"1":"...","...":"data"}},{"summary":"\n \nConstructor \n ","description":"\n \nConstructor \n","comment":["---------------------------------------------------------------------","-- Constructor","---------------------------------------------------------------------"],"code":["function SF.Callback.new()","\tlocal table = {}","\ttable.listeners = {}","\tsetmetatable( table, P_meta )","\t","\treturn table","end"],"private":false,"class":"function","name":"SF.Callback.new","param":[]}],"tables":[],"description":"\n \nSF callback class. \n","summary":"\n \nSF callback class."},"libs_sh/http.lua":{"libraries":{"1":"http","http":{"comment":["--- Http library. Requests content from urls.","-- @shared"],"functions":{"1":"canRequest","2":"get","3":"post","post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}},"canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}}},"class":"library","summary":"\nHttp library.","code":["local http_library, _ = SF.Libraries.Register( \"http\" )","local http_interval = CreateConVar( \"sf_http_interval\", \"0.5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"Interval in seconds in which one http request can be made\" )","local http_max_active = CreateConVar( \"sf_http_max_active\", \"3\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"The maximum amount of active http requests at the same time\" )","","local http_server_allowed, http_client_allowed","if SERVER then","\thttp_server_allowed = CreateConVar( \"sf_http_allowsv\", \"0\", { FCVAR_ARCHIVE, FCVAR_SERVER_CAN_EXECUTE }, \"Should http be allowed to run on the server?\" )","else","\thttp_client_allowed = CreateConVar( \"sf_http_allowcl\", \"0\", { FCVAR_ARCHIVE }, \"Should http from other starfalls be allowed?\" )","end","-- Initializes the lastRequest variable to a value which ensures that the first call to httpRequestReady returns true","-- and the \"active requests counter\" to 0","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.http = {","\t\tlastRequest = 0,","\t\tactive = 0","\t}","end )","","-- Returns an error when a http request was already triggered in the current interval","-- or the maximum amount of simultaneous requests is currently active, returns true otherwise","local function httpRequestReady ( instance )","\tlocal httpData = instance.data.http","\tif CurTime() - httpData.lastRequest < http_interval:GetFloat() or httpData.active >= http_max_active:GetInt() then","\t\tSF.throw( \"You can't run a new http request yet\", 2 )","\tend","\treturn true","end","","-- Runs the appropriate callback after a http request","local function runCallback ( instance, callback, ... )","\tif callback then","\t\tlocal args = { ... }","\t\tif IsValid( instance.data.entity ) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, unpack( args ) )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"http callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend","\tinstance.data.http.active = instance.data.http.active - 1","end",""],"fields":[],"name":"http","client":true,"description":"\nHttp library. Requests content from urls.","libtbl":"http_library","tables":[],"server":true}},"type":"file","name":"libs_sh/http.lua","functions":{"1":"http_library.canRequest","2":"http_library.get","3":"http_library.post","http_library.canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"http_library.get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}},"http_library.post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}}},"doc":[{"summary":"\nHTTP Library ","description":"\nHTTP Library","comment":["--- HTTP Library"],"code":[""]},{"comment":["--- Http library. Requests content from urls.","-- @shared"],"functions":{"1":"canRequest","2":"get","3":"post","post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}},"canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}}},"class":"library","summary":"\nHttp library.","code":["local http_library, _ = SF.Libraries.Register( \"http\" )","local http_interval = CreateConVar( \"sf_http_interval\", \"0.5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"Interval in seconds in which one http request can be made\" )","local http_max_active = CreateConVar( \"sf_http_max_active\", \"3\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"The maximum amount of active http requests at the same time\" )","","local http_server_allowed, http_client_allowed","if SERVER then","\thttp_server_allowed = CreateConVar( \"sf_http_allowsv\", \"0\", { FCVAR_ARCHIVE, FCVAR_SERVER_CAN_EXECUTE }, \"Should http be allowed to run on the server?\" )","else","\thttp_client_allowed = CreateConVar( \"sf_http_allowcl\", \"0\", { FCVAR_ARCHIVE }, \"Should http from other starfalls be allowed?\" )","end","-- Initializes the lastRequest variable to a value which ensures that the first call to httpRequestReady returns true","-- and the \"active requests counter\" to 0","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.http = {","\t\tlastRequest = 0,","\t\tactive = 0","\t}","end )","","-- Returns an error when a http request was already triggered in the current interval","-- or the maximum amount of simultaneous requests is currently active, returns true otherwise","local function httpRequestReady ( instance )","\tlocal httpData = instance.data.http","\tif CurTime() - httpData.lastRequest < http_interval:GetFloat() or httpData.active >= http_max_active:GetInt() then","\t\tSF.throw( \"You can't run a new http request yet\", 2 )","\tend","\treturn true","end","","-- Runs the appropriate callback after a http request","local function runCallback ( instance, callback, ... )","\tif callback then","\t\tlocal args = { ... }","\t\tif IsValid( instance.data.entity ) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, unpack( args ) )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"http callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend","\tinstance.data.http.active = instance.data.http.active - 1","end",""],"fields":[],"name":"http","client":true,"description":"\nHttp library. Requests content from urls.","libtbl":"http_library","tables":[],"server":true},{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}},{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\tif SERVER and not http_server_allowed:GetBool() then SF.throw( \"Server doesn't allow http. ( sf_http_allowsv 0 )\") end","\tif CLIENT and instance.player~=LocalPlayer() and not http_client_allowed:GetBool() then SF.throw(\"Http from others isn't allowed. ( sf_http_allowcl 0 )\") end","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}}],"tables":[],"description":"\nHTTP Library","summary":"\nHTTP Library "},"permissions/providers_cl/input.lua":{"type":"file","name":"permissions/providers_cl/input.lua","functions":[],"doc":[],"libraries":[],"tables":[]},"libs_sh/sounds.lua":{"libraries":{"1":"sounds","sounds":{"comment":["--- Sounds library.","-- @shared"],"functions":{"1":"create","create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}}},"class":"library","summary":"\nSounds library.","code":["local sound_library, _ = SF.Libraries.Register( \"sounds\" )","","SF.Sounds.Wrap = wrap","SF.Sounds.Unwrap = unwrap","SF.Sounds.Methods = sound_methods","SF.Sounds.Metatable = sound_metamethods","","-- Register Privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"sound.create\", \"Sound\", \"Allows the user to create sounds\" )","\tP.registerPrivilege( \"sound.modify\", \"Sound\", \"Allows the user to modify created sounds\" )","end","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.sounds = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.sounds.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tunwrap( s ):Stop()","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""],"fields":[],"name":"sounds","client":true,"description":"\nSounds library.","libtbl":"sound_library","tables":[],"server":true}},"type":"file","name":"libs_sh/sounds.lua","functions":{"1":"sound_library.create","2":"sound_methods:isPlaying","3":"sound_methods:play","4":"sound_methods:setPitch","5":"sound_methods:setSoundLevel","6":"sound_methods:setVolume","7":"sound_methods:stop","sound_methods:setSoundLevel":{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}},"sound_library.create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}},"sound_methods:stop":{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},"sound_methods:setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}},"sound_methods:isPlaying":{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},"sound_methods:setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},"sound_methods:play":{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]}},"doc":[{"comment":["--- Sound type","-- @shared"],"code":["local sound_methods, sound_metamethods = SF.Typedef( \"Sound\" )","local wrap, unwrap = SF.CreateWrapper( sound_metamethods, true, false, debug.getregistry().CSoundPatch )",""],"typtbl":"sound_methods","summary":"\nSound type ","fields":[],"name":"Sound","server":true,"description":"\nSound type","client":true,"class":"class","methods":{"1":"isPlaying","2":"play","3":"setPitch","4":"setSoundLevel","5":"setVolume","6":"stop","setSoundLevel":{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}},"stop":{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},"isPlaying":{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},"play":{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}}}},{"comment":["--- Sounds library.","-- @shared"],"functions":{"1":"create","create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}}},"class":"library","summary":"\nSounds library.","code":["local sound_library, _ = SF.Libraries.Register( \"sounds\" )","","SF.Sounds.Wrap = wrap","SF.Sounds.Unwrap = unwrap","SF.Sounds.Methods = sound_methods","SF.Sounds.Metatable = sound_metamethods","","-- Register Privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"sound.create\", \"Sound\", \"Allows the user to create sounds\" )","\tP.registerPrivilege( \"sound.modify\", \"Sound\", \"Allows the user to modify created sounds\" )","end","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.sounds = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.sounds.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tunwrap( s ):Stop()","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""],"fields":[],"name":"sounds","client":true,"description":"\nSounds library.","libtbl":"sound_library","tables":[],"server":true},{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}},{"summary":"\n ","description":"\n","comment":["--------------------------------------------------"],"code":[""]},{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]},{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}},{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}}],"tables":[],"description":"\nSound type","summary":"\nSound type "},"libs_cl/file.lua":{"libraries":{"1":"file","file":{"comment":["--- File functions. Allows modification of files.","-- @client"],"functions":{"1":"append","2":"createDir","3":"delete","4":"exists","5":"find","6":"read","7":"write","read":{"ret":"Contents, or nil if error","comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"write":{"ret":"True if OK, nil if error","comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"wb\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"delete":{"ret":"True if successful, nil if error","comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"append":{"comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file."],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"ab\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end",""],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"find":{"ret":["Table of file names","Table of directory names"],"comment":["--- Enumerates a directory","-- @param path The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'","-- @param sorting Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","-- @return Table of file names","-- @return Table of directory names"],"code":["function file_library.find ( path, sorting )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif sorting then SF.CheckType( sorting, \"string\" ) end","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Find( \"sf_filedata/\" .. path, \"DATA\", sorting )","end"],"class":"function","name":"file_library.find","summary":"\nEnumerates a directory ","private":false,"library":"file","description":"\nEnumerates a directory","param":{"1":"path","2":"sorting","sorting":"Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","path":"The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'"}},"exists":{"ret":"True if exists, false if not, nil if error","comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"class":"library","summary":"\nFile functions.","fields":[],"name":"file","client":true,"description":"\nFile functions. Allows modification of files.","libtbl":"file_library","tables":[],"code":["local file_library, _ = SF.Libraries.Register( \"file\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"file.read\", \"Read files\", \"Allows the user to read files from data/sf_filedata directory\" )","\tP.registerPrivilege( \"file.write\", \"Write files\", \"Allows the user to write files to data/sf_filedata directory\" )","\tP.registerPrivilege( \"file.exists\", \"File existence check\", \"Allows the user to determine whether a file in data/sf_filedata exists\" )","end","","file.CreateDir( \"sf_filedata/\" )",""]}},"type":"file","name":"libs_cl/file.lua","functions":{"1":"file_library.append","2":"file_library.createDir","3":"file_library.delete","4":"file_library.exists","5":"file_library.find","6":"file_library.read","7":"file_library.write","file_library.find":{"ret":["Table of file names","Table of directory names"],"comment":["--- Enumerates a directory","-- @param path The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'","-- @param sorting Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","-- @return Table of file names","-- @return Table of directory names"],"code":["function file_library.find ( path, sorting )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif sorting then SF.CheckType( sorting, \"string\" ) end","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Find( \"sf_filedata/\" .. path, \"DATA\", sorting )","end"],"class":"function","name":"file_library.find","summary":"\nEnumerates a directory ","private":false,"library":"file","description":"\nEnumerates a directory","param":{"1":"path","2":"sorting","sorting":"Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","path":"The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.write":{"ret":"True if OK, nil if error","comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"wb\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.exists":{"ret":"True if exists, false if not, nil if error","comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.append":{"comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file."],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"ab\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.read":{"ret":"Contents, or nil if error","comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end",""],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.delete":{"ret":"True if successful, nil if error","comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"doc":[{"summary":"\n \nFile functions \n ","description":"\n \nFile functions \n","comment":["-------------------------------------------------------------------------------","-- File functions","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- File functions. Allows modification of files.","-- @client"],"functions":{"1":"append","2":"createDir","3":"delete","4":"exists","5":"find","6":"read","7":"write","read":{"ret":"Contents, or nil if error","comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"write":{"ret":"True if OK, nil if error","comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"wb\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"delete":{"ret":"True if successful, nil if error","comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"append":{"comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file."],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"ab\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end",""],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"find":{"ret":["Table of file names","Table of directory names"],"comment":["--- Enumerates a directory","-- @param path The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'","-- @param sorting Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","-- @return Table of file names","-- @return Table of directory names"],"code":["function file_library.find ( path, sorting )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif sorting then SF.CheckType( sorting, \"string\" ) end","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Find( \"sf_filedata/\" .. path, \"DATA\", sorting )","end"],"class":"function","name":"file_library.find","summary":"\nEnumerates a directory ","private":false,"library":"file","description":"\nEnumerates a directory","param":{"1":"path","2":"sorting","sorting":"Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","path":"The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'"}},"exists":{"ret":"True if exists, false if not, nil if error","comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"class":"library","summary":"\nFile functions.","fields":[],"name":"file","client":true,"description":"\nFile functions. Allows modification of files.","libtbl":"file_library","tables":[],"code":["local file_library, _ = SF.Libraries.Register( \"file\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"file.read\", \"Read files\", \"Allows the user to read files from data/sf_filedata directory\" )","\tP.registerPrivilege( \"file.write\", \"Write files\", \"Allows the user to write files to data/sf_filedata directory\" )","\tP.registerPrivilege( \"file.exists\", \"File existence check\", \"Allows the user to determine whether a file in data/sf_filedata exists\" )","end","","file.CreateDir( \"sf_filedata/\" )",""]},{"ret":"Contents, or nil if error","comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":"True if OK, nil if error","comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"wb\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file."],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\t","\tlocal f = file.Open( \"sf_filedata/\" .. path, \"ab\", \"DATA\" )","\tif not f then SF.throw( \"Couldn't open file for writing.\", 2 ) return end","\tf:Write( data )","\tf:Close()","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":"True if exists, false if not, nil if error","comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":"True if successful, nil if error","comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end",""],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":["Table of file names","Table of directory names"],"comment":["--- Enumerates a directory","-- @param path The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'","-- @param sorting Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","-- @return Table of file names","-- @return Table of directory names"],"code":["function file_library.find ( path, sorting )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif sorting then SF.CheckType( sorting, \"string\" ) end","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Find( \"sf_filedata/\" .. path, \"DATA\", sorting )","end"],"class":"function","name":"file_library.find","summary":"\nEnumerates a directory ","private":false,"library":"file","description":"\nEnumerates a directory","param":{"1":"path","2":"sorting","sorting":"Optional sorting arguement. Either nameasc, namedesc, dateasc, datedesc","path":"The folder to enumerate, relative to data/sf_filedata/. Cannot contain '..'"}}],"tables":[],"description":"\n \nFile functions \n","summary":"\n \nFile functions \n "},"preprocessor.lua":{"libraries":[],"type":"file","name":"preprocessor.lua","functions":{"1":"SF.Preprocessor.ParseDirectives","2":"SF.Preprocessor.SetGlobalDirective","SF.Preprocessor.SetGlobalDirective":{"summary":"\nSets a global preprocessor directive.","description":"\nSets a global preprocessor directive.","comment":["--- Sets a global preprocessor directive.","-- @param directive The directive to set.","-- @param func The callback. Takes the directive arguments, the file name, and instance.data"],"code":["function SF.Preprocessor.SetGlobalDirective(directive, func)","\tSF.Preprocessor.directives[directive] = func","end","","local function FindComments( line )","\tlocal ret, count, pos, found = {}, 0, 1","\trepeat","\t\tfound = line:find( '[\"%-%[%]]', pos )","\t\tif (found) then -- We found something","\t\t\tlocal oldpos = pos","\t\t\t","\t\t\tlocal char = line:sub(found,found)","\t\t\tif char == \"-\" then","\t\t\t\tif line:sub(found,found+1) == \"--\" then","\t\t\t\t\t-- Comment beginning","\t\t\t\t\tif line:sub(found,found+3) == \"--[[\" then","\t\t\t\t\t\t-- Block Comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"start\", pos = found}","\t\t\t\t\t\tpos = found + 4","\t\t\t\t\telse","\t\t\t\t\t\t-- Line comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"line\", pos = found}","\t\t\t\t\t\tpos = found + 2","\t\t\t\t\tend","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"[\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1, found+level+1) == \"[\" then","\t\t\t\t\t-- Block string start","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"stringblock\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"]\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1,found+level+1) == \"]\" then","\t\t\t\t\t-- Ending","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"end\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"\\\"\" then","\t\t\t\tif line:sub(found-1,found-1) == \"\\\\\" and line:sub(found-2,found-1) ~= \"\\\\\\\\\" then","\t\t\t\t\t-- Escaped character","\t\t\t\t\tpos = found+1","\t\t\t\telse","\t\t\t\t\t-- String","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"string\", pos = found}","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\tif oldpos == pos then error(\"Regex found something, but nothing handled it\") end","\t\tend","\tuntil not found","\treturn ret, count","end","",""],"private":false,"class":"function","name":"SF.Preprocessor.SetGlobalDirective","param":{"1":"directive","2":"func","directive":"The directive to set.","func":"The callback. Takes the directive arguments, the file name, and instance.data"}},"SF.Preprocessor.ParseDirectives":{"summary":"\nParses a source file for directives.","description":"\nParses a source file for directives.","comment":["--- Parses a source file for directives.","-- @param filename The file name of the source code","-- @param source The source code to parse.","-- @param directives A table of additional directives to use.","-- @param data The data table passed to the directives."],"code":["function SF.Preprocessor.ParseDirectives(filename, source, directives, data)","\tlocal ending = nil","\tlocal endingLevel = nil","\t","\tlocal str = source","\twhile str ~= \"\" do","\t\tlocal line","\t\tline, str = string.match(str,\"^([^\\n]*)\\n?(.*)$\")","\t\t","\t\tfor _,comment in ipairs(FindComments(line)) do","\t\t\tif ending then","\t\t\t\tif comment.type == ending then","\t\t\t\t\tif endingLevel then","\t\t\t\t\t\tif comment.level and comment.level == endingLevel then","\t\t\t\t\t\t\tending = nil","\t\t\t\t\t\t\tendingLevel = nil","\t\t\t\t\t\t\tend","\t\t\t\t\telse","\t\t\t\t\t\tending = nil","\t\t\t\t\tend","\t\t\t\tend","\t\t\telseif comment.type == \"start\" then","\t\t\t\tending = \"end\"","\t\t\telseif comment.type == \"string\" then","\t\t\t\tending = \"string\"","\t\t\telseif comment.type == \"stringblock\" then","\t\t\t\tending = \"end\"","\t\t\t\tendingLevel = comment.level","\t\t\telseif comment.type == \"line\" then","\t\t\t\tlocal directive, args = string.match(line,\"--@([^ ]+)%s*(.*)$\")","\t\t\t\tlocal func = directives[directive] or SF.Preprocessor.directives[directive]","\t\t\t\tif func then","\t\t\t\t\tfunc(args, filename, data)","\t\t\t\tend","\t\t\tend","\t\tend","\t\t","\t\tif ending == \"newline\" then ending = nil end","\tend","end","","local function directive_include(args, filename, data)","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","\t","\tlocal incl = data.includes[filename]","\tincl[#incl+1] = args","end","SF.Preprocessor.SetGlobalDirective(\"include\",directive_include)","","local function directive_includedir( args, filename, data )","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","","\tlocal incl = data.includes[filename]","","\tlocal files = file.Find( \"starfall/\" ..args.. \"/*\", \"DATA\" )","\tif files then","\t\tfor _, v in pairs( files ) do","\t\t\tincl[ #incl+1 ] = args .. \"/\" .. v","\t\tend","\tend","end","SF.Preprocessor.SetGlobalDirective( \"includedir\", directive_includedir )","","local function directive_name(args, filename, data)","\tif not data.scriptnames then data.scriptnames = {} end","\tdata.scriptnames[filename] = args","end","SF.Preprocessor.SetGlobalDirective(\"name\",directive_name)","","local function directive_sharedscreen(args, filename, data)","\tif not data.sharedscreen then data.sharedscreen = true end","\t","end","SF.Preprocessor.SetGlobalDirective(\"sharedscreen\",directive_sharedscreen)","","local function directive_model( args, filename, data )","\tif not data.models then data.models = {} end","\tdata.models[ filename ] = args","end","SF.Preprocessor.SetGlobalDirective( \"model\", directive_model )","","SF.Preprocessor.SetGlobalDirective( \"server\", function( args, filename, data )","\tif not data.serverorclient then data.serverorclient = {} end","\tdata.serverorclient[ filename ] = \"server\"","end)","","SF.Preprocessor.SetGlobalDirective( \"client\", function( args, filename, data )","\tif not data.serverorclient then data.serverorclient = {} end","\tdata.serverorclient[ filename ] = \"client\"","end)",""],"private":false,"class":"function","name":"SF.Preprocessor.ParseDirectives","param":{"1":"filename","2":"source","3":"directives","4":"data","data":"The data table passed to the directives.","directives":"A table of additional directives to use.","source":"The source code to parse.","filename":"The file name of the source code"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- SF Preprocessor.","-- Processes code for compile time directives.","-------------------------------------------------------------------------------"],"code":["","-- TODO: Make an @include-only parser","","SF.Preprocessor = {}","SF.Preprocessor.directives = {}",""],"summary":"\n \nSF Preprocessor.","description":"\n \nSF Preprocessor. \nProcesses code for compile time directives. \n","param":[]},{"summary":"\nSets a global preprocessor directive.","description":"\nSets a global preprocessor directive.","comment":["--- Sets a global preprocessor directive.","-- @param directive The directive to set.","-- @param func The callback. Takes the directive arguments, the file name, and instance.data"],"code":["function SF.Preprocessor.SetGlobalDirective(directive, func)","\tSF.Preprocessor.directives[directive] = func","end","","local function FindComments( line )","\tlocal ret, count, pos, found = {}, 0, 1","\trepeat","\t\tfound = line:find( '[\"%-%[%]]', pos )","\t\tif (found) then -- We found something","\t\t\tlocal oldpos = pos","\t\t\t","\t\t\tlocal char = line:sub(found,found)","\t\t\tif char == \"-\" then","\t\t\t\tif line:sub(found,found+1) == \"--\" then","\t\t\t\t\t-- Comment beginning","\t\t\t\t\tif line:sub(found,found+3) == \"--[[\" then","\t\t\t\t\t\t-- Block Comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"start\", pos = found}","\t\t\t\t\t\tpos = found + 4","\t\t\t\t\telse","\t\t\t\t\t\t-- Line comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"line\", pos = found}","\t\t\t\t\t\tpos = found + 2","\t\t\t\t\tend","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"[\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1, found+level+1) == \"[\" then","\t\t\t\t\t-- Block string start","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"stringblock\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"]\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1,found+level+1) == \"]\" then","\t\t\t\t\t-- Ending","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"end\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"\\\"\" then","\t\t\t\tif line:sub(found-1,found-1) == \"\\\\\" and line:sub(found-2,found-1) ~= \"\\\\\\\\\" then","\t\t\t\t\t-- Escaped character","\t\t\t\t\tpos = found+1","\t\t\t\telse","\t\t\t\t\t-- String","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"string\", pos = found}","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\tif oldpos == pos then error(\"Regex found something, but nothing handled it\") end","\t\tend","\tuntil not found","\treturn ret, count","end","",""],"private":false,"class":"function","name":"SF.Preprocessor.SetGlobalDirective","param":{"1":"directive","2":"func","directive":"The directive to set.","func":"The callback. Takes the directive arguments, the file name, and instance.data"}},{"summary":"\nParses a source file for directives.","description":"\nParses a source file for directives.","comment":["--- Parses a source file for directives.","-- @param filename The file name of the source code","-- @param source The source code to parse.","-- @param directives A table of additional directives to use.","-- @param data The data table passed to the directives."],"code":["function SF.Preprocessor.ParseDirectives(filename, source, directives, data)","\tlocal ending = nil","\tlocal endingLevel = nil","\t","\tlocal str = source","\twhile str ~= \"\" do","\t\tlocal line","\t\tline, str = string.match(str,\"^([^\\n]*)\\n?(.*)$\")","\t\t","\t\tfor _,comment in ipairs(FindComments(line)) do","\t\t\tif ending then","\t\t\t\tif comment.type == ending then","\t\t\t\t\tif endingLevel then","\t\t\t\t\t\tif comment.level and comment.level == endingLevel then","\t\t\t\t\t\t\tending = nil","\t\t\t\t\t\t\tendingLevel = nil","\t\t\t\t\t\t\tend","\t\t\t\t\telse","\t\t\t\t\t\tending = nil","\t\t\t\t\tend","\t\t\t\tend","\t\t\telseif comment.type == \"start\" then","\t\t\t\tending = \"end\"","\t\t\telseif comment.type == \"string\" then","\t\t\t\tending = \"string\"","\t\t\telseif comment.type == \"stringblock\" then","\t\t\t\tending = \"end\"","\t\t\t\tendingLevel = comment.level","\t\t\telseif comment.type == \"line\" then","\t\t\t\tlocal directive, args = string.match(line,\"--@([^ ]+)%s*(.*)$\")","\t\t\t\tlocal func = directives[directive] or SF.Preprocessor.directives[directive]","\t\t\t\tif func then","\t\t\t\t\tfunc(args, filename, data)","\t\t\t\tend","\t\t\tend","\t\tend","\t\t","\t\tif ending == \"newline\" then ending = nil end","\tend","end","","local function directive_include(args, filename, data)","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","\t","\tlocal incl = data.includes[filename]","\tincl[#incl+1] = args","end","SF.Preprocessor.SetGlobalDirective(\"include\",directive_include)","","local function directive_includedir( args, filename, data )","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","","\tlocal incl = data.includes[filename]","","\tlocal files = file.Find( \"starfall/\" ..args.. \"/*\", \"DATA\" )","\tif files then","\t\tfor _, v in pairs( files ) do","\t\t\tincl[ #incl+1 ] = args .. \"/\" .. v","\t\tend","\tend","end","SF.Preprocessor.SetGlobalDirective( \"includedir\", directive_includedir )","","local function directive_name(args, filename, data)","\tif not data.scriptnames then data.scriptnames = {} end","\tdata.scriptnames[filename] = args","end","SF.Preprocessor.SetGlobalDirective(\"name\",directive_name)","","local function directive_sharedscreen(args, filename, data)","\tif not data.sharedscreen then data.sharedscreen = true end","\t","end","SF.Preprocessor.SetGlobalDirective(\"sharedscreen\",directive_sharedscreen)","","local function directive_model( args, filename, data )","\tif not data.models then data.models = {} end","\tdata.models[ filename ] = args","end","SF.Preprocessor.SetGlobalDirective( \"model\", directive_model )","","SF.Preprocessor.SetGlobalDirective( \"server\", function( args, filename, data )","\tif not data.serverorclient then data.serverorclient = {} end","\tdata.serverorclient[ filename ] = \"server\"","end)","","SF.Preprocessor.SetGlobalDirective( \"client\", function( args, filename, data )","\tif not data.serverorclient then data.serverorclient = {} end","\tdata.serverorclient[ filename ] = \"client\"","end)",""],"private":false,"class":"function","name":"SF.Preprocessor.ParseDirectives","param":{"1":"filename","2":"source","3":"directives","4":"data","data":"The data table passed to the directives.","directives":"A table of additional directives to use.","source":"The source code to parse.","filename":"The file name of the source code"}},{"description":"\nMark a file to be included in the upload. \nThis is required to use the file in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"include","summary":"\nMark a file to be included in the upload.","usage":"\n--@include lib/someLibrary.txt \n \nrequire( \"lib/someLibrary.txt\" ) \n-- CODE","comment":["--- Mark a file to be included in the upload.","-- This is required to use the file in require() and dofile()","-- @name include","-- @class directive","-- @param path Path to the file","-- @usage","-- \\--@include lib/someLibrary.txt","-- ","-- require( \"lib/someLibrary.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the file"}},{"description":"\nMark a directory to be included in the upload. \nThis is optional to include all files in the directory in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"includedir","summary":"\nMark a directory to be included in the upload.","usage":"\n--@includedir lib \n \nrequire( \"lib/someLibraryInLib.txt\" ) \nrequire( \"lib/someOtherLibraryInLib.txt\" ) \n-- CODE","comment":["--- Mark a directory to be included in the upload.","-- This is optional to include all files in the directory in require() and dofile()","-- @name includedir","-- @class directive","-- @param path Path to the directory","-- @usage","-- \\--@includedir lib","--","-- require( \"lib/someLibraryInLib.txt\" )","-- require( \"lib/someOtherLibraryInLib.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the directory"}},{"description":"\nSet the name of the script. \nThis will become the name of the tab and will show on the overlay of the processor","code":["","--","-- if SERVER then","-- \\\t-- Do important calculations","-- \\\t-- Send net message","-- else","-- \\\t-- Display result of important calculations","-- end",""],"class":"directive","classForced":true,"name":"name","summary":"\nSet the name of the script.","usage":"\n--@name Awesome script \n-- CODE","comment":["--- Set the name of the script.","-- This will become the name of the tab and will show on the overlay of the processor","-- @name name","-- @class directive","-- @param name Name of the script","-- @usage","-- \\--@name Awesome script","-- -- CODE"],"param":{"1":"name","name":"Name of the script"}},{"description":"\nSet the model of the processor entity. \nThis does not set the model of the screen entity","code":[""],"class":"directive","classForced":true,"name":"model","summary":"\nSet the model of the processor entity.","usage":"\n--@model models/props_junk/watermelon01.mdl \n-- CODE","comment":["--- Set the model of the processor entity.","-- This does not set the model of the screen entity","-- @name model","-- @class directive","-- @param model String of the model","-- @usage","-- \\--@model models/props_junk/watermelon01.mdl","-- -- CODE"],"param":{"1":"model","model":"String of the model"}},{"description":"\nSet the processor to only run on the server. Shared is default","code":[""],"class":"directive","classForced":true,"name":"server","summary":"\nSet the processor to only run on the server.","usage":"\n--@server \n-- CODE","comment":["--- Set the processor to only run on the server. Shared is default","-- @name server","-- @class directive","-- @usage","-- \\--@server","-- -- CODE"],"param":[]},{"description":"\nSet the processor to only run on the client. Shared is default","code":[],"class":"directive","classForced":true,"name":"client","summary":"\nSet the processor to only run on the client.","usage":"\n--@client \n-- CODE","comment":["--- Set the processor to only run on the client. Shared is default","-- @name client","-- @class directive","-- @usage","-- \\--@client","-- -- CODE"],"param":[]}],"tables":[],"description":"\n \nSF Preprocessor. \nProcesses code for compile time directives. \n","summary":"\n \nSF Preprocessor."},"libs_sh/hook.lua":{"libraries":{"1":"hook","hook":{"comment":["--- Deals with hooks","-- @shared"],"functions":{"1":"add","2":"remove","3":"run","4":"runRemote","runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal results = {}","\tfor k, _ in pairs( recipients ) do","","\t\tlocal result = { k:runScriptHookForResult( \"remote\", SF.WrapObject( instance.data.entity ), SF.WrapObject( instance.player ), ... ) }","\t\tlocal ok = table.remove( result, 1 )","","\t\tif ok and result[1] then","\t\t\tresults[ #results + 1 ] = result","\t\telse","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\tend","","\tend","\treturn results","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tif not instance.hooks[ hookname ] then continue end","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","","\t\tlocal ok = ret[1]","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, {unpack(ret, 2)}, ... )","\t\t\t\tif sane ~= nil then result = { sane } end","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 2 ], ret[ 3 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},"run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}}},"class":"library","summary":"\nDeals with hooks ","code":["local hook_library, _ = SF.Libraries.Register( \"hook\" )","local registered_instances = {}",""],"fields":[],"name":"hook","client":true,"description":"\nDeals with hooks","libtbl":"hook_library","tables":[],"server":true}},"type":"file","name":"libs_sh/hook.lua","functions":{"1":"SF.hookAdd","2":"hook_library.add","3":"hook_library.remove","4":"hook_library.run","5":"hook_library.runRemote","hook_library.runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal results = {}","\tfor k, _ in pairs( recipients ) do","","\t\tlocal result = { k:runScriptHookForResult( \"remote\", SF.WrapObject( instance.data.entity ), SF.WrapObject( instance.player ), ... ) }","\t\tlocal ok = table.remove( result, 1 )","","\t\tif ok and result[1] then","\t\t\tresults[ #results + 1 ] = result","\t\telse","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\tend","","\tend","\treturn results","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"hook_library.add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}},"hook_library.run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"SF.hookAdd":{"comment":["--- Add a GMod hook so that SF gets access to it","-- @shared","-- @param hookname The hook name. In-SF hookname will be lowercased","-- @param customfunc Optional custom function"],"code":["function SF.hookAdd ( hookname, customfunc )","\thooks[ #hooks + 1 ] = hookname","\tlocal lower = hookname:lower()","","\t--Ensure that SF hooks are called after all other hooks.","\tlocal detour = GAMEMODE[ hookname ]","\tif detour then","\t\tGAMEMODE[ hookname ] = function ( self, ... )","\t\t\tlocal a, b, c, d, e, f = run( lower, customfunc, ... )","\t\t\tif ( a != nil ) then","\t\t\t\treturn a, b, c, d, e, f","\t\t\telse","\t\t\t\treturn detour( self, ... )","\t\t\tend","\t\tend","\telse","\t\tGAMEMODE[ hookname ] = function ( self, ... )","\t\t\treturn run( lower, customfunc, ... )","\t\tend","\tend","end","","--Can only return if you are the first argument","local function returnOnlyOnYourself( instance, args, ply )","\tif instance.player ~= ply then return end","\tif args then return args[1] end","end","","--Can only return false on yourself","local function returnOnlyOnYourselfFalse( instance, args, ply )","\tif instance.player ~= ply then return end","\tif args and args[1]==false then return false end","end","","if SFHooksAdded then return end","SFHooksAdded = true","","local add = SF.hookAdd","","if SERVER then","\t-- Server hooks","\tadd( \"GravGunOnPickedUp\" )","\tadd( \"GravGunOnDropped\" )","\tadd( \"OnPhysgunFreeze\" )","\tadd( \"OnPhysgunReload\" )","\tadd( \"PlayerDeath\" )","\tadd( \"PlayerDisconnected\" )","\tadd( \"PlayerInitialSpawn\" )","\tadd( \"PlayerSpawn\" )","\tadd( \"PlayerEnteredVehicle\" )","\tadd( \"PlayerLeaveVehicle\" )","\tadd( \"PlayerSay\", returnOnlyOnYourself )","\tadd( \"PlayerSpray\" )","\tadd( \"PlayerUse\" )","\tadd( \"PlayerSwitchFlashlight\" )","\tadd( \"PlayerCanPickupWeapon\", returnOnlyOnYourselfFalse  )","","\thook.Add(\"EntityTakeDamage\", \"SF_EntityTakeDamage\", function( target, dmg )","\t\tlocal lower = (\"EntityTakeDamage\"):lower()","\t\trun( lower, nil, target, dmg:GetAttacker(),","\t\t\tdmg:GetInflictor(),","\t\t\tdmg:GetDamage(),","\t\t\tdmg:GetDamageType(),","\t\t\tdmg:GetDamagePosition(),","\t\t\tdmg:GetDamageForce() )","\tend)","","else","\t-- Client hooks","\tadd( \"StartChat\" )","\tadd( \"FinishChat\" )","end","","-- Shared hooks","","-- Player hooks","add( \"PlayerHurt\" )","add( \"PlayerNoClip\" )","add( \"KeyPress\" )","add( \"KeyRelease\" )","add( \"GravGunPunt\" )","add( \"PhysgunPickup\" )","add( \"PhysgunDrop\" )","add( \"PlayerSwitchWeapon\", returnOnlyOnYourselfFalse )","","-- Entity hooks","add( \"OnEntityCreated\" )","add( \"EntityRemoved\" )","add( \"PropBreak\" )","","-- Other","add( \"EndEntityDriving\" )","add( \"StartEntityDriving\" )","add( \"Tick\" )",""],"class":"function","summary":"\nAdd a GMod hook so that SF gets access to it ","name":"SF.hookAdd","server":true,"private":false,"client":true,"description":"\nAdd a GMod hook so that SF gets access to it","param":{"1":"hookname","2":"customfunc","customfunc":"Optional custom function","hookname":"The hook name. In-SF hookname will be lowercased"}},"hook_library.remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tif not instance.hooks[ hookname ] then continue end","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","","\t\tlocal ok = ret[1]","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, {unpack(ret, 2)}, ... )","\t\t\t\tif sane ~= nil then result = { sane } end","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 2 ], ret[ 3 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}}},"doc":[{"summary":"\n \nHook library \n ","description":"\n \nHook library \n","comment":["-------------------------------------------------------------------------------","-- Hook library","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Deals with hooks","-- @shared"],"functions":{"1":"add","2":"remove","3":"run","4":"runRemote","runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal results = {}","\tfor k, _ in pairs( recipients ) do","","\t\tlocal result = { k:runScriptHookForResult( \"remote\", SF.WrapObject( instance.data.entity ), SF.WrapObject( instance.player ), ... ) }","\t\tlocal ok = table.remove( result, 1 )","","\t\tif ok and result[1] then","\t\t\tresults[ #results + 1 ] = result","\t\telse","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\tend","","\tend","\treturn results","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tif not instance.hooks[ hookname ] then continue end","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","","\t\tlocal ok = ret[1]","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, {unpack(ret, 2)}, ... )","\t\t\t\tif sane ~= nil then result = { sane } end","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 2 ], ret[ 3 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},"run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}}},"class":"library","summary":"\nDeals with hooks ","code":["local hook_library, _ = SF.Libraries.Register( \"hook\" )","local registered_instances = {}",""],"fields":[],"name":"hook","client":true,"description":"\nDeals with hooks","libtbl":"hook_library","tables":[],"server":true},{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}},{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},{"description":"\nRemote hook. \nThis hook can be called from other instances","code":[""],"class":"hook","classForced":true,"name":"remote","summary":"\nRemote hook.","server":true,"client":true,"comment":["--- Remote hook.","-- This hook can be called from other instances","-- @name remote","-- @class hook","-- @shared","-- @param sender The entity that caused the hook to run","-- @param owner The owner of the sender","-- @param ... The payload that was supplied when calling the hook"],"param":{"1":"sender","2":"owner","3":"...","sender":"The entity that caused the hook to run","...":"The payload that was supplied when calling the hook","owner":"The owner of the sender"}},{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal results = {}","\tfor k, _ in pairs( recipients ) do","","\t\tlocal result = { k:runScriptHookForResult( \"remote\", SF.WrapObject( instance.data.entity ), SF.WrapObject( instance.player ), ... ) }","\t\tlocal ok = table.remove( result, 1 )","","\t\tif ok and result[1] then","\t\t\tresults[ #results + 1 ] = result","\t\telse","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\tend","","\tend","\treturn results","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tif not instance.hooks[ hookname ] then continue end","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","","\t\tlocal ok = ret[1]","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, {unpack(ret, 2)}, ... )","\t\t\t\tif sane ~= nil then result = { sane } end","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 2 ], ret[ 3 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},{"comment":["--- Add a GMod hook so that SF gets access to it","-- @shared","-- @param hookname The hook name. In-SF hookname will be lowercased","-- @param customfunc Optional custom function"],"code":["function SF.hookAdd ( hookname, customfunc )","\thooks[ #hooks + 1 ] = hookname","\tlocal lower = hookname:lower()","","\t--Ensure that SF hooks are called after all other hooks.","\tlocal detour = GAMEMODE[ hookname ]","\tif detour then","\t\tGAMEMODE[ hookname ] = function ( self, ... )","\t\t\tlocal a, b, c, d, e, f = run( lower, customfunc, ... )","\t\t\tif ( a != nil ) then","\t\t\t\treturn a, b, c, d, e, f","\t\t\telse","\t\t\t\treturn detour( self, ... )","\t\t\tend","\t\tend","\telse","\t\tGAMEMODE[ hookname ] = function ( self, ... )","\t\t\treturn run( lower, customfunc, ... )","\t\tend","\tend","end","","--Can only return if you are the first argument","local function returnOnlyOnYourself( instance, args, ply )","\tif instance.player ~= ply then return end","\tif args then return args[1] end","end","","--Can only return false on yourself","local function returnOnlyOnYourselfFalse( instance, args, ply )","\tif instance.player ~= ply then return end","\tif args and args[1]==false then return false end","end","","if SFHooksAdded then return end","SFHooksAdded = true","","local add = SF.hookAdd","","if SERVER then","\t-- Server hooks","\tadd( \"GravGunOnPickedUp\" )","\tadd( \"GravGunOnDropped\" )","\tadd( \"OnPhysgunFreeze\" )","\tadd( \"OnPhysgunReload\" )","\tadd( \"PlayerDeath\" )","\tadd( \"PlayerDisconnected\" )","\tadd( \"PlayerInitialSpawn\" )","\tadd( \"PlayerSpawn\" )","\tadd( \"PlayerEnteredVehicle\" )","\tadd( \"PlayerLeaveVehicle\" )","\tadd( \"PlayerSay\", returnOnlyOnYourself )","\tadd( \"PlayerSpray\" )","\tadd( \"PlayerUse\" )","\tadd( \"PlayerSwitchFlashlight\" )","\tadd( \"PlayerCanPickupWeapon\", returnOnlyOnYourselfFalse  )","","\thook.Add(\"EntityTakeDamage\", \"SF_EntityTakeDamage\", function( target, dmg )","\t\tlocal lower = (\"EntityTakeDamage\"):lower()","\t\trun( lower, nil, target, dmg:GetAttacker(),","\t\t\tdmg:GetInflictor(),","\t\t\tdmg:GetDamage(),","\t\t\tdmg:GetDamageType(),","\t\t\tdmg:GetDamagePosition(),","\t\t\tdmg:GetDamageForce() )","\tend)","","else","\t-- Client hooks","\tadd( \"StartChat\" )","\tadd( \"FinishChat\" )","end","","-- Shared hooks","","-- Player hooks","add( \"PlayerHurt\" )","add( \"PlayerNoClip\" )","add( \"KeyPress\" )","add( \"KeyRelease\" )","add( \"GravGunPunt\" )","add( \"PhysgunPickup\" )","add( \"PhysgunDrop\" )","add( \"PlayerSwitchWeapon\", returnOnlyOnYourselfFalse )","","-- Entity hooks","add( \"OnEntityCreated\" )","add( \"EntityRemoved\" )","add( \"PropBreak\" )","","-- Other","add( \"EndEntityDriving\" )","add( \"StartEntityDriving\" )","add( \"Tick\" )",""],"class":"function","summary":"\nAdd a GMod hook so that SF gets access to it ","name":"SF.hookAdd","server":true,"private":false,"client":true,"description":"\nAdd a GMod hook so that SF gets access to it","param":{"1":"hookname","2":"customfunc","customfunc":"Optional custom function","hookname":"The hook name. In-SF hookname will be lowercased"}},{"description":"\nCalled when an entity is being picked up by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnPickedUp","summary":"\nCalled when an entity is being picked up by a gravity gun ","server":true,"comment":["--- Called when an entity is being picked up by a gravity gun","-- @name GravGunOnPickedUp","-- @class hook","-- @server","-- @param ply Player picking up an object","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up an object","ent":"Entity being picked up"}},{"description":"\nCalled when an entity is being dropped by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnDropped","summary":"\nCalled when an entity is being dropped by a gravity gun ","server":true,"comment":["--- Called when an entity is being dropped by a gravity gun","-- @name GravGunOnDropped","-- @class hook","-- @server","-- @param ply Player dropping the object","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player dropping the object","ent":"Entity being dropped"}},{"description":"\nCalled when an entity is being frozen","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunFreeze","summary":"\nCalled when an entity is being frozen ","server":true,"comment":["--- Called when an entity is being frozen","-- @name OnPhysgunFreeze","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param physobj PhysObj of the entity","-- @param ent Entity being frozen","-- @param ply Player freezing the entity"],"param":{"1":"physgun","2":"physobj","3":"ent","4":"ply","physobj":"PhysObj of the entity","ply":"Player freezing the entity","physgun":"Entity of the physgun","ent":"Entity being frozen"}},{"description":"\nCalled when a player reloads his physgun","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunReload","summary":"\nCalled when a player reloads his physgun ","server":true,"comment":["--- Called when a player reloads his physgun","-- @name OnPhysgunReload","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param ply Player reloading the physgun"],"param":{"1":"physgun","2":"ply","physgun":"Entity of the physgun","ply":"Player reloading the physgun"}},{"description":"\nCalled when a player dies","code":[""],"class":"hook","classForced":true,"name":"PlayerDeath","summary":"\nCalled when a player dies ","server":true,"comment":["--- Called when a player dies","-- @name PlayerDeath","-- @class hook","-- @server","-- @param ply Player who died","-- @param inflictor Entity used to kill the player","-- @param attacker Entity that killed the player"],"param":{"1":"ply","2":"inflictor","3":"attacker","inflictor":"Entity used to kill the player","ply":"Player who died","attacker":"Entity that killed the player"}},{"description":"\nCalled when a player disconnects","code":[""],"class":"hook","classForced":true,"name":"PlayerDisconnected","summary":"\nCalled when a player disconnects ","server":true,"comment":["--- Called when a player disconnects","-- @name PlayerDisconnected","-- @class hook","-- @server","-- @param ply Player that disconnected"],"param":{"1":"ply","ply":"Player that disconnected"}},{"description":"\nCalled when a player spawns for the first time","code":[""],"class":"hook","classForced":true,"name":"PlayerInitialSpawn","summary":"\nCalled when a player spawns for the first time ","server":true,"comment":["--- Called when a player spawns for the first time","-- @name PlayerInitialSpawn","-- @class hook","-- @server","-- @param ply Player who spawned"],"param":{"1":"ply","ply":"Player who spawned"}},{"description":"\nCalled when a player spawns","code":[""],"class":"hook","classForced":true,"name":"PlayerSpawn","summary":"\nCalled when a player spawns ","server":true,"comment":["--- Called when a player spawns","-- @name PlayerSpawn","-- @class hook","-- @server","-- @param ply Player who spawned"],"param":{"1":"ply","ply":"Player who spawned"}},{"description":"\nCalled when a players enters a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerEnteredVehicle","summary":"\nCalled when a players enters a vehicle ","server":true,"comment":["--- Called when a players enters a vehicle","-- @name PlayerEnteredVehicle","-- @class hook","-- @server","-- @param ply Player who entered a vehicle","-- @param vehicle Vehicle that was entered","-- @param num Role"],"param":{"1":"ply","2":"vehicle","3":"num","vehicle":"Vehicle that was entered","ply":"Player who entered a vehicle","num":"Role"}},{"description":"\nCalled when a players leaves a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerLeaveVehicle","summary":"\nCalled when a players leaves a vehicle ","server":true,"comment":["--- Called when a players leaves a vehicle","-- @name PlayerLeaveVehicle","-- @class hook","-- @server","-- @param ply Player who left a vehicle","-- @param vehicle Vehicle that was left"],"param":{"1":"ply","2":"vehicle","ply":"Player who left a vehicle","vehicle":"Vehicle that was left"}},{"ret":"New text. \"\" to stop from displaying. Nil to keep original.","description":"\nCalled when a player sends a chat message","code":[""],"class":"hook","classForced":true,"name":"PlayerSay","summary":"\nCalled when a player sends a chat message ","server":true,"comment":["--- Called when a player sends a chat message","-- @name PlayerSay","-- @class hook","-- @server","-- @param ply Player that sent the message","-- @param text Content of the message","-- @param teamChat True if team chat","-- @return New text. \"\" to stop from displaying. Nil to keep original."],"param":{"1":"ply","2":"text","3":"teamChat","text":"Content of the message","ply":"Player that sent the message","teamChat":"True if team chat"}},{"description":"\nCalled when a players sprays his logo","code":[""],"class":"hook","classForced":true,"name":"PlayerSpray","summary":"\nCalled when a players sprays his logo ","server":true,"comment":["--- Called when a players sprays his logo","-- @name PlayerSpray","-- @class hook","-- @server","-- @param ply Player that sprayed"],"param":{"1":"ply","ply":"Player that sprayed"}},{"description":"\nCalled when a player holds their use key and looks at an entity. \nWill continuously run.","code":[""],"class":"hook","classForced":true,"name":"PlayerUse","summary":"\nCalled when a player holds their use key and looks at an entity.","param":{"1":"ply","2":"ent","ply":"Player using the entity","ent":"Entity being used"},"comment":["--- Called when a player holds their use key and looks at an entity.","-- Will continuously run.","-- @name PlayerUse","-- @server","-- @class hook","-- @param ply Player using the entity","-- @param ent Entity being used"],"server":true},{"description":"\nCalled when a players turns their flashlight on or off","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchFlashlight","summary":"\nCalled when a players turns their flashlight on or off ","server":true,"comment":["--- Called when a players turns their flashlight on or off","-- @name PlayerSwitchFlashlight","-- @class hook","-- @server","-- @param ply Player switching flashlight","-- @param state New flashlight state. True if on."],"param":{"1":"ply","2":"state","ply":"Player switching flashlight","state":"New flashlight state. True if on."}},{"description":"\nCalled when a wants to pick up a weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerCanPickupWeapon","summary":"\nCalled when a wants to pick up a weapon ","server":true,"comment":["--- Called when a wants to pick up a weapon","-- @name PlayerCanPickupWeapon","-- @class hook","-- @server","-- @param ply Player","-- @param wep Weapon"],"param":{"1":"ply","2":"wep","ply":"Player","wep":"Weapon"}},{"description":"\nCalled when a player gets hurt","code":[""],"class":"hook","classForced":true,"name":"PlayerHurt","summary":"\nCalled when a player gets hurt ","server":true,"client":true,"comment":["--- Called when a player gets hurt","-- @name PlayerHurt","-- @class hook","-- @shared","-- @param ply Player being hurt","-- @param attacker Entity causing damage to the player","-- @param newHealth New health of the player","-- @param damageTaken Amount of damage the player has taken"],"param":{"1":"ply","2":"attacker","3":"newHealth","4":"damageTaken","damageTaken":"Amount of damage the player has taken","attacker":"Entity causing damage to the player","ply":"Player being hurt","newHealth":"New health of the player"}},{"description":"\nCalled when a player toggles noclip","code":[""],"class":"hook","classForced":true,"name":"PlayerNoClip","summary":"\nCalled when a player toggles noclip ","server":true,"client":true,"comment":["--- Called when a player toggles noclip","-- @name PlayerNoClip","-- @class hook","-- @shared","-- @param ply Player toggling noclip","-- @param newState New noclip state. True if on."],"param":{"1":"ply","2":"newState","ply":"Player toggling noclip","newState":"New noclip state. True if on."}},{"description":"\nCalled when a player presses a key","code":[""],"class":"hook","classForced":true,"name":"KeyPress","summary":"\nCalled when a player presses a key ","server":true,"client":true,"comment":["--- Called when a player presses a key","-- @name KeyPress","-- @class hook","-- @shared","-- @param ply Player pressing the key","-- @param key The key being pressed"],"param":{"1":"ply","2":"key","ply":"Player pressing the key","key":"The key being pressed"}},{"description":"\nCalled when a player releases a key","code":[""],"class":"hook","classForced":true,"name":"KeyRelease","summary":"\nCalled when a player releases a key ","server":true,"client":true,"comment":["--- Called when a player releases a key","-- @name KeyRelease","-- @class hook","-- @shared","-- @param ply Player releasing the key","-- @param key The key being released"],"param":{"1":"ply","2":"key","ply":"Player releasing the key","key":"The key being released"}},{"description":"\nCalled when a player punts with the gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunPunt","summary":"\nCalled when a player punts with the gravity gun ","server":true,"client":true,"comment":["--- Called when a player punts with the gravity gun","-- @name GravGunPunt","-- @class hook","-- @shared","-- @param ply Player punting the gravgun","-- @param ent Entity being punted"],"param":{"1":"ply","2":"ent","ply":"Player punting the gravgun","ent":"Entity being punted"}},{"description":"\nCalled when an entity gets picked up by a physgun","code":[""],"class":"hook","classForced":true,"name":"PhysgunPickup","summary":"\nCalled when an entity gets picked up by a physgun ","server":true,"client":true,"comment":["--- Called when an entity gets picked up by a physgun","-- @name PhysgunPickup","-- @class hook","-- @shared","-- @param ply Player picking up the entity","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up the entity","ent":"Entity being picked up"}},{"description":"\nCalled when an entity being held by a physgun gets dropped","code":[""],"class":"hook","classForced":true,"name":"PhysgunDrop","summary":"\nCalled when an entity being held by a physgun gets dropped ","server":true,"client":true,"comment":["--- Called when an entity being held by a physgun gets dropped","-- @name PhysgunDrop","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player droppig the entity","ent":"Entity being dropped"}},{"description":"\nCalled when a player switches their weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchWeapon","summary":"\nCalled when a player switches their weapon ","server":true,"client":true,"comment":["--- Called when a player switches their weapon","-- @name PlayerSwitchWeapon","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param oldwep Old weapon","-- @param newweapon New weapon"],"param":{"1":"ply","2":"oldwep","3":"newweapon","oldwep":"Old weapon","ply":"Player droppig the entity","newweapon":"New weapon"}},{"description":"\nCalled when an entity gets created","code":[""],"class":"hook","classForced":true,"name":"OnEntityCreated","summary":"\nCalled when an entity gets created ","server":true,"client":true,"comment":["--- Called when an entity gets created","-- @name OnEntityCreated","-- @class hook","-- @shared","-- @param ent New entity"],"param":{"1":"ent","ent":"New entity"}},{"description":"\nCalled when an entity is removed","code":[""],"class":"hook","classForced":true,"name":"EntityRemoved","summary":"\nCalled when an entity is removed ","server":true,"client":true,"comment":["--- Called when an entity is removed","-- @name EntityRemoved","-- @class hook","-- @shared","-- @param ent Entity being removed"],"param":{"1":"ent","ent":"Entity being removed"}},{"description":"\nCalled when an entity is broken","code":[""],"class":"hook","classForced":true,"name":"PropBreak","summary":"\nCalled when an entity is broken ","server":true,"client":true,"comment":["--- Called when an entity is broken","-- @name PropBreak","-- @class hook","-- @shared","-- @param ply Player who broke it","-- @param ent Entity broken"],"param":{"1":"ply","2":"ent","ply":"Player who broke it","ent":"Entity broken"}},{"description":"\nCalled when an entity is damaged","code":[""],"class":"hook","classForced":true,"name":"EntityTakeDamage","summary":"\nCalled when an entity is damaged ","server":true,"comment":["--- Called when an entity is damaged","-- @name EntityTakeDamage","-- @class hook","-- @server","-- @param target Entity that is hurt","-- @param attacker Entity that attacked","-- @param inflictor Entity that inflicted the damage","-- @param amount How much damage","-- @param type Type of the damage","-- @param position Position of the damage","-- @param force Force of the damage"],"param":{"1":"target","2":"attacker","3":"inflictor","4":"amount","5":"type","6":"position","7":"force","inflictor":"Entity that inflicted the damage","position":"Position of the damage","amount":"How much damage","target":"Entity that is hurt","force":"Force of the damage","attacker":"Entity that attacked","type":"Type of the damage"}},{"description":"\nCalled when a player stops driving an entity","code":[""],"class":"hook","classForced":true,"name":"EndEntityDriving","summary":"\nCalled when a player stops driving an entity ","server":true,"client":true,"comment":["--- Called when a player stops driving an entity","-- @name EndEntityDriving","-- @class hook","-- @shared","-- @param ent Entity that had been driven","-- @param ply Player that drove the entity"],"param":{"1":"ent","2":"ply","ent":"Entity that had been driven","ply":"Player that drove the entity"}},{"description":"\nCalled when a player starts driving an entity","code":[""],"class":"hook","classForced":true,"name":"StartEntityDriving","summary":"\nCalled when a player starts driving an entity ","server":true,"client":true,"comment":["--- Called when a player starts driving an entity","-- @name StartEntityDriving","-- @class hook","-- @shared","-- @param ent Entity being driven","-- @param ply Player that is driving the entity"],"param":{"1":"ent","2":"ply","ent":"Entity being driven","ply":"Player that is driving the entity"}},{"description":"\nThink hook. Called each frame on the client and each game tick on the server.","code":[""],"class":"hook","classForced":true,"name":"think","summary":"\nThink hook.","server":true,"client":true,"comment":["--- Think hook. Called each frame on the client and each game tick on the server.","-- @name think","-- @class hook","-- @shared"],"param":[]},{"description":"\nTick hook. Called each game tick on both the server and client.","code":[""],"class":"hook","classForced":true,"name":"tick","summary":"\nTick hook.","server":true,"client":true,"comment":["--- Tick hook. Called each game tick on both the server and client.","-- @name tick","-- @class hook","-- @shared"],"param":[]},{"description":"\nCalled when the starfall chip is removed","code":[""],"class":"hook","classForced":true,"name":"Removed","summary":"\nCalled when the starfall chip is removed ","server":true,"comment":["--- Called when the starfall chip is removed","-- @name Removed","-- @class hook","-- @server"],"param":[]},{"description":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","code":[""],"class":"hook","classForced":true,"name":"Initialize","summary":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","server":true,"comment":["--- Called after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","-- @name Initialize","-- @class hook","-- @server"],"param":[]},{"description":"\nCalled when the local player opens their chat window.","code":[""],"class":"hook","classForced":true,"name":"StartChat","summary":"\nCalled when the local player opens their chat window.","client":true,"comment":["--- Called when the local player opens their chat window.","-- @name StartChat","-- @class hook","-- @client"],"param":[]},{"description":"\nCalled when the local player closes their chat window.","code":[],"class":"hook","classForced":true,"name":"FinishChat","summary":"\nCalled when the local player closes their chat window.","client":true,"comment":["--- Called when the local player closes their chat window.","-- @name FinishChat","-- @class hook","-- @client"],"param":[]}],"tables":[],"description":"\n \nHook library \n","summary":"\n \nHook library \n "},"libs_sh/builtins.lua":{"libraries":{"1":"builtin","builtin":{"description":"\nBuilt in values. These don't need to be loaded; they are in the default environment.","code":["","-- ------------------------- Lua Ports ------------------------- --","-- This part is messy because of LuaDoc stuff.","","local function pascalToCamel ( t, r )","\tlocal r = r or {}","\tfor k, v in pairs( t ) do","\t\tk = k:gsub( \"^%l\", string.lower )","\t\tr[ k ] = v","\tend","\treturn r","end",""],"summary":"\nBuilt in values.","class":"library","tables":{"1":"IN_KEY","2":"KEY","3":"MOUSE","4":"bit","5":"math","6":"os","7":"string","8":"table","IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown:","-- ALT1,","-- ALT2,","-- ATTACK,","-- ATTACK2,","-- BACK,","-- DUCK,","-- FORWARD,","-- JUMP,","-- LEFT,","-- MOVELEFT,","-- MOVERIGHT,","-- RELOAD,","-- RIGHT,","-- SCORE,","-- SPEED,","-- USE,","-- WALK,","-- ZOOM,","-- GRENADE1,","-- GRENADE2,","-- WEAPON1,","-- WEAPON2,","-- BULLRUSH,","-- CANCEL,","-- RUN","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"string":{"description":"\nString library http://wiki.garrysmod.com/page/Category:string","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nString library http://wiki.garrysmod.com/page/Category:string ","library":"builtin","comment":["--- String library http://wiki.garrysmod.com/page/Category:string","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"os":{"description":"\nThe os library. http://wiki.garrysmod.com/page/Category:os","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nThe os library.","library":"builtin","comment":["--- The os library. http://wiki.garrysmod.com/page/Category:os","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"table":{"description":"\nTable library. http://wiki.garrysmod.com/page/Category:table","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","local bit_methods, bit_metatable = SF.Typedef(\"Library: bit\")","filterGmodLua(bit,bit_methods)","bit_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nTable library.","library":"builtin","comment":["--- Table library. http://wiki.garrysmod.com/page/Category:table","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"math":{"description":"\nThe math library. http://wiki.garrysmod.com/page/Category:math","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nThe math library.","library":"builtin","comment":["--- The math library. http://wiki.garrysmod.com/page/Category:math","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"bit":{"description":"\nBit library. http://wiki.garrysmod.com/page/Category:bit","code":["SF.DefaultEnvironment.bit = setmetatable({},bit_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.bit","summary":"\nBit library.","library":"builtin","comment":["--- Bit library. http://wiki.garrysmod.com/page/Category:bit","-- @name SF.DefaultEnvironment.bit","-- @class table"],"param":[]},"MOUSE":{"description":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library:","-- MOUSE1,","-- LEFT,","-- MOUSE2,","-- RIGHT,","-- MOUSE3,","-- MIDDLE,","-- MOUSE4,","-- 4,","-- MOUSE5,","-- 5,","-- MWHEELUP,","-- WHEEL_UP,","-- MWHEELDOWN,","-- WHEEL_DOWN,","-- COUNT,","-- FIRST,","-- LAST","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"KEY":{"description":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library:","-- FIRST,","-- NONE,","-- 0,","-- 1,","-- 2,","-- 3,","-- 4,","-- 5,","-- 6,","-- 7,","-- 8,","-- 9,","-- A,","-- B,","-- C,","-- D,","-- E,","-- F,","-- G,","-- H,","-- I,","-- J,","-- K,","-- L,","-- M,","-- N,","-- O,","-- P,","-- Q,","-- R,","-- S,","-- T,","-- U,","-- V,","-- W,","-- X,","-- Y,","-- Z,","-- KP_INS,","-- PAD_0,","-- KP_END,","-- PAD_1,","-- KP_DOWNARROW ,","-- PAD_2,","-- KP_PGDN,","-- PAD_3,","-- KP_LEFTARROW,","-- PAD_4,","-- KP_5 ,","-- PAD_5,","-- KP_RIGHTARROW,","-- PAD_6,","-- KP_HOME,","-- PAD_7,","-- KP_UPARROW,","-- PAD_8,","-- KP_PGUP,","-- PAD_9,","-- PAD_DIVIDE,","-- KP_SLASH,","-- KP_MULTIPLY,","-- PAD_MULTIPLY,","-- KP_MINUS,","-- PAD_MINUS,","-- KP_PLUS,","-- PAD_PLUS,","-- KP_ENTER,","-- PAD_ENTER,","-- KP_DEL,","-- PAD_DECIMAL,","-- LBRACKET,","-- RBRACKET,","-- SEMICOLON,","-- APOSTROPHE,","-- BACKQUOTE,","-- COMMA,","-- PERIOD,","-- SLASH,","-- BACKSLASH,","-- MINUS,","-- EQUAL,","-- ENTER,","-- SPACE,","-- BACKSPACE,","-- TAB,","-- CAPSLOCK,","-- NUMLOCK,","-- ESCAPE,","-- SCROLLLOCK,","-- INS,","-- INSERT,","-- DEL,","-- DELETE,","-- HOME,","-- END,","-- PGUP,","-- PAGEUP,","-- PGDN,","-- PAGEDOWN,","-- PAUSE,","-- BREAK,","-- SHIFT,","-- LSHIFT,","-- RSHIFT,","-- ALT,","-- LALT,","-- RALT,","-- CTRL,","-- LCONTROL,","-- RCTRL,","-- RCONTROL,","-- LWIN,","-- RWIN,","-- APP,","-- UPARROW,","-- UP,","-- LEFTARROW,","-- LEFT,","-- DOWNARROW,","-- DOWN,","-- RIGHTARROW,","-- RIGHT,","-- F1,","-- F2,","-- F3,","-- F4,","-- F5,","-- F6,","-- F7,","-- F8,","-- F9,","-- F10,","-- F11,","-- F12,","-- CAPSLOCKTOGGLE,","-- NUMLOCKTOGGLE,","-- SCROLLLOCKTOGGLE,","-- LAST,","-- COUNT","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]}},"functions":{"1":"assert","2":"chip","3":"concmd","4":"dodir","5":"dofile","6":"entity","7":"error","8":"getLibraries","9":"getfenv","10":"getmetatable","11":"ipairs","12":"isValid","13":"loadstring","14":"next","15":"owner","16":"pairs","17":"player","18":"printMesssage","19":"printTable","20":"quotaAverage","21":"quotaMax","22":"quotaUsed","23":"require","24":"requiredir","25":"setClipboardText","26":"setName","27":"setSoftQuota","28":"setfenv","29":"setmetatable","30":"throw","31":"tonumber","32":"tostring","33":"try","34":"type","35":"unpack","chip":{"ret":"Starfall entity","description":"\nReturns the entity representing a processor that this script is running on.","code":["SF.DefaultEnvironment.chip = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.chip","summary":"\nReturns the entity representing a processor that this script is running on.","library":"builtin","comment":["--- Returns the entity representing a processor that this script is running on.","-- @name SF.DefaultEnvironment.chip","-- @class function","-- @return Starfall entity"],"param":[]},"tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"setClipboardText":{"comment":["\t--- Sets clipboard text. Only works on the owner of the chip.","\t-- @param txt Text to set to the clipboard"],"code":["\tfunction SF.DefaultEnvironment.setClipboardText( txt )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( txt, \"string\" )","\t\tSetClipboardText( txt )","\tend","\t"],"class":"function","name":"SF.DefaultEnvironment.setClipboardText","summary":"\nSets clipboard text.","private":false,"library":"builtin","description":"\nSets clipboard text. Only works on the owner of the chip.","param":{"1":"txt","txt":"Text to set to the clipboard"}},"unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"isValid":{"ret":"If it is valid","comment":["--- Returns if the table has an isValid function and isValid returns true.","--@param object Table to check","--@return If it is valid"],"code":["function SF.DefaultEnvironment.isValid( object )","","\tif ( !object ) then return false end","\tif ( !object.isValid ) then return false end","","\treturn object:isValid()","","end","","local _KEY = {","\t[ \"FIRST\" ] = 0,","\t[ \"NONE\" ] = 0,","\t[ \"0\" ] = 1,","\t[ \"1\" ] = 2,","\t[ \"2\" ] = 3,","\t[ \"3\" ] = 4,","\t[ \"4\" ] = 5,","\t[ \"5\" ] = 6,","\t[ \"6\" ] = 7,","\t[ \"7\" ] = 8,","\t[ \"8\" ] = 9,","\t[ \"9\" ] = 10,","\t[ \"A\" ] = 11,","\t[ \"B\" ] = 12,","\t[ \"C\" ] = 13,","\t[ \"D\" ] = 14,","\t[ \"E\" ] = 15,","\t[ \"F\" ] = 16,","\t[ \"G\" ] = 17,","\t[ \"H\" ] = 18,","\t[ \"I\" ] = 19,","\t[ \"J\" ] = 20,","\t[ \"K\" ] = 21,","\t[ \"L\" ] = 22,","\t[ \"M\" ] = 23,","\t[ \"N\" ] = 24,","\t[ \"O\" ] = 25,","\t[ \"P\" ] = 26,","\t[ \"Q\" ] = 27,","\t[ \"R\" ] = 28,","\t[ \"S\" ] = 29,","\t[ \"T\" ] = 30,","\t[ \"U\" ] = 31,","\t[ \"V\" ] = 32,","\t[ \"W\" ] = 33,","\t[ \"X\" ] = 34,","\t[ \"Y\" ] = 35,","\t[ \"Z\" ] = 36,","\t[ \"KP_INS\" ] = 37,","\t[ \"PAD_0\" ] = 37,","\t[ \"KP_END\" ] = 38,","\t[ \"PAD_1\" ] = 38,","\t[ \"KP_DOWNARROW \" ] = 39,","\t[ \"PAD_2\" ] = 39,","\t[ \"KP_PGDN\" ] = 40,","\t[ \"PAD_3\" ] = 40,","\t[ \"KP_LEFTARROW\" ] = 41,","\t[ \"PAD_4\" ] = 41,","\t[ \"KP_5 \" ] = 42,","\t[ \"PAD_5\" ] = 42,","\t[ \"KP_RIGHTARROW\" ] = 43,","\t[ \"PAD_6\" ] = 43,","\t[ \"KP_HOME\" ] = 44,","\t[ \"PAD_7\" ] = 44,","\t[ \"KP_UPARROW\" ] = 45,","\t[ \"PAD_8\" ] = 45,","\t[ \"KP_PGUP\" ] = 46,","\t[ \"PAD_9\" ] = 46,","\t[ \"PAD_DIVIDE\" ] = 47,","\t[ \"KP_SLASH\" ] = 47,","\t[ \"KP_MULTIPLY\" ] = 48,","\t[ \"PAD_MULTIPLY\" ] = 48,","\t[ \"KP_MINUS\" ] = 49,","\t[ \"PAD_MINUS\" ] = 49,","\t[ \"KP_PLUS\" ] = 50,","\t[ \"PAD_PLUS\" ] = 50,","\t[ \"KP_ENTER\" ] = 51,","\t[ \"PAD_ENTER\" ] = 51,","\t[ \"KP_DEL\" ] = 52,","\t[ \"PAD_DECIMAL\" ] = 52,","\t[ \"[\" ] = 53,","\t[ \"LBRACKET\" ] = 53,","\t[ \"]\" ] = 54,","\t[ \"RBRACKET\" ] = 54,","\t[ \"SEMICOLON\" ] = 55,","\t[ \"'\" ] = 56,","\t[ \"APOSTROPHE\" ] = 56,","\t[ \"`\" ] = 57,","\t[ \"BACKQUOTE\" ] = 57,","\t[ \",\" ] = 58,","\t[ \"COMMA\" ] = 58,","\t[ \".\" ] = 59,","\t[ \"PERIOD\" ] = 59,","\t[ \"/\" ] = 60,","\t[ \"SLASH\" ] = 60,","\t[ \"\\\\\" ] = 61,","\t[ \"BACKSLASH\" ] = 61,","\t[ \"-\" ] = 62,","\t[ \"MINUS\" ] = 62,","\t[ \"=\" ] = 63,","\t[ \"EQUAL\" ] = 63,","\t[ \"ENTER\" ] = 64,","\t[ \"SPACE\" ] = 65,","\t[ \"BACKSPACE\" ] = 66,","\t[ \"TAB\" ] = 67,","\t[ \"CAPSLOCK\" ] = 68,","\t[ \"NUMLOCK\" ] = 69,","\t[ \"ESCAPE\" ] = 70,","\t[ \"SCROLLLOCK\" ] = 71,","\t[ \"INS\" ] = 72,","\t[ \"INSERT\" ] = 72,","\t[ \"DEL\" ] = 73,","\t[ \"DELETE\" ] = 73,","\t[ \"HOME\" ] = 74,","\t[ \"END\" ] = 75,","\t[ \"PGUP\" ] = 76,","\t[ \"PAGEUP\" ] = 76,","\t[ \"PGDN\" ] = 77,","\t[ \"PAGEDOWN\" ] = 77,","\t[ \"PAUSE\" ] = 78,","\t[ \"BREAK\" ] = 78,","\t[ \"SHIFT\" ] = 79,","\t[ \"LSHIFT\" ] = 79,","\t[ \"RSHIFT\" ] = 80,","\t[ \"ALT\" ] = 81,","\t[ \"LALT\" ] = 81,","\t[ \"RALT\" ] = 82,","\t[ \"CTRL\" ] = 83,","\t[ \"LCONTROL\" ] = 83,","\t[ \"RCTRL\" ] = 84,","\t[ \"RCONTROL\" ] = 84,","\t[ \"LWIN\" ] = 85,","\t[ \"RWIN\" ] = 86,","\t[ \"APP\" ] = 87,","\t[ \"UPARROW\" ] = 88,","\t[ \"UP\" ] = 88,","\t[ \"LEFTARROW\" ] = 89,","\t[ \"LEFT\" ] = 89,","\t[ \"DOWNARROW\" ] = 90,","\t[ \"DOWN\" ] = 90,","\t[ \"RIGHTARROW\" ] = 91,","\t[ \"RIGHT\" ] = 91,","\t[ \"F1\" ] = 92,","\t[ \"F2\" ] = 93,","\t[ \"F3\" ] = 94,","\t[ \"F4\" ] = 95,","\t[ \"F5\" ] = 96,","\t[ \"F6\" ] = 97,","\t[ \"F7\" ] = 98,","\t[ \"F8\" ] = 99,","\t[ \"F9\" ] = 100,","\t[ \"F10\" ] = 101,","\t[ \"F11\" ] = 102,","\t[ \"F12\" ] = 103,","\t[ \"CAPSLOCKTOGGLE\" ] = 104,","\t[ \"NUMLOCKTOGGLE\" ] = 105,","\t[ \"SCROLLLOCKTOGGLE\" ] = 106,","\t[ \"LAST\" ] = 106,","\t[ \"COUNT\" ] = 106","}",""],"class":"function","name":"SF.DefaultEnvironment.isValid","summary":"\nReturns if the table has an isValid function and isValid returns true.","private":false,"library":"builtin","description":"\nReturns if the table has an isValid function and isValid returns true.","param":{"1":"object","object":"Table to check"}},"pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as owner() on the server. On the client, returns the local player","code":["SF.DefaultEnvironment.player = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.player","summary":"\nSame as owner() on the server.","library":"builtin","comment":["--- Same as owner() on the server. On the client, returns the local player","-- @name SF.DefaultEnvironment.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]},"requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}},"getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if CLIENT then\t"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},"dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"entity":{"ret":"entity","description":"\nReturns the entity with index 'num'","code":["SF.DefaultEnvironment.entity = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.entity","summary":"\nReturns the entity with index 'num' ","library":"builtin","comment":["--- Returns the entity with index 'num'","-- @name SF.DefaultEnvironment.entity","-- @class function","-- @param num Entity index","-- @return entity"],"param":{"1":"num","num":"Entity index"}},"type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"printMesssage":{"comment":["\t--- Prints a message to your chat, console, or the center of your screen.","\t-- @param mtype How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","\t-- @param text The message text."],"code":["\tfunction SF.DefaultEnvironment.printMesssage( mtype, text )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( text, \"string\" )","\t\tSF.instance.player:PrintMessage( mtype, text )","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end","","-- Prints a message to the player's chat.","-- @shared","-- @param ... Values to print","function SF.DefaultEnvironment.print(...)","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tlocal str = \"\"","\tlocal tbl = {n=select('#', ...), ...}","\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t( SERVER and SF.instance.player or LocalPlayer() ):ChatPrint(str)","end",""],"class":"function","name":"SF.DefaultEnvironment.printMesssage","summary":"\nPrints a message to your chat, console, or the center of your screen.","private":false,"library":"builtin","description":"\nPrints a message to your chat, console, or the center of your screen.","param":{"1":"mtype","2":"text","mtype":"How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","text":"The message text."}},"printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"owner":{"ret":"Owner entity","description":"\nReturns whoever created the chip","code":["SF.DefaultEnvironment.owner = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.owner","summary":"\nReturns whoever created the chip ","library":"builtin","comment":["--- Returns whoever created the chip","-- @name SF.DefaultEnvironment.owner","-- @class function","-- @return Owner entity"],"param":[]},"getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\tlocal fenv = getfenv(2)","\tif fenv ~= _G then return fenv end","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" or getfenv( func ) == _G then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"setName":{"comment":["\t--- Sets the chip's display name","\t-- @client","\t-- @param name Name"],"code":["\tfunction SF.DefaultEnvironment.setName( name )","\t\tSF.CheckType( name, \"string\" )","\t\tlocal e = SF.instance.data.entity","\t\tif IsValid( e ) then","\t\t\te.name = name","\t\tend","\tend","\t"],"class":"function","summary":"\nSets the chip's display name ","name":"SF.DefaultEnvironment.setName","library":"builtin","private":false,"client":true,"description":"\nSets the chip's display name","param":{"1":"name","name":"Name"}},"dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"setSoftQuota":{"comment":["--- Sets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","-- @param quota The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50% "],"code":["function SF.DefaultEnvironment.setSoftQuota ( quota )","\tSF.CheckType( quota, \"number\" )","\tself.cpu_softquota = quota","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original)","\tfor name, func in pairs(lib) do","\t\tif not type(name)==\"string\" then continue end","\t\tname = name:gsub(\"^[A-Z]\", string.lower)","\t\toriginal[name] = func","\tend","end","","-- String library","local string_methods, string_metatable = SF.Typedef(\"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.setSoftQuota","summary":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","private":false,"library":"builtin","description":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","param":{"1":"quota","quota":"The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50%"}}},"classForced":true,"fields":{"1":"CLIENT","2":"SERVER","CLIENT":{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},"SERVER":{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]}},"name":"builtin","libtbl":"SF.DefaultEnvironment","server":true,"client":true,"comment":["--- Built in values. These don't need to be loaded; they are in the default environment.","-- @name builtin","-- @shared","-- @class library","-- @libtbl SF.DefaultEnvironment"],"param":[]}},"type":"file","name":"libs_sh/builtins.lua","functions":{"1":"SF.DefaultEnvironment.assert","2":"SF.DefaultEnvironment.chip","3":"SF.DefaultEnvironment.concmd","4":"SF.DefaultEnvironment.dodir","5":"SF.DefaultEnvironment.dofile","6":"SF.DefaultEnvironment.entity","7":"SF.DefaultEnvironment.error","8":"SF.DefaultEnvironment.getLibraries","9":"SF.DefaultEnvironment.getfenv","10":"SF.DefaultEnvironment.getmetatable","11":"SF.DefaultEnvironment.ipairs","12":"SF.DefaultEnvironment.isValid","13":"SF.DefaultEnvironment.loadstring","14":"SF.DefaultEnvironment.next","15":"SF.DefaultEnvironment.owner","16":"SF.DefaultEnvironment.pairs","17":"SF.DefaultEnvironment.player","18":"SF.DefaultEnvironment.printMesssage","19":"SF.DefaultEnvironment.printTable","20":"SF.DefaultEnvironment.quotaAverage","21":"SF.DefaultEnvironment.quotaMax","22":"SF.DefaultEnvironment.quotaUsed","23":"SF.DefaultEnvironment.require","24":"SF.DefaultEnvironment.requiredir","25":"SF.DefaultEnvironment.setClipboardText","26":"SF.DefaultEnvironment.setName","27":"SF.DefaultEnvironment.setSoftQuota","28":"SF.DefaultEnvironment.setfenv","29":"SF.DefaultEnvironment.setmetatable","30":"SF.DefaultEnvironment.throw","31":"SF.DefaultEnvironment.tonumber","32":"SF.DefaultEnvironment.tostring","33":"SF.DefaultEnvironment.try","34":"SF.DefaultEnvironment.type","35":"SF.DefaultEnvironment.unpack","SF.DefaultEnvironment.isValid":{"ret":"If it is valid","comment":["--- Returns if the table has an isValid function and isValid returns true.","--@param object Table to check","--@return If it is valid"],"code":["function SF.DefaultEnvironment.isValid( object )","","\tif ( !object ) then return false end","\tif ( !object.isValid ) then return false end","","\treturn object:isValid()","","end","","local _KEY = {","\t[ \"FIRST\" ] = 0,","\t[ \"NONE\" ] = 0,","\t[ \"0\" ] = 1,","\t[ \"1\" ] = 2,","\t[ \"2\" ] = 3,","\t[ \"3\" ] = 4,","\t[ \"4\" ] = 5,","\t[ \"5\" ] = 6,","\t[ \"6\" ] = 7,","\t[ \"7\" ] = 8,","\t[ \"8\" ] = 9,","\t[ \"9\" ] = 10,","\t[ \"A\" ] = 11,","\t[ \"B\" ] = 12,","\t[ \"C\" ] = 13,","\t[ \"D\" ] = 14,","\t[ \"E\" ] = 15,","\t[ \"F\" ] = 16,","\t[ \"G\" ] = 17,","\t[ \"H\" ] = 18,","\t[ \"I\" ] = 19,","\t[ \"J\" ] = 20,","\t[ \"K\" ] = 21,","\t[ \"L\" ] = 22,","\t[ \"M\" ] = 23,","\t[ \"N\" ] = 24,","\t[ \"O\" ] = 25,","\t[ \"P\" ] = 26,","\t[ \"Q\" ] = 27,","\t[ \"R\" ] = 28,","\t[ \"S\" ] = 29,","\t[ \"T\" ] = 30,","\t[ \"U\" ] = 31,","\t[ \"V\" ] = 32,","\t[ \"W\" ] = 33,","\t[ \"X\" ] = 34,","\t[ \"Y\" ] = 35,","\t[ \"Z\" ] = 36,","\t[ \"KP_INS\" ] = 37,","\t[ \"PAD_0\" ] = 37,","\t[ \"KP_END\" ] = 38,","\t[ \"PAD_1\" ] = 38,","\t[ \"KP_DOWNARROW \" ] = 39,","\t[ \"PAD_2\" ] = 39,","\t[ \"KP_PGDN\" ] = 40,","\t[ \"PAD_3\" ] = 40,","\t[ \"KP_LEFTARROW\" ] = 41,","\t[ \"PAD_4\" ] = 41,","\t[ \"KP_5 \" ] = 42,","\t[ \"PAD_5\" ] = 42,","\t[ \"KP_RIGHTARROW\" ] = 43,","\t[ \"PAD_6\" ] = 43,","\t[ \"KP_HOME\" ] = 44,","\t[ \"PAD_7\" ] = 44,","\t[ \"KP_UPARROW\" ] = 45,","\t[ \"PAD_8\" ] = 45,","\t[ \"KP_PGUP\" ] = 46,","\t[ \"PAD_9\" ] = 46,","\t[ \"PAD_DIVIDE\" ] = 47,","\t[ \"KP_SLASH\" ] = 47,","\t[ \"KP_MULTIPLY\" ] = 48,","\t[ \"PAD_MULTIPLY\" ] = 48,","\t[ \"KP_MINUS\" ] = 49,","\t[ \"PAD_MINUS\" ] = 49,","\t[ \"KP_PLUS\" ] = 50,","\t[ \"PAD_PLUS\" ] = 50,","\t[ \"KP_ENTER\" ] = 51,","\t[ \"PAD_ENTER\" ] = 51,","\t[ \"KP_DEL\" ] = 52,","\t[ \"PAD_DECIMAL\" ] = 52,","\t[ \"[\" ] = 53,","\t[ \"LBRACKET\" ] = 53,","\t[ \"]\" ] = 54,","\t[ \"RBRACKET\" ] = 54,","\t[ \"SEMICOLON\" ] = 55,","\t[ \"'\" ] = 56,","\t[ \"APOSTROPHE\" ] = 56,","\t[ \"`\" ] = 57,","\t[ \"BACKQUOTE\" ] = 57,","\t[ \",\" ] = 58,","\t[ \"COMMA\" ] = 58,","\t[ \".\" ] = 59,","\t[ \"PERIOD\" ] = 59,","\t[ \"/\" ] = 60,","\t[ \"SLASH\" ] = 60,","\t[ \"\\\\\" ] = 61,","\t[ \"BACKSLASH\" ] = 61,","\t[ \"-\" ] = 62,","\t[ \"MINUS\" ] = 62,","\t[ \"=\" ] = 63,","\t[ \"EQUAL\" ] = 63,","\t[ \"ENTER\" ] = 64,","\t[ \"SPACE\" ] = 65,","\t[ \"BACKSPACE\" ] = 66,","\t[ \"TAB\" ] = 67,","\t[ \"CAPSLOCK\" ] = 68,","\t[ \"NUMLOCK\" ] = 69,","\t[ \"ESCAPE\" ] = 70,","\t[ \"SCROLLLOCK\" ] = 71,","\t[ \"INS\" ] = 72,","\t[ \"INSERT\" ] = 72,","\t[ \"DEL\" ] = 73,","\t[ \"DELETE\" ] = 73,","\t[ \"HOME\" ] = 74,","\t[ \"END\" ] = 75,","\t[ \"PGUP\" ] = 76,","\t[ \"PAGEUP\" ] = 76,","\t[ \"PGDN\" ] = 77,","\t[ \"PAGEDOWN\" ] = 77,","\t[ \"PAUSE\" ] = 78,","\t[ \"BREAK\" ] = 78,","\t[ \"SHIFT\" ] = 79,","\t[ \"LSHIFT\" ] = 79,","\t[ \"RSHIFT\" ] = 80,","\t[ \"ALT\" ] = 81,","\t[ \"LALT\" ] = 81,","\t[ \"RALT\" ] = 82,","\t[ \"CTRL\" ] = 83,","\t[ \"LCONTROL\" ] = 83,","\t[ \"RCTRL\" ] = 84,","\t[ \"RCONTROL\" ] = 84,","\t[ \"LWIN\" ] = 85,","\t[ \"RWIN\" ] = 86,","\t[ \"APP\" ] = 87,","\t[ \"UPARROW\" ] = 88,","\t[ \"UP\" ] = 88,","\t[ \"LEFTARROW\" ] = 89,","\t[ \"LEFT\" ] = 89,","\t[ \"DOWNARROW\" ] = 90,","\t[ \"DOWN\" ] = 90,","\t[ \"RIGHTARROW\" ] = 91,","\t[ \"RIGHT\" ] = 91,","\t[ \"F1\" ] = 92,","\t[ \"F2\" ] = 93,","\t[ \"F3\" ] = 94,","\t[ \"F4\" ] = 95,","\t[ \"F5\" ] = 96,","\t[ \"F6\" ] = 97,","\t[ \"F7\" ] = 98,","\t[ \"F8\" ] = 99,","\t[ \"F9\" ] = 100,","\t[ \"F10\" ] = 101,","\t[ \"F11\" ] = 102,","\t[ \"F12\" ] = 103,","\t[ \"CAPSLOCKTOGGLE\" ] = 104,","\t[ \"NUMLOCKTOGGLE\" ] = 105,","\t[ \"SCROLLLOCKTOGGLE\" ] = 106,","\t[ \"LAST\" ] = 106,","\t[ \"COUNT\" ] = 106","}",""],"class":"function","name":"SF.DefaultEnvironment.isValid","summary":"\nReturns if the table has an isValid function and isValid returns true.","private":false,"library":"builtin","description":"\nReturns if the table has an isValid function and isValid returns true.","param":{"1":"object","object":"Table to check"}},"SF.DefaultEnvironment.loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"SF.DefaultEnvironment.player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as owner() on the server. On the client, returns the local player","code":["SF.DefaultEnvironment.player = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.player","summary":"\nSame as owner() on the server.","library":"builtin","comment":["--- Same as owner() on the server. On the client, returns the local player","-- @name SF.DefaultEnvironment.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]},"SF.DefaultEnvironment.setClipboardText":{"comment":["\t--- Sets clipboard text. Only works on the owner of the chip.","\t-- @param txt Text to set to the clipboard"],"code":["\tfunction SF.DefaultEnvironment.setClipboardText( txt )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( txt, \"string\" )","\t\tSetClipboardText( txt )","\tend","\t"],"class":"function","name":"SF.DefaultEnvironment.setClipboardText","summary":"\nSets clipboard text.","private":false,"library":"builtin","description":"\nSets clipboard text. Only works on the owner of the chip.","param":{"1":"txt","txt":"Text to set to the clipboard"}},"SF.DefaultEnvironment.pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"SF.DefaultEnvironment.entity":{"ret":"entity","description":"\nReturns the entity with index 'num'","code":["SF.DefaultEnvironment.entity = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.entity","summary":"\nReturns the entity with index 'num' ","library":"builtin","comment":["--- Returns the entity with index 'num'","-- @name SF.DefaultEnvironment.entity","-- @class function","-- @param num Entity index","-- @return entity"],"param":{"1":"num","num":"Entity index"}},"SF.DefaultEnvironment.concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}},"SF.DefaultEnvironment.try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"SF.DefaultEnvironment.getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\tlocal fenv = getfenv(2)","\tif fenv ~= _G then return fenv end","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"SF.DefaultEnvironment.unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"SF.DefaultEnvironment.tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"SF.DefaultEnvironment.setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" or getfenv( func ) == _G then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"SF.DefaultEnvironment.tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"SF.DefaultEnvironment.setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"SF.DefaultEnvironment.error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"SF.DefaultEnvironment.throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"SF.DefaultEnvironment.assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"SF.DefaultEnvironment.getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"SF.DefaultEnvironment.requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"SF.DefaultEnvironment.setSoftQuota":{"comment":["--- Sets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","-- @param quota The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50% "],"code":["function SF.DefaultEnvironment.setSoftQuota ( quota )","\tSF.CheckType( quota, \"number\" )","\tself.cpu_softquota = quota","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original)","\tfor name, func in pairs(lib) do","\t\tif not type(name)==\"string\" then continue end","\t\tname = name:gsub(\"^[A-Z]\", string.lower)","\t\toriginal[name] = func","\tend","end","","-- String library","local string_methods, string_metatable = SF.Typedef(\"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.setSoftQuota","summary":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","private":false,"library":"builtin","description":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","param":{"1":"quota","quota":"The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50%"}},"SF.DefaultEnvironment.quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"SF.DefaultEnvironment.printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"SF.DefaultEnvironment.dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"SF.DefaultEnvironment.chip":{"ret":"Starfall entity","description":"\nReturns the entity representing a processor that this script is running on.","code":["SF.DefaultEnvironment.chip = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.chip","summary":"\nReturns the entity representing a processor that this script is running on.","library":"builtin","comment":["--- Returns the entity representing a processor that this script is running on.","-- @name SF.DefaultEnvironment.chip","-- @class function","-- @return Starfall entity"],"param":[]},"SF.DefaultEnvironment.type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"SF.DefaultEnvironment.dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"SF.DefaultEnvironment.ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"SF.DefaultEnvironment.require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"SF.DefaultEnvironment.owner":{"ret":"Owner entity","description":"\nReturns whoever created the chip","code":["SF.DefaultEnvironment.owner = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.owner","summary":"\nReturns whoever created the chip ","library":"builtin","comment":["--- Returns whoever created the chip","-- @name SF.DefaultEnvironment.owner","-- @class function","-- @return Owner entity"],"param":[]},"SF.DefaultEnvironment.next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"SF.DefaultEnvironment.quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"SF.DefaultEnvironment.quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"SF.DefaultEnvironment.printMesssage":{"comment":["\t--- Prints a message to your chat, console, or the center of your screen.","\t-- @param mtype How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","\t-- @param text The message text."],"code":["\tfunction SF.DefaultEnvironment.printMesssage( mtype, text )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( text, \"string\" )","\t\tSF.instance.player:PrintMessage( mtype, text )","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end","","-- Prints a message to the player's chat.","-- @shared","-- @param ... Values to print","function SF.DefaultEnvironment.print(...)","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tlocal str = \"\"","\tlocal tbl = {n=select('#', ...), ...}","\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t( SERVER and SF.instance.player or LocalPlayer() ):ChatPrint(str)","end",""],"class":"function","name":"SF.DefaultEnvironment.printMesssage","summary":"\nPrints a message to your chat, console, or the center of your screen.","private":false,"library":"builtin","description":"\nPrints a message to your chat, console, or the center of your screen.","param":{"1":"mtype","2":"text","mtype":"How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","text":"The message text."}},"SF.DefaultEnvironment.setName":{"comment":["\t--- Sets the chip's display name","\t-- @client","\t-- @param name Name"],"code":["\tfunction SF.DefaultEnvironment.setName( name )","\t\tSF.CheckType( name, \"string\" )","\t\tlocal e = SF.instance.data.entity","\t\tif IsValid( e ) then","\t\t\te.name = name","\t\tend","\tend","\t"],"class":"function","summary":"\nSets the chip's display name ","name":"SF.DefaultEnvironment.setName","library":"builtin","private":false,"client":true,"description":"\nSets the chip's display name","param":{"1":"name","name":"Name"}},"SF.DefaultEnvironment.getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if CLIENT then\t"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]}},"doc":[{"summary":"\n \nBuiltins.","description":"\n \nBuiltins. \nFunctions built-in to the default environment \n","comment":["-------------------------------------------------------------------------------","-- Builtins.","-- Functions built-in to the default environment","-------------------------------------------------------------------------------"],"code":["","local dgetmeta = debug.getmetatable",""]},{"description":"\nBuilt in values. These don't need to be loaded; they are in the default environment.","code":["","-- ------------------------- Lua Ports ------------------------- --","-- This part is messy because of LuaDoc stuff.","","local function pascalToCamel ( t, r )","\tlocal r = r or {}","\tfor k, v in pairs( t ) do","\t\tk = k:gsub( \"^%l\", string.lower )","\t\tr[ k ] = v","\tend","\treturn r","end",""],"summary":"\nBuilt in values.","class":"library","tables":{"1":"IN_KEY","2":"KEY","3":"MOUSE","4":"bit","5":"math","6":"os","7":"string","8":"table","IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown:","-- ALT1,","-- ALT2,","-- ATTACK,","-- ATTACK2,","-- BACK,","-- DUCK,","-- FORWARD,","-- JUMP,","-- LEFT,","-- MOVELEFT,","-- MOVERIGHT,","-- RELOAD,","-- RIGHT,","-- SCORE,","-- SPEED,","-- USE,","-- WALK,","-- ZOOM,","-- GRENADE1,","-- GRENADE2,","-- WEAPON1,","-- WEAPON2,","-- BULLRUSH,","-- CANCEL,","-- RUN","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"string":{"description":"\nString library http://wiki.garrysmod.com/page/Category:string","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nString library http://wiki.garrysmod.com/page/Category:string ","library":"builtin","comment":["--- String library http://wiki.garrysmod.com/page/Category:string","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"os":{"description":"\nThe os library. http://wiki.garrysmod.com/page/Category:os","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nThe os library.","library":"builtin","comment":["--- The os library. http://wiki.garrysmod.com/page/Category:os","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"table":{"description":"\nTable library. http://wiki.garrysmod.com/page/Category:table","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","local bit_methods, bit_metatable = SF.Typedef(\"Library: bit\")","filterGmodLua(bit,bit_methods)","bit_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nTable library.","library":"builtin","comment":["--- Table library. http://wiki.garrysmod.com/page/Category:table","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"math":{"description":"\nThe math library. http://wiki.garrysmod.com/page/Category:math","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nThe math library.","library":"builtin","comment":["--- The math library. http://wiki.garrysmod.com/page/Category:math","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"bit":{"description":"\nBit library. http://wiki.garrysmod.com/page/Category:bit","code":["SF.DefaultEnvironment.bit = setmetatable({},bit_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.bit","summary":"\nBit library.","library":"builtin","comment":["--- Bit library. http://wiki.garrysmod.com/page/Category:bit","-- @name SF.DefaultEnvironment.bit","-- @class table"],"param":[]},"MOUSE":{"description":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library:","-- MOUSE1,","-- LEFT,","-- MOUSE2,","-- RIGHT,","-- MOUSE3,","-- MIDDLE,","-- MOUSE4,","-- 4,","-- MOUSE5,","-- 5,","-- MWHEELUP,","-- WHEEL_UP,","-- MWHEELDOWN,","-- WHEEL_DOWN,","-- COUNT,","-- FIRST,","-- LAST","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"KEY":{"description":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library:","-- FIRST,","-- NONE,","-- 0,","-- 1,","-- 2,","-- 3,","-- 4,","-- 5,","-- 6,","-- 7,","-- 8,","-- 9,","-- A,","-- B,","-- C,","-- D,","-- E,","-- F,","-- G,","-- H,","-- I,","-- J,","-- K,","-- L,","-- M,","-- N,","-- O,","-- P,","-- Q,","-- R,","-- S,","-- T,","-- U,","-- V,","-- W,","-- X,","-- Y,","-- Z,","-- KP_INS,","-- PAD_0,","-- KP_END,","-- PAD_1,","-- KP_DOWNARROW ,","-- PAD_2,","-- KP_PGDN,","-- PAD_3,","-- KP_LEFTARROW,","-- PAD_4,","-- KP_5 ,","-- PAD_5,","-- KP_RIGHTARROW,","-- PAD_6,","-- KP_HOME,","-- PAD_7,","-- KP_UPARROW,","-- PAD_8,","-- KP_PGUP,","-- PAD_9,","-- PAD_DIVIDE,","-- KP_SLASH,","-- KP_MULTIPLY,","-- PAD_MULTIPLY,","-- KP_MINUS,","-- PAD_MINUS,","-- KP_PLUS,","-- PAD_PLUS,","-- KP_ENTER,","-- PAD_ENTER,","-- KP_DEL,","-- PAD_DECIMAL,","-- LBRACKET,","-- RBRACKET,","-- SEMICOLON,","-- APOSTROPHE,","-- BACKQUOTE,","-- COMMA,","-- PERIOD,","-- SLASH,","-- BACKSLASH,","-- MINUS,","-- EQUAL,","-- ENTER,","-- SPACE,","-- BACKSPACE,","-- TAB,","-- CAPSLOCK,","-- NUMLOCK,","-- ESCAPE,","-- SCROLLLOCK,","-- INS,","-- INSERT,","-- DEL,","-- DELETE,","-- HOME,","-- END,","-- PGUP,","-- PAGEUP,","-- PGDN,","-- PAGEDOWN,","-- PAUSE,","-- BREAK,","-- SHIFT,","-- LSHIFT,","-- RSHIFT,","-- ALT,","-- LALT,","-- RALT,","-- CTRL,","-- LCONTROL,","-- RCTRL,","-- RCONTROL,","-- LWIN,","-- RWIN,","-- APP,","-- UPARROW,","-- UP,","-- LEFTARROW,","-- LEFT,","-- DOWNARROW,","-- DOWN,","-- RIGHTARROW,","-- RIGHT,","-- F1,","-- F2,","-- F3,","-- F4,","-- F5,","-- F6,","-- F7,","-- F8,","-- F9,","-- F10,","-- F11,","-- F12,","-- CAPSLOCKTOGGLE,","-- NUMLOCKTOGGLE,","-- SCROLLLOCKTOGGLE,","-- LAST,","-- COUNT","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]}},"functions":{"1":"assert","2":"chip","3":"concmd","4":"dodir","5":"dofile","6":"entity","7":"error","8":"getLibraries","9":"getfenv","10":"getmetatable","11":"ipairs","12":"isValid","13":"loadstring","14":"next","15":"owner","16":"pairs","17":"player","18":"printMesssage","19":"printTable","20":"quotaAverage","21":"quotaMax","22":"quotaUsed","23":"require","24":"requiredir","25":"setClipboardText","26":"setName","27":"setSoftQuota","28":"setfenv","29":"setmetatable","30":"throw","31":"tonumber","32":"tostring","33":"try","34":"type","35":"unpack","chip":{"ret":"Starfall entity","description":"\nReturns the entity representing a processor that this script is running on.","code":["SF.DefaultEnvironment.chip = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.chip","summary":"\nReturns the entity representing a processor that this script is running on.","library":"builtin","comment":["--- Returns the entity representing a processor that this script is running on.","-- @name SF.DefaultEnvironment.chip","-- @class function","-- @return Starfall entity"],"param":[]},"tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"setClipboardText":{"comment":["\t--- Sets clipboard text. Only works on the owner of the chip.","\t-- @param txt Text to set to the clipboard"],"code":["\tfunction SF.DefaultEnvironment.setClipboardText( txt )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( txt, \"string\" )","\t\tSetClipboardText( txt )","\tend","\t"],"class":"function","name":"SF.DefaultEnvironment.setClipboardText","summary":"\nSets clipboard text.","private":false,"library":"builtin","description":"\nSets clipboard text. Only works on the owner of the chip.","param":{"1":"txt","txt":"Text to set to the clipboard"}},"unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"isValid":{"ret":"If it is valid","comment":["--- Returns if the table has an isValid function and isValid returns true.","--@param object Table to check","--@return If it is valid"],"code":["function SF.DefaultEnvironment.isValid( object )","","\tif ( !object ) then return false end","\tif ( !object.isValid ) then return false end","","\treturn object:isValid()","","end","","local _KEY = {","\t[ \"FIRST\" ] = 0,","\t[ \"NONE\" ] = 0,","\t[ \"0\" ] = 1,","\t[ \"1\" ] = 2,","\t[ \"2\" ] = 3,","\t[ \"3\" ] = 4,","\t[ \"4\" ] = 5,","\t[ \"5\" ] = 6,","\t[ \"6\" ] = 7,","\t[ \"7\" ] = 8,","\t[ \"8\" ] = 9,","\t[ \"9\" ] = 10,","\t[ \"A\" ] = 11,","\t[ \"B\" ] = 12,","\t[ \"C\" ] = 13,","\t[ \"D\" ] = 14,","\t[ \"E\" ] = 15,","\t[ \"F\" ] = 16,","\t[ \"G\" ] = 17,","\t[ \"H\" ] = 18,","\t[ \"I\" ] = 19,","\t[ \"J\" ] = 20,","\t[ \"K\" ] = 21,","\t[ \"L\" ] = 22,","\t[ \"M\" ] = 23,","\t[ \"N\" ] = 24,","\t[ \"O\" ] = 25,","\t[ \"P\" ] = 26,","\t[ \"Q\" ] = 27,","\t[ \"R\" ] = 28,","\t[ \"S\" ] = 29,","\t[ \"T\" ] = 30,","\t[ \"U\" ] = 31,","\t[ \"V\" ] = 32,","\t[ \"W\" ] = 33,","\t[ \"X\" ] = 34,","\t[ \"Y\" ] = 35,","\t[ \"Z\" ] = 36,","\t[ \"KP_INS\" ] = 37,","\t[ \"PAD_0\" ] = 37,","\t[ \"KP_END\" ] = 38,","\t[ \"PAD_1\" ] = 38,","\t[ \"KP_DOWNARROW \" ] = 39,","\t[ \"PAD_2\" ] = 39,","\t[ \"KP_PGDN\" ] = 40,","\t[ \"PAD_3\" ] = 40,","\t[ \"KP_LEFTARROW\" ] = 41,","\t[ \"PAD_4\" ] = 41,","\t[ \"KP_5 \" ] = 42,","\t[ \"PAD_5\" ] = 42,","\t[ \"KP_RIGHTARROW\" ] = 43,","\t[ \"PAD_6\" ] = 43,","\t[ \"KP_HOME\" ] = 44,","\t[ \"PAD_7\" ] = 44,","\t[ \"KP_UPARROW\" ] = 45,","\t[ \"PAD_8\" ] = 45,","\t[ \"KP_PGUP\" ] = 46,","\t[ \"PAD_9\" ] = 46,","\t[ \"PAD_DIVIDE\" ] = 47,","\t[ \"KP_SLASH\" ] = 47,","\t[ \"KP_MULTIPLY\" ] = 48,","\t[ \"PAD_MULTIPLY\" ] = 48,","\t[ \"KP_MINUS\" ] = 49,","\t[ \"PAD_MINUS\" ] = 49,","\t[ \"KP_PLUS\" ] = 50,","\t[ \"PAD_PLUS\" ] = 50,","\t[ \"KP_ENTER\" ] = 51,","\t[ \"PAD_ENTER\" ] = 51,","\t[ \"KP_DEL\" ] = 52,","\t[ \"PAD_DECIMAL\" ] = 52,","\t[ \"[\" ] = 53,","\t[ \"LBRACKET\" ] = 53,","\t[ \"]\" ] = 54,","\t[ \"RBRACKET\" ] = 54,","\t[ \"SEMICOLON\" ] = 55,","\t[ \"'\" ] = 56,","\t[ \"APOSTROPHE\" ] = 56,","\t[ \"`\" ] = 57,","\t[ \"BACKQUOTE\" ] = 57,","\t[ \",\" ] = 58,","\t[ \"COMMA\" ] = 58,","\t[ \".\" ] = 59,","\t[ \"PERIOD\" ] = 59,","\t[ \"/\" ] = 60,","\t[ \"SLASH\" ] = 60,","\t[ \"\\\\\" ] = 61,","\t[ \"BACKSLASH\" ] = 61,","\t[ \"-\" ] = 62,","\t[ \"MINUS\" ] = 62,","\t[ \"=\" ] = 63,","\t[ \"EQUAL\" ] = 63,","\t[ \"ENTER\" ] = 64,","\t[ \"SPACE\" ] = 65,","\t[ \"BACKSPACE\" ] = 66,","\t[ \"TAB\" ] = 67,","\t[ \"CAPSLOCK\" ] = 68,","\t[ \"NUMLOCK\" ] = 69,","\t[ \"ESCAPE\" ] = 70,","\t[ \"SCROLLLOCK\" ] = 71,","\t[ \"INS\" ] = 72,","\t[ \"INSERT\" ] = 72,","\t[ \"DEL\" ] = 73,","\t[ \"DELETE\" ] = 73,","\t[ \"HOME\" ] = 74,","\t[ \"END\" ] = 75,","\t[ \"PGUP\" ] = 76,","\t[ \"PAGEUP\" ] = 76,","\t[ \"PGDN\" ] = 77,","\t[ \"PAGEDOWN\" ] = 77,","\t[ \"PAUSE\" ] = 78,","\t[ \"BREAK\" ] = 78,","\t[ \"SHIFT\" ] = 79,","\t[ \"LSHIFT\" ] = 79,","\t[ \"RSHIFT\" ] = 80,","\t[ \"ALT\" ] = 81,","\t[ \"LALT\" ] = 81,","\t[ \"RALT\" ] = 82,","\t[ \"CTRL\" ] = 83,","\t[ \"LCONTROL\" ] = 83,","\t[ \"RCTRL\" ] = 84,","\t[ \"RCONTROL\" ] = 84,","\t[ \"LWIN\" ] = 85,","\t[ \"RWIN\" ] = 86,","\t[ \"APP\" ] = 87,","\t[ \"UPARROW\" ] = 88,","\t[ \"UP\" ] = 88,","\t[ \"LEFTARROW\" ] = 89,","\t[ \"LEFT\" ] = 89,","\t[ \"DOWNARROW\" ] = 90,","\t[ \"DOWN\" ] = 90,","\t[ \"RIGHTARROW\" ] = 91,","\t[ \"RIGHT\" ] = 91,","\t[ \"F1\" ] = 92,","\t[ \"F2\" ] = 93,","\t[ \"F3\" ] = 94,","\t[ \"F4\" ] = 95,","\t[ \"F5\" ] = 96,","\t[ \"F6\" ] = 97,","\t[ \"F7\" ] = 98,","\t[ \"F8\" ] = 99,","\t[ \"F9\" ] = 100,","\t[ \"F10\" ] = 101,","\t[ \"F11\" ] = 102,","\t[ \"F12\" ] = 103,","\t[ \"CAPSLOCKTOGGLE\" ] = 104,","\t[ \"NUMLOCKTOGGLE\" ] = 105,","\t[ \"SCROLLLOCKTOGGLE\" ] = 106,","\t[ \"LAST\" ] = 106,","\t[ \"COUNT\" ] = 106","}",""],"class":"function","name":"SF.DefaultEnvironment.isValid","summary":"\nReturns if the table has an isValid function and isValid returns true.","private":false,"library":"builtin","description":"\nReturns if the table has an isValid function and isValid returns true.","param":{"1":"object","object":"Table to check"}},"pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as owner() on the server. On the client, returns the local player","code":["SF.DefaultEnvironment.player = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.player","summary":"\nSame as owner() on the server.","library":"builtin","comment":["--- Same as owner() on the server. On the client, returns the local player","-- @name SF.DefaultEnvironment.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]},"requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}},"getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if CLIENT then\t"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},"dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"entity":{"ret":"entity","description":"\nReturns the entity with index 'num'","code":["SF.DefaultEnvironment.entity = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.entity","summary":"\nReturns the entity with index 'num' ","library":"builtin","comment":["--- Returns the entity with index 'num'","-- @name SF.DefaultEnvironment.entity","-- @class function","-- @param num Entity index","-- @return entity"],"param":{"1":"num","num":"Entity index"}},"type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"printMesssage":{"comment":["\t--- Prints a message to your chat, console, or the center of your screen.","\t-- @param mtype How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","\t-- @param text The message text."],"code":["\tfunction SF.DefaultEnvironment.printMesssage( mtype, text )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( text, \"string\" )","\t\tSF.instance.player:PrintMessage( mtype, text )","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end","","-- Prints a message to the player's chat.","-- @shared","-- @param ... Values to print","function SF.DefaultEnvironment.print(...)","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tlocal str = \"\"","\tlocal tbl = {n=select('#', ...), ...}","\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t( SERVER and SF.instance.player or LocalPlayer() ):ChatPrint(str)","end",""],"class":"function","name":"SF.DefaultEnvironment.printMesssage","summary":"\nPrints a message to your chat, console, or the center of your screen.","private":false,"library":"builtin","description":"\nPrints a message to your chat, console, or the center of your screen.","param":{"1":"mtype","2":"text","mtype":"How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","text":"The message text."}},"printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"owner":{"ret":"Owner entity","description":"\nReturns whoever created the chip","code":["SF.DefaultEnvironment.owner = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.owner","summary":"\nReturns whoever created the chip ","library":"builtin","comment":["--- Returns whoever created the chip","-- @name SF.DefaultEnvironment.owner","-- @class function","-- @return Owner entity"],"param":[]},"getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\tlocal fenv = getfenv(2)","\tif fenv ~= _G then return fenv end","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" or getfenv( func ) == _G then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"setName":{"comment":["\t--- Sets the chip's display name","\t-- @client","\t-- @param name Name"],"code":["\tfunction SF.DefaultEnvironment.setName( name )","\t\tSF.CheckType( name, \"string\" )","\t\tlocal e = SF.instance.data.entity","\t\tif IsValid( e ) then","\t\t\te.name = name","\t\tend","\tend","\t"],"class":"function","summary":"\nSets the chip's display name ","name":"SF.DefaultEnvironment.setName","library":"builtin","private":false,"client":true,"description":"\nSets the chip's display name","param":{"1":"name","name":"Name"}},"dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"setSoftQuota":{"comment":["--- Sets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","-- @param quota The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50% "],"code":["function SF.DefaultEnvironment.setSoftQuota ( quota )","\tSF.CheckType( quota, \"number\" )","\tself.cpu_softquota = quota","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original)","\tfor name, func in pairs(lib) do","\t\tif not type(name)==\"string\" then continue end","\t\tname = name:gsub(\"^[A-Z]\", string.lower)","\t\toriginal[name] = func","\tend","end","","-- String library","local string_methods, string_metatable = SF.Typedef(\"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.setSoftQuota","summary":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","private":false,"library":"builtin","description":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","param":{"1":"quota","quota":"The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50%"}}},"classForced":true,"fields":{"1":"CLIENT","2":"SERVER","CLIENT":{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},"SERVER":{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]}},"name":"builtin","libtbl":"SF.DefaultEnvironment","server":true,"client":true,"comment":["--- Built in values. These don't need to be loaded; they are in the default environment.","-- @name builtin","-- @shared","-- @class library","-- @libtbl SF.DefaultEnvironment"],"param":[]},{"ret":"Starfall entity","description":"\nReturns the entity representing a processor that this script is running on.","code":["SF.DefaultEnvironment.chip = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.chip","summary":"\nReturns the entity representing a processor that this script is running on.","library":"builtin","comment":["--- Returns the entity representing a processor that this script is running on.","-- @name SF.DefaultEnvironment.chip","-- @class function","-- @return Starfall entity"],"param":[]},{"ret":"Owner entity","description":"\nReturns whoever created the chip","code":["SF.DefaultEnvironment.owner = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.owner","summary":"\nReturns whoever created the chip ","library":"builtin","comment":["--- Returns whoever created the chip","-- @name SF.DefaultEnvironment.owner","-- @class function","-- @return Owner entity"],"param":[]},{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as owner() on the server. On the client, returns the local player","code":["SF.DefaultEnvironment.player = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.player","summary":"\nSame as owner() on the server.","library":"builtin","comment":["--- Same as owner() on the server. On the client, returns the local player","-- @name SF.DefaultEnvironment.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]},{"ret":"entity","description":"\nReturns the entity with index 'num'","code":["SF.DefaultEnvironment.entity = nil",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.entity","summary":"\nReturns the entity with index 'num' ","library":"builtin","comment":["--- Returns the entity with index 'num'","-- @name SF.DefaultEnvironment.entity","-- @class function","-- @param num Entity index","-- @return entity"],"param":{"1":"num","num":"Entity index"}},{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]},{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},{"comment":["--- Sets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","-- @param quota The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50% "],"code":["function SF.DefaultEnvironment.setSoftQuota ( quota )","\tSF.CheckType( quota, \"number\" )","\tself.cpu_softquota = quota","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original)","\tfor name, func in pairs(lib) do","\t\tif not type(name)==\"string\" then continue end","\t\tname = name:gsub(\"^[A-Z]\", string.lower)","\t\toriginal[name] = func","\tend","end","","-- String library","local string_methods, string_metatable = SF.Typedef(\"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.setSoftQuota","summary":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","private":false,"library":"builtin","description":"\nSets a CPU soft quota which will trigger a catchable error if the cpu goes over a certain amount.","param":{"1":"quota","quota":"The threshold where the soft error will be thrown. Ratio of current cpu to the max cpu usage. 0.5 is 50%"}},{"description":"\nString library http://wiki.garrysmod.com/page/Category:string","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nString library http://wiki.garrysmod.com/page/Category:string ","library":"builtin","comment":["--- String library http://wiki.garrysmod.com/page/Category:string","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},{"description":"\nThe math library. http://wiki.garrysmod.com/page/Category:math","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nThe math library.","library":"builtin","comment":["--- The math library. http://wiki.garrysmod.com/page/Category:math","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},{"description":"\nThe os library. http://wiki.garrysmod.com/page/Category:os","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nThe os library.","library":"builtin","comment":["--- The os library. http://wiki.garrysmod.com/page/Category:os","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},{"description":"\nTable library. http://wiki.garrysmod.com/page/Category:table","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","local bit_methods, bit_metatable = SF.Typedef(\"Library: bit\")","filterGmodLua(bit,bit_methods)","bit_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nTable library.","library":"builtin","comment":["--- Table library. http://wiki.garrysmod.com/page/Category:table","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},{"description":"\nBit library. http://wiki.garrysmod.com/page/Category:bit","code":["SF.DefaultEnvironment.bit = setmetatable({},bit_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.bit","summary":"\nBit library.","library":"builtin","comment":["--- Bit library. http://wiki.garrysmod.com/page/Category:bit","-- @name SF.DefaultEnvironment.bit","-- @class table"],"param":[]},{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if CLIENT then\t"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},{"comment":["\t--- Sets the chip's display name","\t-- @client","\t-- @param name Name"],"code":["\tfunction SF.DefaultEnvironment.setName( name )","\t\tSF.CheckType( name, \"string\" )","\t\tlocal e = SF.instance.data.entity","\t\tif IsValid( e ) then","\t\t\te.name = name","\t\tend","\tend","\t"],"class":"function","summary":"\nSets the chip's display name ","name":"SF.DefaultEnvironment.setName","library":"builtin","private":false,"client":true,"description":"\nSets the chip's display name","param":{"1":"name","name":"Name"}},{"comment":["\t--- Sets clipboard text. Only works on the owner of the chip.","\t-- @param txt Text to set to the clipboard"],"code":["\tfunction SF.DefaultEnvironment.setClipboardText( txt )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( txt, \"string\" )","\t\tSetClipboardText( txt )","\tend","\t"],"class":"function","name":"SF.DefaultEnvironment.setClipboardText","summary":"\nSets clipboard text.","private":false,"library":"builtin","description":"\nSets clipboard text. Only works on the owner of the chip.","param":{"1":"txt","txt":"Text to set to the clipboard"}},{"comment":["\t--- Prints a message to your chat, console, or the center of your screen.","\t-- @param mtype How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","\t-- @param text The message text."],"code":["\tfunction SF.DefaultEnvironment.printMesssage( mtype, text )","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tSF.CheckType( text, \"string\" )","\t\tSF.instance.player:PrintMessage( mtype, text )","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end","","-- Prints a message to the player's chat.","-- @shared","-- @param ... Values to print","function SF.DefaultEnvironment.print(...)","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tlocal str = \"\"","\tlocal tbl = {n=select('#', ...), ...}","\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t( SERVER and SF.instance.player or LocalPlayer() ):ChatPrint(str)","end",""],"class":"function","name":"SF.DefaultEnvironment.printMesssage","summary":"\nPrints a message to your chat, console, or the center of your screen.","private":false,"library":"builtin","description":"\nPrints a message to your chat, console, or the center of your screen.","param":{"1":"mtype","2":"text","mtype":"How the message should be displayed. See http://wiki.garrysmod.com/page/Enums/HUD","text":"The message text."}},{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" or getfenv( func ) == _G then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\tlocal fenv = getfenv(2)","\tif fenv ~= _G then return fenv end","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}},{"ret":"If it is valid","comment":["--- Returns if the table has an isValid function and isValid returns true.","--@param object Table to check","--@return If it is valid"],"code":["function SF.DefaultEnvironment.isValid( object )","","\tif ( !object ) then return false end","\tif ( !object.isValid ) then return false end","","\treturn object:isValid()","","end","","local _KEY = {","\t[ \"FIRST\" ] = 0,","\t[ \"NONE\" ] = 0,","\t[ \"0\" ] = 1,","\t[ \"1\" ] = 2,","\t[ \"2\" ] = 3,","\t[ \"3\" ] = 4,","\t[ \"4\" ] = 5,","\t[ \"5\" ] = 6,","\t[ \"6\" ] = 7,","\t[ \"7\" ] = 8,","\t[ \"8\" ] = 9,","\t[ \"9\" ] = 10,","\t[ \"A\" ] = 11,","\t[ \"B\" ] = 12,","\t[ \"C\" ] = 13,","\t[ \"D\" ] = 14,","\t[ \"E\" ] = 15,","\t[ \"F\" ] = 16,","\t[ \"G\" ] = 17,","\t[ \"H\" ] = 18,","\t[ \"I\" ] = 19,","\t[ \"J\" ] = 20,","\t[ \"K\" ] = 21,","\t[ \"L\" ] = 22,","\t[ \"M\" ] = 23,","\t[ \"N\" ] = 24,","\t[ \"O\" ] = 25,","\t[ \"P\" ] = 26,","\t[ \"Q\" ] = 27,","\t[ \"R\" ] = 28,","\t[ \"S\" ] = 29,","\t[ \"T\" ] = 30,","\t[ \"U\" ] = 31,","\t[ \"V\" ] = 32,","\t[ \"W\" ] = 33,","\t[ \"X\" ] = 34,","\t[ \"Y\" ] = 35,","\t[ \"Z\" ] = 36,","\t[ \"KP_INS\" ] = 37,","\t[ \"PAD_0\" ] = 37,","\t[ \"KP_END\" ] = 38,","\t[ \"PAD_1\" ] = 38,","\t[ \"KP_DOWNARROW \" ] = 39,","\t[ \"PAD_2\" ] = 39,","\t[ \"KP_PGDN\" ] = 40,","\t[ \"PAD_3\" ] = 40,","\t[ \"KP_LEFTARROW\" ] = 41,","\t[ \"PAD_4\" ] = 41,","\t[ \"KP_5 \" ] = 42,","\t[ \"PAD_5\" ] = 42,","\t[ \"KP_RIGHTARROW\" ] = 43,","\t[ \"PAD_6\" ] = 43,","\t[ \"KP_HOME\" ] = 44,","\t[ \"PAD_7\" ] = 44,","\t[ \"KP_UPARROW\" ] = 45,","\t[ \"PAD_8\" ] = 45,","\t[ \"KP_PGUP\" ] = 46,","\t[ \"PAD_9\" ] = 46,","\t[ \"PAD_DIVIDE\" ] = 47,","\t[ \"KP_SLASH\" ] = 47,","\t[ \"KP_MULTIPLY\" ] = 48,","\t[ \"PAD_MULTIPLY\" ] = 48,","\t[ \"KP_MINUS\" ] = 49,","\t[ \"PAD_MINUS\" ] = 49,","\t[ \"KP_PLUS\" ] = 50,","\t[ \"PAD_PLUS\" ] = 50,","\t[ \"KP_ENTER\" ] = 51,","\t[ \"PAD_ENTER\" ] = 51,","\t[ \"KP_DEL\" ] = 52,","\t[ \"PAD_DECIMAL\" ] = 52,","\t[ \"[\" ] = 53,","\t[ \"LBRACKET\" ] = 53,","\t[ \"]\" ] = 54,","\t[ \"RBRACKET\" ] = 54,","\t[ \"SEMICOLON\" ] = 55,","\t[ \"'\" ] = 56,","\t[ \"APOSTROPHE\" ] = 56,","\t[ \"`\" ] = 57,","\t[ \"BACKQUOTE\" ] = 57,","\t[ \",\" ] = 58,","\t[ \"COMMA\" ] = 58,","\t[ \".\" ] = 59,","\t[ \"PERIOD\" ] = 59,","\t[ \"/\" ] = 60,","\t[ \"SLASH\" ] = 60,","\t[ \"\\\\\" ] = 61,","\t[ \"BACKSLASH\" ] = 61,","\t[ \"-\" ] = 62,","\t[ \"MINUS\" ] = 62,","\t[ \"=\" ] = 63,","\t[ \"EQUAL\" ] = 63,","\t[ \"ENTER\" ] = 64,","\t[ \"SPACE\" ] = 65,","\t[ \"BACKSPACE\" ] = 66,","\t[ \"TAB\" ] = 67,","\t[ \"CAPSLOCK\" ] = 68,","\t[ \"NUMLOCK\" ] = 69,","\t[ \"ESCAPE\" ] = 70,","\t[ \"SCROLLLOCK\" ] = 71,","\t[ \"INS\" ] = 72,","\t[ \"INSERT\" ] = 72,","\t[ \"DEL\" ] = 73,","\t[ \"DELETE\" ] = 73,","\t[ \"HOME\" ] = 74,","\t[ \"END\" ] = 75,","\t[ \"PGUP\" ] = 76,","\t[ \"PAGEUP\" ] = 76,","\t[ \"PGDN\" ] = 77,","\t[ \"PAGEDOWN\" ] = 77,","\t[ \"PAUSE\" ] = 78,","\t[ \"BREAK\" ] = 78,","\t[ \"SHIFT\" ] = 79,","\t[ \"LSHIFT\" ] = 79,","\t[ \"RSHIFT\" ] = 80,","\t[ \"ALT\" ] = 81,","\t[ \"LALT\" ] = 81,","\t[ \"RALT\" ] = 82,","\t[ \"CTRL\" ] = 83,","\t[ \"LCONTROL\" ] = 83,","\t[ \"RCTRL\" ] = 84,","\t[ \"RCONTROL\" ] = 84,","\t[ \"LWIN\" ] = 85,","\t[ \"RWIN\" ] = 86,","\t[ \"APP\" ] = 87,","\t[ \"UPARROW\" ] = 88,","\t[ \"UP\" ] = 88,","\t[ \"LEFTARROW\" ] = 89,","\t[ \"LEFT\" ] = 89,","\t[ \"DOWNARROW\" ] = 90,","\t[ \"DOWN\" ] = 90,","\t[ \"RIGHTARROW\" ] = 91,","\t[ \"RIGHT\" ] = 91,","\t[ \"F1\" ] = 92,","\t[ \"F2\" ] = 93,","\t[ \"F3\" ] = 94,","\t[ \"F4\" ] = 95,","\t[ \"F5\" ] = 96,","\t[ \"F6\" ] = 97,","\t[ \"F7\" ] = 98,","\t[ \"F8\" ] = 99,","\t[ \"F9\" ] = 100,","\t[ \"F10\" ] = 101,","\t[ \"F11\" ] = 102,","\t[ \"F12\" ] = 103,","\t[ \"CAPSLOCKTOGGLE\" ] = 104,","\t[ \"NUMLOCKTOGGLE\" ] = 105,","\t[ \"SCROLLLOCKTOGGLE\" ] = 106,","\t[ \"LAST\" ] = 106,","\t[ \"COUNT\" ] = 106","}",""],"class":"function","name":"SF.DefaultEnvironment.isValid","summary":"\nReturns if the table has an isValid function and isValid returns true.","private":false,"library":"builtin","description":"\nReturns if the table has an isValid function and isValid returns true.","param":{"1":"object","object":"Table to check"}},{"description":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library:","-- FIRST,","-- NONE,","-- 0,","-- 1,","-- 2,","-- 3,","-- 4,","-- 5,","-- 6,","-- 7,","-- 8,","-- 9,","-- A,","-- B,","-- C,","-- D,","-- E,","-- F,","-- G,","-- H,","-- I,","-- J,","-- K,","-- L,","-- M,","-- N,","-- O,","-- P,","-- Q,","-- R,","-- S,","-- T,","-- U,","-- V,","-- W,","-- X,","-- Y,","-- Z,","-- KP_INS,","-- PAD_0,","-- KP_END,","-- PAD_1,","-- KP_DOWNARROW ,","-- PAD_2,","-- KP_PGDN,","-- PAD_3,","-- KP_LEFTARROW,","-- PAD_4,","-- KP_5 ,","-- PAD_5,","-- KP_RIGHTARROW,","-- PAD_6,","-- KP_HOME,","-- PAD_7,","-- KP_UPARROW,","-- PAD_8,","-- KP_PGUP,","-- PAD_9,","-- PAD_DIVIDE,","-- KP_SLASH,","-- KP_MULTIPLY,","-- PAD_MULTIPLY,","-- KP_MINUS,","-- PAD_MINUS,","-- KP_PLUS,","-- PAD_PLUS,","-- KP_ENTER,","-- PAD_ENTER,","-- KP_DEL,","-- PAD_DECIMAL,","-- LBRACKET,","-- RBRACKET,","-- SEMICOLON,","-- APOSTROPHE,","-- BACKQUOTE,","-- COMMA,","-- PERIOD,","-- SLASH,","-- BACKSLASH,","-- MINUS,","-- EQUAL,","-- ENTER,","-- SPACE,","-- BACKSPACE,","-- TAB,","-- CAPSLOCK,","-- NUMLOCK,","-- ESCAPE,","-- SCROLLLOCK,","-- INS,","-- INSERT,","-- DEL,","-- DELETE,","-- HOME,","-- END,","-- PGUP,","-- PAGEUP,","-- PGDN,","-- PAGEDOWN,","-- PAUSE,","-- BREAK,","-- SHIFT,","-- LSHIFT,","-- RSHIFT,","-- ALT,","-- LALT,","-- RALT,","-- CTRL,","-- LCONTROL,","-- RCTRL,","-- RCONTROL,","-- LWIN,","-- RWIN,","-- APP,","-- UPARROW,","-- UP,","-- LEFTARROW,","-- LEFT,","-- DOWNARROW,","-- DOWN,","-- RIGHTARROW,","-- RIGHT,","-- F1,","-- F2,","-- F3,","-- F4,","-- F5,","-- F6,","-- F7,","-- F8,","-- F9,","-- F10,","-- F11,","-- F12,","-- CAPSLOCKTOGGLE,","-- NUMLOCKTOGGLE,","-- SCROLLLOCKTOGGLE,","-- LAST,","-- COUNT","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]},{"description":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library:","-- MOUSE1,","-- LEFT,","-- MOUSE2,","-- RIGHT,","-- MOUSE3,","-- MIDDLE,","-- MOUSE4,","-- 4,","-- MOUSE5,","-- 5,","-- MWHEELUP,","-- WHEEL_UP,","-- MWHEELDOWN,","-- WHEEL_DOWN,","-- COUNT,","-- FIRST,","-- LAST","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},{"description":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown:","-- ALT1,","-- ALT2,","-- ATTACK,","-- ATTACK2,","-- BACK,","-- DUCK,","-- FORWARD,","-- JUMP,","-- LEFT,","-- MOVELEFT,","-- MOVERIGHT,","-- RELOAD,","-- RIGHT,","-- SCORE,","-- SPEED,","-- USE,","-- WALK,","-- ZOOM,","-- GRENADE1,","-- GRENADE2,","-- WEAPON1,","-- WEAPON2,","-- BULLRUSH,","-- CANCEL,","-- RUN","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]}],"tables":{"1":"SF.DefaultEnvironment.IN_KEY","2":"SF.DefaultEnvironment.KEY","3":"SF.DefaultEnvironment.MOUSE","4":"SF.DefaultEnvironment.bit","5":"SF.DefaultEnvironment.math","6":"SF.DefaultEnvironment.os","7":"SF.DefaultEnvironment.string","8":"SF.DefaultEnvironment.table","SF.DefaultEnvironment.string":{"description":"\nString library http://wiki.garrysmod.com/page/Category:string","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nString library http://wiki.garrysmod.com/page/Category:string ","library":"builtin","comment":["--- String library http://wiki.garrysmod.com/page/Category:string","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"SF.DefaultEnvironment.MOUSE":{"description":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library: \nMOUSE1, \nLEFT, \nMOUSE2, \nRIGHT, \nMOUSE3, \nMIDDLE, \nMOUSE4, \n4, \nMOUSE5, \n5, \nMWHEELUP, \nWHEEL_UP, \nMWHEELDOWN, \nWHEEL_DOWN, \nCOUNT, \nFIRST, \nLAST ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library:","-- MOUSE1,","-- LEFT,","-- MOUSE2,","-- RIGHT,","-- MOUSE3,","-- MIDDLE,","-- MOUSE4,","-- 4,","-- MOUSE5,","-- 5,","-- MWHEELUP,","-- WHEEL_UP,","-- MWHEELDOWN,","-- WHEEL_DOWN,","-- COUNT,","-- FIRST,","-- LAST","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"SF.DefaultEnvironment.IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown: \nALT1, \nALT2, \nATTACK, \nATTACK2, \nBACK, \nDUCK, \nFORWARD, \nJUMP, \nLEFT, \nMOVELEFT, \nMOVERIGHT, \nRELOAD, \nRIGHT, \nSCORE, \nSPEED, \nUSE, \nWALK, \nZOOM, \nGRENADE1, \nGRENADE2, \nWEAPON1, \nWEAPON2, \nBULLRUSH, \nCANCEL, \nRUN ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown:","-- ALT1,","-- ALT2,","-- ATTACK,","-- ATTACK2,","-- BACK,","-- DUCK,","-- FORWARD,","-- JUMP,","-- LEFT,","-- MOVELEFT,","-- MOVERIGHT,","-- RELOAD,","-- RIGHT,","-- SCORE,","-- SPEED,","-- USE,","-- WALK,","-- ZOOM,","-- GRENADE1,","-- GRENADE2,","-- WEAPON1,","-- WEAPON2,","-- BULLRUSH,","-- CANCEL,","-- RUN","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"SF.DefaultEnvironment.KEY":{"description":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library: \nFIRST, \nNONE, \n0, \n1, \n2, \n3, \n4, \n5, \n6, \n7, \n8, \n9, \nA, \nB, \nC, \nD, \nE, \nF, \nG, \nH, \nI, \nJ, \nK, \nL, \nM, \nN, \nO, \nP, \nQ, \nR, \nS, \nT, \nU, \nV, \nW, \nX, \nY, \nZ, \nKP_INS, \nPAD_0, \nKP_END, \nPAD_1, \nKP_DOWNARROW , \nPAD_2, \nKP_PGDN, \nPAD_3, \nKP_LEFTARROW, \nPAD_4, \nKP_5 , \nPAD_5, \nKP_RIGHTARROW, \nPAD_6, \nKP_HOME, \nPAD_7, \nKP_UPARROW, \nPAD_8, \nKP_PGUP, \nPAD_9, \nPAD_DIVIDE, \nKP_SLASH, \nKP_MULTIPLY, \nPAD_MULTIPLY, \nKP_MINUS, \nPAD_MINUS, \nKP_PLUS, \nPAD_PLUS, \nKP_ENTER, \nPAD_ENTER, \nKP_DEL, \nPAD_DECIMAL, \nLBRACKET, \nRBRACKET, \nSEMICOLON, \nAPOSTROPHE, \nBACKQUOTE, \nCOMMA, \nPERIOD, \nSLASH, \nBACKSLASH, \nMINUS, \nEQUAL, \nENTER, \nSPACE, \nBACKSPACE, \nTAB, \nCAPSLOCK, \nNUMLOCK, \nESCAPE, \nSCROLLLOCK, \nINS, \nINSERT, \nDEL, \nDELETE, \nHOME, \nEND, \nPGUP, \nPAGEUP, \nPGDN, \nPAGEDOWN, \nPAUSE, \nBREAK, \nSHIFT, \nLSHIFT, \nRSHIFT, \nALT, \nLALT, \nRALT, \nCTRL, \nLCONTROL, \nRCTRL, \nRCONTROL, \nLWIN, \nRWIN, \nAPP, \nUPARROW, \nUP, \nLEFTARROW, \nLEFT, \nDOWNARROW, \nDOWN, \nRIGHTARROW, \nRIGHT, \nF1, \nF2, \nF3, \nF4, \nF5, \nF6, \nF7, \nF8, \nF9, \nF10, \nF11, \nF12, \nCAPSLOCKTOGGLE, \nNUMLOCKTOGGLE, \nSCROLLLOCKTOGGLE, \nLAST, \nCOUNT ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library:","-- FIRST,","-- NONE,","-- 0,","-- 1,","-- 2,","-- 3,","-- 4,","-- 5,","-- 6,","-- 7,","-- 8,","-- 9,","-- A,","-- B,","-- C,","-- D,","-- E,","-- F,","-- G,","-- H,","-- I,","-- J,","-- K,","-- L,","-- M,","-- N,","-- O,","-- P,","-- Q,","-- R,","-- S,","-- T,","-- U,","-- V,","-- W,","-- X,","-- Y,","-- Z,","-- KP_INS,","-- PAD_0,","-- KP_END,","-- PAD_1,","-- KP_DOWNARROW ,","-- PAD_2,","-- KP_PGDN,","-- PAD_3,","-- KP_LEFTARROW,","-- PAD_4,","-- KP_5 ,","-- PAD_5,","-- KP_RIGHTARROW,","-- PAD_6,","-- KP_HOME,","-- PAD_7,","-- KP_UPARROW,","-- PAD_8,","-- KP_PGUP,","-- PAD_9,","-- PAD_DIVIDE,","-- KP_SLASH,","-- KP_MULTIPLY,","-- PAD_MULTIPLY,","-- KP_MINUS,","-- PAD_MINUS,","-- KP_PLUS,","-- PAD_PLUS,","-- KP_ENTER,","-- PAD_ENTER,","-- KP_DEL,","-- PAD_DECIMAL,","-- LBRACKET,","-- RBRACKET,","-- SEMICOLON,","-- APOSTROPHE,","-- BACKQUOTE,","-- COMMA,","-- PERIOD,","-- SLASH,","-- BACKSLASH,","-- MINUS,","-- EQUAL,","-- ENTER,","-- SPACE,","-- BACKSPACE,","-- TAB,","-- CAPSLOCK,","-- NUMLOCK,","-- ESCAPE,","-- SCROLLLOCK,","-- INS,","-- INSERT,","-- DEL,","-- DELETE,","-- HOME,","-- END,","-- PGUP,","-- PAGEUP,","-- PGDN,","-- PAGEDOWN,","-- PAUSE,","-- BREAK,","-- SHIFT,","-- LSHIFT,","-- RSHIFT,","-- ALT,","-- LALT,","-- RALT,","-- CTRL,","-- LCONTROL,","-- RCTRL,","-- RCONTROL,","-- LWIN,","-- RWIN,","-- APP,","-- UPARROW,","-- UP,","-- LEFTARROW,","-- LEFT,","-- DOWNARROW,","-- DOWN,","-- RIGHTARROW,","-- RIGHT,","-- F1,","-- F2,","-- F3,","-- F4,","-- F5,","-- F6,","-- F7,","-- F8,","-- F9,","-- F10,","-- F11,","-- F12,","-- CAPSLOCKTOGGLE,","-- NUMLOCKTOGGLE,","-- SCROLLLOCKTOGGLE,","-- LAST,","-- COUNT","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]},"SF.DefaultEnvironment.os":{"description":"\nThe os library. http://wiki.garrysmod.com/page/Category:os","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nThe os library.","library":"builtin","comment":["--- The os library. http://wiki.garrysmod.com/page/Category:os","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"SF.DefaultEnvironment.math":{"description":"\nThe math library. http://wiki.garrysmod.com/page/Category:math","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nThe math library.","library":"builtin","comment":["--- The math library. http://wiki.garrysmod.com/page/Category:math","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"SF.DefaultEnvironment.table":{"description":"\nTable library. http://wiki.garrysmod.com/page/Category:table","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","local bit_methods, bit_metatable = SF.Typedef(\"Library: bit\")","filterGmodLua(bit,bit_methods)","bit_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nTable library.","library":"builtin","comment":["--- Table library. http://wiki.garrysmod.com/page/Category:table","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"SF.DefaultEnvironment.bit":{"description":"\nBit library. http://wiki.garrysmod.com/page/Category:bit","code":["SF.DefaultEnvironment.bit = setmetatable({},bit_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.bit","summary":"\nBit library.","library":"builtin","comment":["--- Bit library. http://wiki.garrysmod.com/page/Category:bit","-- @name SF.DefaultEnvironment.bit","-- @class table"],"param":[]}},"description":"\n \nBuiltins. \nFunctions built-in to the default environment \n","summary":"\n \nBuiltins."},"permissions/core.lua":{"libraries":[],"type":"file","name":"permissions/core.lua","functions":{"1":"P.check","2":"P.registerPrivilege","3":"P.registerProvider","P.check":{"ret":"boolean whether the action is permitted","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return boolean whether the action is permitted"],"code":["function P.check ( principal, target, key )","\tif not P.privileges[ key ] then print( \"WARNING: Starfall privilege \" .. key .. \" was not registered!\" ) end","","\t-- server owners can do whatever they want","\tif have_owner then","\t\t-- this can't be merged into the check loop below because that","\t\tfor _, provider in pairs( providers ) do","\t\t\tif provider:isOwner( principal ) then return true end","\t\tend","\tend","","\tlocal allow = true","\tfor _, provider in pairs( providers ) do","\t\tlocal result = provider:check( principal, target, key )","\t\tif DENY == result then","\t\t\t-- a single deny overrides any allows, just deny it now","\t\t\treturn false","\t\telseif ALLOW == result then","\t\t\t-- an allow can be overridden by a deny, so remember and keep going","\t\t\tallow = true","\t\tend","\t\t-- otherwise, this provider has no opinion, just go on to the next one","\tend","","\treturn allow","end",""],"class":"function","name":"P.check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}},"P.registerProvider":{"summary":"\nAdds a provider implementation to the set used by this library.","description":"\nAdds a provider implementation to the set used by this library. \nProviders must implement the {@link SF.Permissions.Provider} interface.","comment":["--- Adds a provider implementation to the set used by this library.","-- Providers must implement the {@link SF.Permissions.Provider} interface.","-- @param provider the provider to be registered"],"code":["function P.registerProvider ( provider )","\tif type( provider ) ~= \"table\"","\t\t\tor type( provider.supportsOwner ) ~= \"function\"","\t\t\tor type( provider.isOwner ) ~= \"function\"","\t\t\tor type( provider.check ) ~= \"function\" then","\t\terror( \"given object does not implement the provider interface\", 2 )","\tend","","\tproviders[ provider ] = provider","","\tif provider:supportsOwner() then","\t\thave_owner = true","\tend","end",""],"private":false,"class":"function","name":"P.registerProvider","param":{"1":"provider","provider":"the provider to be registered"}},"P.registerPrivilege":{"summary":"\nRegisters a privilege ","description":"\nRegisters a privilege","comment":["--- Registers a privilege","-- @param id unique identifier of the privilege being registered","-- @param name Human readable name of the privilege","-- @param description a short description of the privilege"],"code":["function P.registerPrivilege ( id, name, description )","\tP.privileges[ id ] = { name = name, description = description }","","\t-- The second check is not really necessary, but since it will resolve to false most of the time, we can save some time","\tif SERVER and #player.GetAll() > 0 then","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tnet.Broadcast()","\tend","end","","-- Find and include all provider files.","do","\tlocal function IncludeClientFile ( file )","\t\tif SERVER then","\t\t\tAddCSLuaFile( file )","\t\telse","\t\t\tinclude( file )","\t\tend","\tend","","\tif SERVER then","\t\tinclude( \"starfall/permissions/provider.lua\" )","\tend","","\tIncludeClientFile( \"starfall/permissions/provider.lua\" )","","\tif SERVER then","\t\tlocal files = file.Find( \"starfall/permissions/providers_sv/*.lua\", \"LUA\" )","","\t\tfor _, file in pairs( files ) do","\t\t\tinclude( \"starfall/permissions/providers_sv/\" .. file )","\t\tend","\tend","","\tlocal sh_files = file.Find( \"starfall/permissions/providers_sh/*.lua\", \"LUA\" )","","\tfor _, file in pairs( sh_files ) do","\t\tif SERVER then","\t\t\tAddCSLuaFile( \"starfall/permissions/providers_sh/\" .. file )","\t\tend","\t\tinclude( \"starfall/permissions/providers_sh/\" .. file )","\tend","","\tlocal cl_files = file.Find( \"starfall/permissions/providers_cl/*.lua\", \"LUA\" )","","\tfor _, file in pairs( cl_files ) do","\t\tIncludeClientFile( \"starfall/permissions/providers_cl/\" .. file )","\tend","end","","-- Send serverside privileges to client","","--[[if SERVER then","\tlocal function sendPrivileges ( ply )","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tsendPrivileges()","","\thook.Add( \"PlayerInitialSpawn\", \"starfall_permissions\", sendPrivileges )","else","\tnet.Receive( \"starfall_permissions_privileges\", function ()","\t\tlocal len = net.ReadInt( 16 )","\t\tfor i = 1, len do","\t\t\tP.serverPrivileges[ net.ReadString() ] = { name = net.ReadString(), description = net.ReadString() }","\t\tend","\tend )","end]]"],"private":false,"class":"function","name":"P.registerPrivilege","param":{"1":"id","2":"name","3":"description","id":"unique identifier of the privilege being registered","name":"Human readable name of the privilege","description":"a short description of the privilege"}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Permissions management","---------------------------------------------------------------------"],"code":["","-- TODO: Client version",""],"summary":"\n \nSF Permissions management \n ","description":"\n \nSF Permissions management \n","param":[]},{"description":"\nPermission format","code":["","SF.Permissions = {}","","local P = SF.Permissions","P.__index = P","","P.privileges = {}","","if SERVER then","\tutil.AddNetworkString( \"starfall_permissions_privileges\" )","else","\tP.serverPrivileges = {}","end","","do","\tlocal lockmeta = {","\t\t__newindex = function ( table, key, value )","\t\t\terror( \"attempting to assign to a read-only table\", 2 )","\t\tend,","\t\t__metatable = \"constant\"","\t}","","\tlocal result_vals = {","\t\tDENY\t= setmetatable( {}, lockmeta ),","\t\tALLOW\t= setmetatable( {}, lockmeta ),","\t\tNEUTRAL\t= setmetatable( {}, lockmeta )","\t}","","\tP.Result = setmetatable( {}, {","\t\t__index = result_vals,","\t\t__newindex = lockmeta.__newindex,","\t\t__metatable = \"enum\"","\t} )","end","","local DENY = P.Result.DENY","local ALLOW = P.Result.ALLOW","local NEUTRAL = P.Result.NEUTRAL","","local providers = {}","","local have_owner = false",""],"class":"table","classForced":true,"name":"Permission","summary":"\nPermission format ","field":{"1":"name","2":"desc","3":"level","4":"value","value":"Boolean. True to allow, false to deny","level":"The abusability of the permission. 0 = low (print to console), \n1 = normal (modify entities), 2 = high (run arbitrary lua)","name":"The name of the permission","desc":"The description of the permission."},"comment":["--- Permission format","-- @name Permission","-- @class table","-- @field name The name of the permission","-- @field desc The description of the permission.","-- @field level The abusability of the permission. 0 = low (print to console),","--                1 = normal (modify entities), 2 = high (run arbitrary lua)","-- @field value Boolean. True to allow, false to deny"],"param":[]},{"summary":"\nAdds a provider implementation to the set used by this library.","description":"\nAdds a provider implementation to the set used by this library. \nProviders must implement the {@link SF.Permissions.Provider} interface.","comment":["--- Adds a provider implementation to the set used by this library.","-- Providers must implement the {@link SF.Permissions.Provider} interface.","-- @param provider the provider to be registered"],"code":["function P.registerProvider ( provider )","\tif type( provider ) ~= \"table\"","\t\t\tor type( provider.supportsOwner ) ~= \"function\"","\t\t\tor type( provider.isOwner ) ~= \"function\"","\t\t\tor type( provider.check ) ~= \"function\" then","\t\terror( \"given object does not implement the provider interface\", 2 )","\tend","","\tproviders[ provider ] = provider","","\tif provider:supportsOwner() then","\t\thave_owner = true","\tend","end",""],"private":false,"class":"function","name":"P.registerProvider","param":{"1":"provider","provider":"the provider to be registered"}},{"ret":"boolean whether the action is permitted","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return boolean whether the action is permitted"],"code":["function P.check ( principal, target, key )","\tif not P.privileges[ key ] then print( \"WARNING: Starfall privilege \" .. key .. \" was not registered!\" ) end","","\t-- server owners can do whatever they want","\tif have_owner then","\t\t-- this can't be merged into the check loop below because that","\t\tfor _, provider in pairs( providers ) do","\t\t\tif provider:isOwner( principal ) then return true end","\t\tend","\tend","","\tlocal allow = true","\tfor _, provider in pairs( providers ) do","\t\tlocal result = provider:check( principal, target, key )","\t\tif DENY == result then","\t\t\t-- a single deny overrides any allows, just deny it now","\t\t\treturn false","\t\telseif ALLOW == result then","\t\t\t-- an allow can be overridden by a deny, so remember and keep going","\t\t\tallow = true","\t\tend","\t\t-- otherwise, this provider has no opinion, just go on to the next one","\tend","","\treturn allow","end",""],"class":"function","name":"P.check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}},{"summary":"\nRegisters a privilege ","description":"\nRegisters a privilege","comment":["--- Registers a privilege","-- @param id unique identifier of the privilege being registered","-- @param name Human readable name of the privilege","-- @param description a short description of the privilege"],"code":["function P.registerPrivilege ( id, name, description )","\tP.privileges[ id ] = { name = name, description = description }","","\t-- The second check is not really necessary, but since it will resolve to false most of the time, we can save some time","\tif SERVER and #player.GetAll() > 0 then","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tnet.Broadcast()","\tend","end","","-- Find and include all provider files.","do","\tlocal function IncludeClientFile ( file )","\t\tif SERVER then","\t\t\tAddCSLuaFile( file )","\t\telse","\t\t\tinclude( file )","\t\tend","\tend","","\tif SERVER then","\t\tinclude( \"starfall/permissions/provider.lua\" )","\tend","","\tIncludeClientFile( \"starfall/permissions/provider.lua\" )","","\tif SERVER then","\t\tlocal files = file.Find( \"starfall/permissions/providers_sv/*.lua\", \"LUA\" )","","\t\tfor _, file in pairs( files ) do","\t\t\tinclude( \"starfall/permissions/providers_sv/\" .. file )","\t\tend","\tend","","\tlocal sh_files = file.Find( \"starfall/permissions/providers_sh/*.lua\", \"LUA\" )","","\tfor _, file in pairs( sh_files ) do","\t\tif SERVER then","\t\t\tAddCSLuaFile( \"starfall/permissions/providers_sh/\" .. file )","\t\tend","\t\tinclude( \"starfall/permissions/providers_sh/\" .. file )","\tend","","\tlocal cl_files = file.Find( \"starfall/permissions/providers_cl/*.lua\", \"LUA\" )","","\tfor _, file in pairs( cl_files ) do","\t\tIncludeClientFile( \"starfall/permissions/providers_cl/\" .. file )","\tend","end","","-- Send serverside privileges to client","","--[[if SERVER then","\tlocal function sendPrivileges ( ply )","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tsendPrivileges()","","\thook.Add( \"PlayerInitialSpawn\", \"starfall_permissions\", sendPrivileges )","else","\tnet.Receive( \"starfall_permissions_privileges\", function ()","\t\tlocal len = net.ReadInt( 16 )","\t\tfor i = 1, len do","\t\t\tP.serverPrivileges[ net.ReadString() ] = { name = net.ReadString(), description = net.ReadString() }","\t\tend","\tend )","end]]"],"private":false,"class":"function","name":"P.registerPrivilege","param":{"1":"id","2":"name","3":"description","id":"unique identifier of the privilege being registered","name":"Human readable name of the privilege","description":"a short description of the privilege"}}],"tables":{"1":"Permission","Permission":{"description":"\nPermission format","code":["","SF.Permissions = {}","","local P = SF.Permissions","P.__index = P","","P.privileges = {}","","if SERVER then","\tutil.AddNetworkString( \"starfall_permissions_privileges\" )","else","\tP.serverPrivileges = {}","end","","do","\tlocal lockmeta = {","\t\t__newindex = function ( table, key, value )","\t\t\terror( \"attempting to assign to a read-only table\", 2 )","\t\tend,","\t\t__metatable = \"constant\"","\t}","","\tlocal result_vals = {","\t\tDENY\t= setmetatable( {}, lockmeta ),","\t\tALLOW\t= setmetatable( {}, lockmeta ),","\t\tNEUTRAL\t= setmetatable( {}, lockmeta )","\t}","","\tP.Result = setmetatable( {}, {","\t\t__index = result_vals,","\t\t__newindex = lockmeta.__newindex,","\t\t__metatable = \"enum\"","\t} )","end","","local DENY = P.Result.DENY","local ALLOW = P.Result.ALLOW","local NEUTRAL = P.Result.NEUTRAL","","local providers = {}","","local have_owner = false",""],"class":"table","classForced":true,"name":"Permission","summary":"\nPermission format ","field":{"1":"name","2":"desc","3":"level","4":"value","value":"Boolean. True to allow, false to deny","level":"The abusability of the permission. 0 = low (print to console), \n1 = normal (modify entities), 2 = high (run arbitrary lua)","name":"The name of the permission","desc":"The description of the permission."},"comment":["--- Permission format","-- @name Permission","-- @class table","-- @field name The name of the permission","-- @field desc The description of the permission.","-- @field level The abusability of the permission. 0 = low (print to console),","--                1 = normal (modify entities), 2 = high (run arbitrary lua)","-- @field value Boolean. True to allow, false to deny"],"param":[]}},"description":"\n \nSF Permissions management \n","summary":"\n \nSF Permissions management \n "},"database.lua":{"type":"file","name":"database.lua","functions":[],"doc":[],"libraries":[],"tables":[]},"libs_sh/physenv.lua":{"libraries":{"1":"physenv","physenv":{"comment":["--- Physenv functions","-- @shared"],"functions":{"1":"getAirDensity","2":"getGravity","3":"getPerformanceSettings","getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},"getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]}},"class":"library","summary":"\nPhysenv functions ","code":["local physenv_lib, _ = SF.Libraries.Register( \"physenv\" )",""],"fields":[],"name":"physenv","client":true,"description":"\nPhysenv functions","libtbl":"physenv_lib","tables":[],"server":true}},"type":"file","name":"libs_sh/physenv.lua","functions":{"1":"physenv_lib.getAirDensity","2":"physenv_lib.getGravity","3":"physenv_lib.getPerformanceSettings","physenv_lib.getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]},"physenv_lib.getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"physenv_lib.getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]}},"doc":[{"summary":"\n \nPhysenv library \n ","description":"\n \nPhysenv library \n","comment":["-------------------------------------------------------------------------------","-- Physenv library","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Physenv functions","-- @shared"],"functions":{"1":"getAirDensity","2":"getGravity","3":"getPerformanceSettings","getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},"getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]}},"class":"library","summary":"\nPhysenv functions ","code":["local physenv_lib, _ = SF.Libraries.Register( \"physenv\" )",""],"fields":[],"name":"physenv","client":true,"description":"\nPhysenv functions","libtbl":"physenv_lib","tables":[],"server":true},{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]},{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]}],"tables":[],"description":"\n \nPhysenv library \n","summary":"\n \nPhysenv library \n "},"sflib.lua":{"libraries":[],"type":"file","name":"sflib.lua","functions":{"1":"SF.AddObjectUnwrapper","2":"SF.AddObjectWrapper","3":"SF.BurstObject","4":"SF.CheckType","5":"SF.CreateContext","6":"SF.CreateWrapper","7":"SF.DeserializeCode","8":"SF.EntityTable","9":"SF.GetType","10":"SF.RequestCode","11":"SF.RunScriptHook","12":"SF.Sanitize","13":"SF.SerializeCode","14":"SF.Typedef","15":"SF.Unsanitize","16":"SF.UnwrapObject","17":"SF.WrapFunction","18":"SF.WrapObject","19":"SF.WrappedFunctionInstance","20":"SF.throw","SF.AddObjectUnwrapper":{"summary":"\nHelper function for adding custom unwrappers ","description":"\nHelper function for adding custom unwrappers","comment":["--- Helper function for adding custom unwrappers","-- @param object_meta metatable of object","-- @param unwrapper function that unwraps object"],"code":["function SF.AddObjectUnwrapper( object_meta, unwrapper )","\tobject_meta.__unwrap = unwrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectUnwrapper","param":{"1":"object_meta","2":"unwrapper","unwrapper":"function that unwraps object","object_meta":"metatable of object"}},"SF.CreateContext":{"summary":"\nCreates a new context.","description":"\nCreates a new context. A context is used to define what scripts will have access to.","comment":["--- Creates a new context. A context is used to define what scripts will have access to.","-- @param env The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","-- @param directives Additional Preprocessor directives to use. Default is an empty table","-- @param cpuTime Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","-- @param libs Additional (local) libraries for the script to access. Default is an empty table."],"code":["function SF.CreateContext ( env, directives, cpuTime, libs )","\tlocal context = {}","\tcontext.env = env or SF.DefaultEnvironmentMT","\tcontext.directives = directives or {}","\tcontext.cpuTime = cpuTime or {","\t\tgetBufferN = function () return SF.cpuBufferN:GetInt() or 3 end,","\t\tgetMax = function () return SF.cpuQuota:GetFloat() end","\t}","\tcontext.libs = libs or {}","\treturn context","end",""],"private":false,"class":"function","name":"SF.CreateContext","param":{"1":"env","2":"directives","3":"cpuTime","4":"libs","env":"The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","directives":"Additional Preprocessor directives to use. Default is an empty table","cpuTime":"Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","libs":"Additional (local) libraries for the script to access. Default is an empty table."}},"SF.SerializeCode":{"summary":"\nSerializes an instance's code in a format compatible with the duplicator library ","description":"\nSerializes an instance's code in a format compatible with the duplicator library","comment":["--- Serializes an instance's code in a format compatible with the duplicator library","-- @param sources The table of filename = source entries. Ususally instance.source","-- @param mainfile The main filename. Usually instance.mainfile"],"code":["function SF.SerializeCode(sources, mainfile)","\tlocal rt = {source = {}}","\tfor filename, source in pairs(sources) do","\t\trt.source[filename] = string.gsub(source, serialize_replace_regex, serialize_replace_tbl)","\tend","\trt.mainfile = mainfile","\treturn rt","end","","local deserialize_replace_regex = \"[\" .. string.char( 5 ) .. string.char( 4 ) .. \"]\"","local deserialize_replace_tbl = { [ string.char( 5 )[ 1 ] ] = \"\\n\", [ string.char( 4 )[ 1 ] ] = '\"' }"],"private":false,"class":"function","name":"SF.SerializeCode","param":{"1":"sources","2":"mainfile","mainfile":"The main filename. Usually instance.mainfile","sources":"The table of filename = source entries. Ususally instance.source"}},"SF.Typedef":{"ret":["The table to store normal methods","The table to store metamethods"],"comment":["--- Creates a type that is safe for SF scripts to use. Instances of the type","-- cannot access the type's metatable or metamethods.","-- @param name Name of table","-- @param supermeta The metatable to inheret from","-- @return The table to store normal methods","-- @return The table to store metamethods"],"code":["function SF.Typedef(name, supermeta)","\t--Keep the original type so we don't screw up inheritance","\tif SF.Types[name] then","\t\treturn SF.Types[name].__methods, SF.Types[name]","\tend","","\tlocal methods, metamethods = {}, {}","\tmetamethods.__metatable = name","\tmetamethods.__index = methods","\tmetamethods.__methods = methods","\t","\tmetamethods.__supertypes = {[metamethods] = true}","\t","\tif supermeta then","\t\tsetmetatable(methods, {__index=supermeta.__index})","\t\tmetamethods.__supertypes[supermeta] = true","\t\tif supermeta.__supertypes then","\t\t\tfor k,_ in pairs(supermeta.__supertypes) do","\t\t\t\tmetamethods.__supertypes[k] = true","\t\t\tend","\t\tend","\tend","","\tSF.Types[name] = metamethods","\ttypemetatables[ metamethods ] = true","\treturn methods, metamethods","end","","function SF.GetTypeDef( name )","\treturn SF.Types[name]","end","","-- Include this file after Typedef as this file relies on it.","include(\"callback.lua\")","","do","\tlocal env, metatable = SF.Typedef(\"Environment\")"],"class":"function","name":"SF.Typedef","private":false,"summary":"\nCreates a type that is safe for SF scripts to use.","description":"\nCreates a type that is safe for SF scripts to use. Instances of the type \ncannot access the type's metatable or metamethods.","param":{"1":"name","2":"supermeta","name":"Name of table","supermeta":"The metatable to inheret from"}},"SF.AddObjectWrapper":{"summary":"\nHelper function for adding custom wrappers ","description":"\nHelper function for adding custom wrappers","comment":["--- Helper function for adding custom wrappers","-- @param object_meta metatable of object","-- @param sf_object_meta starfall metatable of object","-- @param wrapper function that wraps object"],"code":["function SF.AddObjectWrapper( object_meta, sf_object_meta, wrapper )","\tsf_object_meta.__wrap = wrapper","\tobject_wrappers[object_meta] = wrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectWrapper","param":{"1":"object_meta","2":"sf_object_meta","3":"wrapper","sf_object_meta":"starfall metatable of object","wrapper":"function that wraps object","object_meta":"metatable of object"}},"SF.Unsanitize":{"summary":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment ","description":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment","comment":["--- Takes output from starfall and does it's best to make the output","-- fully usable outside of starfall environment"],"code":["function SF.Unsanitize( ... )","\tlocal return_list = {}","\t","\tlocal args = {...}","\t","\tfor key, value in pairs( args ) do","\t\tlocal typ = type(value)","\t\tif typ == \"table\" and SF.UnwrapObject(value) then","\t\t\treturn_list[key] = SF.UnwrapObject(value)","\t\telseif typ == \"table\" then","\t\t\treturn_list[key] = {}","","\t\t\tfor k,v in pairs(value) do","\t\t\t\treturn_list[key][SF.Unsanitize(k)] = SF.Unsanitize(v)","\t\t\tend","\t\telse","\t\t\treturn_list[key] = value","\t\tend","\tend","","\treturn unpack( return_list )","end","","-- ------------------------------------------------------------------------- --","","local function isnan(n)","\treturn n ~= n","end","","-- Taken from E2Lib","","-- This function clamps the position before moving the entity","local minx, miny, minz = -16384, -16384, -16384","local maxx, maxy, maxz = 16384, 16384, 16384","local clamp = math.Clamp","local function clampPos(pos)","\tpos.x = clamp(pos.x, minx, maxx)","\tpos.y = clamp(pos.y, miny, maxy)","\tpos.z = clamp(pos.z, minz, maxz)","\treturn pos","end","","function SF.setPos(ent, pos)","\tif isnan(pos.x) or isnan(pos.y) or isnan(pos.z) then return end","\treturn ent:SetPos(clampPos(pos))","end","","local huge, abs = math.huge, math.abs","function SF.setAng(ent, ang)","\tif isnan(ang.pitch) or isnan(ang.yaw) or isnan(ang.roll) then return end","\tif abs(ang.pitch) == huge or abs(ang.yaw) == huge or abs(ang.roll) == huge then return false end -- SetAngles'ing inf crashes the server","\treturn ent:SetAngles(ang)","end","","-- ------------------------------------------------------------------------- --","","local serialize_replace_regex = \"[\\\"\\n]\"","local serialize_replace_tbl = { [ \"\\n\" ] = string.char( 5 ), [ '\"' ] = string.char( 4 ) }",""],"private":false,"class":"function","name":"SF.Unsanitize","param":["..."]},"SF.GetType":{"summary":"\nGets the type of val.","description":"\nGets the type of val.","comment":["--- Gets the type of val.","-- @param val The value to be checked."],"code":["function SF.GetType( val )","\tlocal mt = dgetmeta(val)","\treturn (mt and mt.__metatable and type(mt.__metatable) == \"string\") and mt.__metatable or type(val)","end","","-- ------------------------------------------------------------------------- --","","local object_wrappers = {}","local sensitive2sf_tables = {}","local sf2sensitive_tables = {}",""],"private":false,"class":"function","name":"SF.GetType","param":{"1":"val","val":"The value to be checked."}},"SF.EntityTable":{"summary":"\nManages data tied to entities so that the data is cleaned when the entity is removed ","description":"\nManages data tied to entities so that the data is cleaned when the entity is removed","comment":["--- Manages data tied to entities so that the data is cleaned when the entity is removed"],"code":["function SF.EntityTable( key )","\treturn setmetatable({}, ","\t{__newindex = function(t, e, v)","\t\trawset(t, e, v)","\t\te:CallOnRemove(\"SF_\" .. key, function() t[e] = nil end)","\tend})","end",""],"private":false,"class":"function","name":"SF.EntityTable","param":["key"]},"SF.throw":{"summary":"\nThrows an error like the throw function in builtins ","description":"\nThrows an error like the throw function in builtins","comment":["--- Throws an error like the throw function in builtins","-- @param msg Message","-- @param level Which level in the stacktrace to blame","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" ) or info.short_src","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end","","SF.Types = {}","local typemetatables = {}"],"private":false,"class":"function","name":"SF.throw","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame"}},"SF.RunScriptHook":{"summary":"\nCalls a script hook on all processors.","description":"\nCalls a script hook on all processors.","comment":["--- Calls a script hook on all processors."],"code":["function SF.RunScriptHook(hook,...)","\tfor _,instance in pairs(SF.allInstances) do","\t\tif not instance.error then","\t\t\tlocal ok, err = instance:runScriptHook(hook,...)","\t\t\tif not ok then","\t\t\t\tinstance.error = true","\t\t\t\tif instance.runOnError then","\t\t\t\t\tinstance:runOnError( err )","\t\t\t\tend","\t\t\tend","\t\tend","\tend","end",""],"private":false,"class":"function","name":"SF.RunScriptHook","param":["hook","..."]},"SF.UnwrapObject":{"ret":"the unwrapped starfall object","comment":["--- Takes a wrapped starfall object and returns the unwrapped version","-- @param object the wrapped starfall object, should work on any starfall","-- wrapped object.","-- @return the unwrapped starfall object"],"code":["function SF.UnwrapObject( object )","\tlocal metatable = dgetmeta(object)","\t","\tif metatable and metatable.__unwrap then","\t\treturn metatable.__unwrap( object )","\tend","end",""],"class":"function","name":"SF.UnwrapObject","private":false,"summary":"\nTakes a wrapped starfall object and returns the unwrapped version ","description":"\nTakes a wrapped starfall object and returns the unwrapped version","param":{"1":"object","object":"the wrapped starfall object, should work on any starfall \nwrapped object."}},"SF.Sanitize":{"summary":"\nSanitizes and returns its argument list.","description":"\nSanitizes and returns its argument list. \nBasic types are returned unchanged. Non-object tables will be \nrecursed into and their keys and values will be sanitized. Object \ntypes will be wrapped if a wrapper is available. When a wrapper is \nnot available objects will be replaced with nil, so as to prevent \nany possiblitiy of leakage. Functions will always be replaced with \nnil as there is no way to verify that they are safe.","comment":["--- Sanitizes and returns its argument list.","-- Basic types are returned unchanged. Non-object tables will be","-- recursed into and their keys and values will be sanitized. Object","-- types will be wrapped if a wrapper is available. When a wrapper is","-- not available objects will be replaced with nil, so as to prevent","-- any possiblitiy of leakage. Functions will always be replaced with","-- nil as there is no way to verify that they are safe."],"code":["function SF.Sanitize( ... )","\t-- Sanitize ALL the things.","\tlocal return_list = {}","\tlocal args = { ... }","\t","\tfor key, value in pairs( args ) do","\t\tlocal typmeta = getmetatable( value )","\t\tlocal typ = type( typmeta ) == \"string\" and typmeta or type( value )","\t\tif safe_types[ typ ] then","\t\t\treturn_list[ key ] = value","\t\telseif SF.WrapObject( value ) then","\t\t\treturn_list[ key ] = SF.WrapObject( value )","\t\telseif typ == \"table\" then","\t\t\tlocal tbl = {}","\t\t\tfor k,v in pairs( value ) do","\t\t\t\ttbl[ SF.Sanitize( k ) ] = SF.Sanitize( v )","\t\t\tend","\t\t\treturn_list[ key ] = tbl","\t\telse ","\t\t\treturn_list[ key ] = nil","\t\tend","\tend","\t","\treturn unpack( return_list )","end",""],"private":false,"class":"function","name":"SF.Sanitize","param":["..."]},"SF.CreateWrapper":{"ret":["The function to wrap sensitive values to a SF-safe table","The function to unwrap the SF-safe table to the sensitive table"],"comment":["--- Creates wrap/unwrap functions for sensitive values, by using a lookup table","-- (which is set to have weak keys and values)","-- @param metatable The metatable to assign the wrapped value.","-- @param weakwrapper Make the wrapper weak inside the internal lookup table. Default: True","-- @param weaksensitive Make the sensitive data weak inside the internal lookup table. Default: True","-- @param target_metatable (optional) The metatable of the object that will get","-- \t\twrapped by these wrapper functions.  This is required if you want to","-- \t\thave the object be auto-recognized by the generic SF.WrapObject","--\t\tfunction.","-- @return The function to wrap sensitive values to a SF-safe table","-- @return The function to unwrap the SF-safe table to the sensitive table"],"code":["function SF.CreateWrapper(metatable, weakwrapper, weaksensitive, target_metatable, shared_meta)","\tlocal s2sfmode = \"\"","\tlocal sf2smode = \"\"","\t","\tif weakwrapper == nil or weakwrapper then","\t\tsf2smode = \"k\"","\t\ts2sfmode = \"v\"","\tend","\tif weaksensitive then","\t\tsf2smode = sf2smode..\"v\"","\t\ts2sfmode = s2sfmode..\"k\"","\tend ","","\tlocal sensitive2sf, sf2sensitive","\tif shared_meta then","\t\tsensitive2sf = sensitive2sf_tables[ shared_meta ]","\t\tsf2sensitive = sf2sensitive_tables[ shared_meta ]","\telse","\t\tsensitive2sf = setmetatable({},{__mode=s2sfmode})","\t\tsf2sensitive = setmetatable({},{__mode=sf2smode})","\t\tsensitive2sf_tables[ metatable ] = sensitive2sf","\t\tsf2sensitive_tables[ metatable ] = sf2sensitive","\tend","\t","\tlocal function wrap(value)","\t\tif value == nil then return nil end","\t\tif sensitive2sf[value] then return sensitive2sf[value] end","\t\tlocal tbl = setmetatable({},metatable)","\t\tsensitive2sf[value] = tbl","\t\tsf2sensitive[tbl] = value","\t\treturn tbl","\tend","\t","\tlocal function unwrap(value)","\t\treturn sf2sensitive[value]","\tend","\t","\tif target_metatable ~= nil then","\t\tobject_wrappers[target_metatable] = wrap","\t\tmetatable.__wrap = wrap","\tend","\t","\tmetatable.__unwrap = unwrap","\t","\treturn wrap, unwrap","end",""],"class":"function","name":"SF.CreateWrapper","private":false,"summary":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values) ","description":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values)","param":{"1":"metatable","2":"weakwrapper","3":"weaksensitive","4":"target_metatable","5":"shared_meta","target_metatable":"(optional) The metatable of the object that will get \nwrapped by these wrapper functions.  This is required if you want to \nhave the object be auto-recognized by the generic SF.WrapObject \nfunction.","metatable":"The metatable to assign the wrapped value.","weaksensitive":"Make the sensitive data weak inside the internal lookup table. Default: True","weakwrapper":"Make the wrapper weak inside the internal lookup table. Default: True"}},"SF.RequestCode":{"ret":"True if the code was requested, false if an incomplete request is still in progress for that player","comment":["\t--- Requests a player to send whatever code they have open in his/her editor to","\t-- the server.","\t-- @server","\t-- @param ply Player to request code from","\t-- @param callback Called when all of the code is recieved. Arguments are either the main filename and a table","\t-- of filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)","\t-- @return True if the code was requested, false if an incomplete request is still in progress for that player"],"code":["\tfunction SF.RequestCode(ply, callback)","\t\tif uploaddata[ply] and uploaddata[ply].timeout > CurTime() then return false end","\t\t","\t\tnet.Start(\"starfall_requpload\")","\t\tnet.Send(ply)","","\t\tuploaddata[ply] = {","\t\t\tfiles={},","\t\t\tmainfile = nil,","\t\t\tneedHeader=true,","\t\t\tcallback = callback,","\t\t\ttimeout = CurTime() + 1","\t\t}","\t\treturn true","\tend","\t","\tnet.Receive(\"starfall_upload\", function(len, ply)","\t\tlocal updata = uploaddata[ply]","\t\tif not updata then","\t\t\tErrorNoHalt(\"SF: Player \"..ply:GetName()..\" tried to upload code without being requested (expect this message multiple times)\\n\")","\t\t\treturn","\t\tend","\t\t","\t\tupdata.mainfile = net.ReadString()","\t\t","\t\tlocal I = 0","\t\twhile I < 256 do","\t\t\tif net.ReadBit() ~= 0 then break end","\t\t\tlocal filename = net.ReadString()","","\t\t\tnet.ReadStream( ply, function( data )","\t\t\t\tupdata.Completed = updata.Completed + 1","\t\t\t\tupdata.files[ filename ] = data","\t\t\t\tif updata.Completed == updata.NumFiles then","\t\t\t\t\tupdata.callback(updata.mainfile, updata.files)","\t\t\t\t\tuploaddata[ply] = nil","\t\t\t\tend","\t\t\tend )","\t\t\tI = I + 1","\t\tend","","\t\tupdata.Completed = 0","\t\tupdata.NumFiles = I","\t\t","\t\tif I == 0 then","\t\t\tuploaddata[ply] = nil","\t\tend","\tend)","","\tfunction SF.AddNotify ( ply, msg, notifyType, duration, sound )","\t\tif not IsValid( ply ) then return end","","\t\tnet.Start( \"starfall_addnotify\" )","\t\tnet.WriteString( msg )","\t\tnet.WriteUInt( notifyType, 8 or 0, 8 )","\t\tnet.WriteFloat( duration )","\t\tnet.WriteUInt( sound, 8 or 0, 8 )","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tfunction SF.Print ( ply, msg )","\t\tnet.Start( \"starfall_console_print\" )","\t\t\tnet.WriteString( msg )","\t\tnet.Send( ply )","\tend","else","\tnet.Receive(\"starfall_openeditor\",function(len)\t\t","\t\tSF.Editor.open()","\t\t","\t\tlocal gate = net.ReadEntity()","\t\t","\t\thook.Add(\"Think\",\"WaitForEditor\",function()","\t\t\tif SF.Editor.initialized then","\t\t\t\tif IsValid(gate) and gate.files then","\t\t\t\t\tfor name, code in pairs(gate.files) do","\t\t\t\t\t\tlocal found = false","\t\t\t\t\t\tfor _, tab in pairs(SF.Editor.getTabHolder().tabs) do","\t\t\t\t\t\t\tif tab.filename == name and tab.code == code then","\t\t\t\t\t\t\t\tfound = tab","\t\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t\tend","\t\t\t\t\t\tend","\t\t\t\t\t\tif found then","\t\t\t\t\t\t\tSF.Editor.selectTab( found )","\t\t\t\t\t\telse","\t\t\t\t\t\t\tSF.Editor.addTab( name, code )","\t\t\t\t\t\tend","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\thook.Remove(\"Think\",\"WaitForEditor\")","\t\t\tend","\t\tend)","\tend)","\t","\tnet.Receive(\"starfall_requpload\", function(len)","\t\tlocal ok, list = SF.Editor.BuildIncludesTable()","\t\tif ok then","\t\t\t--print(\"Uploading SF code\")","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteString(list.mainfile)","\t\t\t","\t\t\tfor name, data in pairs( list.files ) do","\t\t\t\tnet.WriteBit( false )","\t\t\t\tnet.WriteString( name )","\t\t\t\tnet.WriteStream( data )","\t\t\tend","","\t\t\tnet.WriteBit( true )","\t\t\tnet.SendToServer()","\t\t\t--print(\"Done sending\")","\t\telse","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteString(\"\")","\t\t\tnet.WriteBit(false)","\t\t\tnet.SendToServer()","\t\t\tif list then","\t\t\t\tSF.AddNotify( LocalPlayer(), list, NOTIFY_ERROR, 7, NOTIFYSOUND_ERROR1 )","\t\t\tend","\t\tend","\tend)","","\tlocal sounds = {","\t\t[ NOTIFYSOUND_DRIP1 ] = \"ambient/water/drip1.wav\",","\t\t[ NOTIFYSOUND_DRIP2 ] = \"ambient/water/drip2.wav\",","\t\t[ NOTIFYSOUND_DRIP3 ] = \"ambient/water/drip3.wav\",","\t\t[ NOTIFYSOUND_DRIP4 ] = \"ambient/water/drip4.wav\",","\t\t[ NOTIFYSOUND_DRIP5 ] = \"ambient/water/drip5.wav\",","\t\t[ NOTIFYSOUND_ERROR1 ] = \"buttons/button10.wav\",","\t\t[ NOTIFYSOUND_CONFIRM1 ] = \"buttons/button3.wav\",","\t\t[ NOTIFYSOUND_CONFIRM2 ] = \"buttons/button14.wav\",","\t\t[ NOTIFYSOUND_CONFIRM3 ] = \"buttons/button15.wav\",","\t\t[ NOTIFYSOUND_CONFIRM4 ] = \"buttons/button17.wav\"","\t}","","\tfunction SF.AddNotify ( ply, msg, type, duration, sound )","\t\tif not IsValid( ply ) then return end","","\t\tif ply ~= LocalPlayer() then","\t\t\treturn","\t\tend","","\t\tprint( msg )","","\t\tlocal newline = string.find( msg, \"\\n\" )","\t\tif newline then","\t\t\tmsg = string.sub( msg, 1, newline - 1 )","\t\tend","\t\t","\t\tGAMEMODE:AddNotify( msg, type, duration )","","\t\tif sound and sounds[ sound ] then","\t\t\tsurface.PlaySound( sounds[ sound ] )","\t\tend","\tend","","\tnet.Receive( \"starfall_addnotify\", function ()","\t\tSF.AddNotify( LocalPlayer(), net.ReadString(), net.ReadUInt( 8 ), net.ReadFloat(), net.ReadUInt( 8 ) )","\tend )","","\tnet.Receive( \"starfall_console_print\", function ()","\t\tprint( net.ReadString() )","\tend )","end","","-- ------------------------------------------------------------------------- --","","local function cleanHooks( file )","\tfor k, v in pairs(SF.Libraries.hooks) do","\t\tlocal i = 1","\t\twhile i <= #v do","\t\t\tlocal hookfile = string.lower(string.sub(string.GetFileFromFilename( debug.getinfo( v[i], \"S\" ).short_src or \"\" ), 1, -5))","\t\t\tif file == hookfile then","\t\t\t\ttable.remove( v, i )","\t\t\telse","\t\t\t\ti = i + 1","\t\t\tend","\t\tend","\tend","end","","if SERVER then","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\t\tAddCSLuaFile(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading SF server-side libraries\")","\tl = file.Find(\"starfall/libs_sv/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sv/\"..filename)","\tend","\tMsgN(\"- End loading server-side libraries\")","","\t","\tMsgN(\"- Adding client-side libraries to send list\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Adding \"..filename)","\t\tAddCSLuaFile(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","\t","\tMsgN(\"-End Loading SF Libraries\")","\t","\t-- Command to reload the libraries","\tutil.AddNetworkString(\"sf_reloadlibrary\")","\tconcommand.Add(\"sf_reloadlibrary\", function(ply, com, arg)","\t\tif ply:IsValid() and not ply:IsSuperAdmin() then return end","\t\tlocal filename = arg[1]","\t\tif not filename then return end","\t\tfilename = string.lower( filename )","\t\t","\t\tlocal function sendToClient(name)","\t\t\tnet.Start(\"sf_reloadlibrary\")","\t\t\tlocal data = util.Compress(file.Read(name,\"LUA\"))","\t\t\tnet.WriteString(filename)","\t\t\tnet.WriteStream( data )","\t\t\tnet.Broadcast()","\t\tend","\t\t","\t\tlocal sv_filename = \"starfall/libs_sv/\"..filename..\".lua\"","\t\tlocal sh_filename = \"starfall/libs_sh/\"..filename..\".lua\"","\t\tlocal cl_filename = \"starfall/libs_cl/\"..filename..\".lua\"","\t\t","\t\tcleanHooks( filename )","\t\t","\t\tlocal postload","\t\tif file.Exists( sh_filename, \"LUA\" ) then","\t\t\tprint(\"Reloaded library: \" .. filename)","\t\t\tinclude(sh_filename)","\t\t\tsendToClient(sh_filename)","\t\t\tpostload = true","\t\tend","\t\tif file.Exists( sv_filename, \"LUA\" ) then","\t\t\tprint(\"Reloaded library: \" .. filename)","\t\t\tinclude(sv_filename)","\t\t\tpostload = true","\t\tend","\t\tif file.Exists( cl_filename, \"LUA\" ) then","\t\t\tsendToClient(cl_filename)","\t\tend","\t\tif postload then","\t\t\tSF.Libraries.CallHook(\"postload\")","\t\tend","\tend)","\t","else","","\tnet.Receive(\"sf_reloadlibrary\", function(len)","\t\tlocal name = net.ReadString()","\t\tnet.ReadStream( nil, function( data )","\t\t\tlocal file = util.Decompress( data )","\t\t\tif file then","\t\t\t\tprint(\"Reloaded library: \" .. name)","\t\t\t\tcleanHooks( name )","\t\t\t\tlocal func = CompileString( file, \"starfall/\" .. name .. \".lua\" )","\t\t\t\tfunc()","\t\t\t\tSF.Libraries.CallHook(\"postload\")","\t\t\tend","\t\tend )","\tend)","","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading client-side libraries\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","","\t","\tMsgN(\"-End Loading SF Libraries\")","end","","SF.Libraries.CallHook(\"postload\")"],"class":"function","name":"SF.RequestCode","summary":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","private":false,"server":true,"description":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","param":{"1":"ply","2":"callback","ply":"Player to request code from","callback":"Called when all of the code is recieved. Arguments are either the main filename and a table \nof filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)"}},"SF.BurstObject":{"summary":"\nReturns a class that can keep track of burst ","description":"\nReturns a class that can keep track of burst","comment":["--- Returns a class that can keep track of burst"],"code":["function SF.BurstObject( rate, max )","\tlocal burstclass = {","\t\tuse = function(self, amount)","\t\t\tself:check()","\t\t\tif self.val>= amount then","\t\t\t\tself.val = self.val - amount","\t\t\t\treturn true","\t\t\tend","\t\t\treturn false","\t\tend,","\t\tcheck = function(self)","\t\t\tself.val = math.min( self.val + (CurTime() - self.lasttick)*self.rate, self.max )","\t\t\tself.lasttick = CurTime()","\t\t\treturn self.val","\t\tend","\t}","\tlocal t = {","\t\trate = rate, ","\t\tmax = max,","\t\tval = max,","\t\tlasttick = 0","\t}","\treturn setmetatable(t, {__index=burstclass})","end","","local wrappedfunctions = setmetatable({},{__mode=\"kv\"})","local wrappedfunctions2instance = setmetatable({},{__mode=\"kv\"})"],"private":false,"class":"function","name":"SF.BurstObject","param":["rate","max"]},"SF.DeserializeCode":{"ret":["The table of filename = source entries","The main filename"],"comment":["--- Deserializes an instance's code.","-- @return The table of filename = source entries","-- @return The main filename"],"code":["function SF.DeserializeCode(tbl)","\tlocal sources = {}","\tfor filename, source in pairs(tbl.source) do","\t\tsources[filename] = string.gsub(source, deserialize_replace_regex, deserialize_replace_tbl)","\tend","\treturn sources, tbl.mainfile","end","","-- ------------------------------------------------------------------------- --","","if SERVER then","\tutil.AddNetworkString(\"starfall_requpload\")","\tutil.AddNetworkString(\"starfall_upload\")","\tutil.AddNetworkString( \"starfall_addnotify\" )","\tutil.AddNetworkString( \"starfall_console_print\" )","\tutil.AddNetworkString( \"starfall_openeditor\" )","\t","\tlocal uploaddata = SF.EntityTable( \"sfTransfer\" )",""],"class":"function","name":"SF.DeserializeCode","private":false,"summary":"\nDeserializes an instance's code.","description":"\nDeserializes an instance's code.","param":["tbl"]},"SF.WrappedFunctionInstance":{"ret":"Instance","comment":["--- Gets the instance a wrapped function is bound to","-- @param func Function","-- @return Instance"],"code":["function SF.WrappedFunctionInstance(func)","\treturn wrappedfunctions2instance[func]","end","","-- A list of safe data types","local safe_types = {","\t[\"number\"  ] = true,","\t[\"string\"  ] = true,","\t[\"Vector\"  ] = false,","\t[\"Color\"   ] = false,","\t[\"Angle\"   ] = false,","\t[\"Entity\"  ] = false,","\t[\"VMatrix\" ] = false,","\t[\"boolean\" ] = true,","\t[\"nil\"     ] = true,","}",""],"class":"function","name":"SF.WrappedFunctionInstance","private":false,"summary":"\nGets the instance a wrapped function is bound to ","description":"\nGets the instance a wrapped function is bound to","param":{"1":"func","func":"Function"}},"SF.WrapObject":{"ret":"returns nil if the object doesn't have a known wrapper, \nor returns the wrapped object if it does have a wrapper.","comment":["--- Wraps the given object so that it is safe to pass into starfall","-- It will wrap it as long as we have the metatable of the object that is","-- getting wrapped.","-- @param object the object needing to get wrapped as it's passed into starfall","-- @return returns nil if the object doesn't have a known wrapper,","-- or returns the wrapped object if it does have a wrapper."],"code":["function SF.WrapObject( object )","\tlocal metatable = dgetmeta(object)","\tif not metatable and type(object)~=\"table\" then return object end","\tlocal wrap = object_wrappers[metatable]","\treturn wrap and wrap(object)","end",""],"class":"function","name":"SF.WrapObject","private":false,"summary":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","description":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","param":{"1":"object","object":"the object needing to get wrapped as it's passed into starfall"}},"SF.WrapFunction":{"ret":"a function That when called will call the wrapped starfall function","comment":["--- Wraps the given starfall function so that it may called directly by GMLua","-- @param func The starfall function getting wrapped","-- @param instance The instance the function originated from","-- @return a function That when called will call the wrapped starfall function"],"code":["function SF.WrapFunction( func, instance )","\tif wrappedfunctions[func] then return wrappedfunctions[func] end","\t","\tlocal function returned_func( ... )","\t\treturn SF.Unsanitize( instance:runFunction( func, SF.Sanitize(...) ) )","\tend","\twrappedfunctions[func] = returned_func","\twrappedfunctions2instance[returned_func] = instance","\t","\treturn returned_func","end",""],"class":"function","name":"SF.WrapFunction","private":false,"summary":"\nWraps the given starfall function so that it may called directly by GMLua ","description":"\nWraps the given starfall function so that it may called directly by GMLua","param":{"1":"func","2":"instance","func":"The starfall function getting wrapped","instance":"The instance the function originated from"}},"SF.CheckType":{"summary":"\nChecks the type of val.","description":"\nChecks the type of val. Errors if the types don't match","comment":["--- Checks the type of val. Errors if the types don't match","-- @param val The value to be checked.","-- @param typ A string type or metatable.","-- @param level Level at which to error at. 3 is added to this value. Default is 0.","-- @param default A value to return if val is nil."],"code":["function SF.CheckType(val, typ, level, default)","\tlocal meta = dgetmeta(val)","\tif meta == typ or (meta and typemetatables[meta] and meta.__supertypes and meta.__supertypes[typ]) or type(val) == typ then ","\t\treturn val","\telseif val == nil and default then","\t\treturn default","\telse","\t\t-- Failed, throw error","\t\tlevel = (level or 0) + 3","\t\t","\t\tlocal typname","\t\tif type(typ) == \"table\" then","\t\t\tassert(typ.__metatable and type(typ.__metatable) == \"string\")","\t\t\ttypname = typ.__metatable","\t\telse","\t\t\ttypname = typ","\t\tend","\t\t","\t\tlocal funcname = debug.getinfo(level-1, \"n\").name or \"<unnamed>\"","\t\tlocal mt = getmetatable(val)","\t\tSF.throw( \"Type mismatch (Expected \" .. typname .. \", got \" .. ( type( mt ) == \"string\" and mt or type( val ) ) .. \") in function \" .. funcname, level )","\tend","end",""],"private":false,"class":"function","name":"SF.CheckType","param":{"1":"val","2":"typ","3":"level","4":"default","level":"Level at which to error at. 3 is added to this value. Default is 0.","typ":"A string type or metatable.","default":"A value to return if val is nil.","val":"The value to be checked."}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- The main Starfall library","-------------------------------------------------------------------------------"],"code":["","if SF ~= nil then return end","SF = {}","","jit.off() -- Needed so ops counting will work reliably.","","-- Send files to client","if SERVER then","\tAddCSLuaFile( \"sflib.lua\" )","\tAddCSLuaFile( \"compiler.lua\" )","\tAddCSLuaFile( \"instance.lua\" )","\tAddCSLuaFile( \"libraries.lua\" )","\tAddCSLuaFile( \"preprocessor.lua\" )","\tAddCSLuaFile( \"database.lua\" )","\tAddCSLuaFile( \"permissions/core.lua\" )","\tAddCSLuaFile( \"editor.lua\" )","\tAddCSLuaFile( \"sfderma.lua\" )","\tAddCSLuaFile( \"callback.lua\" )","\tAddCSLuaFile( \"sfhelper.lua\" )","\tAddCSLuaFile( \"netstream.lua\" )","end","","-- Load files","include( \"compiler.lua\" )","include( \"instance.lua\" )","include( \"libraries.lua\" )","include( \"preprocessor.lua\" )","include( \"database.lua\" )","include( \"permissions/core.lua\" )","include( \"editor.lua\" )","include( \"sfhelper.lua\" )","include( \"netstream.lua\" )","","SF.cpuBufferN = CreateConVar( \"sf_timebuffersize\", 100, { FCVAR_REPLICATED }, \"Window width of the CPU time quota moving average.\" )","","if SERVER then","\tSF.cpuQuota = CreateConVar( \"sf_timebuffer\", 0.004, {}, \"Max average CPU time for serverside.\" )","else","\tSF.cpuQuota = CreateClientConVar( \"sf_timebuffer\", 0.015, false, false )","end","","","local dgetmeta = debug.getmetatable",""],"summary":"\n \nThe main Starfall library \n ","description":"\n \nThe main Starfall library \n","param":[]},{"summary":"\nThrows an error like the throw function in builtins ","description":"\nThrows an error like the throw function in builtins","comment":["--- Throws an error like the throw function in builtins","-- @param msg Message","-- @param level Which level in the stacktrace to blame","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" ) or info.short_src","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end","","SF.Types = {}","local typemetatables = {}"],"private":false,"class":"function","name":"SF.throw","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame"}},{"ret":["The table to store normal methods","The table to store metamethods"],"comment":["--- Creates a type that is safe for SF scripts to use. Instances of the type","-- cannot access the type's metatable or metamethods.","-- @param name Name of table","-- @param supermeta The metatable to inheret from","-- @return The table to store normal methods","-- @return The table to store metamethods"],"code":["function SF.Typedef(name, supermeta)","\t--Keep the original type so we don't screw up inheritance","\tif SF.Types[name] then","\t\treturn SF.Types[name].__methods, SF.Types[name]","\tend","","\tlocal methods, metamethods = {}, {}","\tmetamethods.__metatable = name","\tmetamethods.__index = methods","\tmetamethods.__methods = methods","\t","\tmetamethods.__supertypes = {[metamethods] = true}","\t","\tif supermeta then","\t\tsetmetatable(methods, {__index=supermeta.__index})","\t\tmetamethods.__supertypes[supermeta] = true","\t\tif supermeta.__supertypes then","\t\t\tfor k,_ in pairs(supermeta.__supertypes) do","\t\t\t\tmetamethods.__supertypes[k] = true","\t\t\tend","\t\tend","\tend","","\tSF.Types[name] = metamethods","\ttypemetatables[ metamethods ] = true","\treturn methods, metamethods","end","","function SF.GetTypeDef( name )","\treturn SF.Types[name]","end","","-- Include this file after Typedef as this file relies on it.","include(\"callback.lua\")","","do","\tlocal env, metatable = SF.Typedef(\"Environment\")"],"class":"function","name":"SF.Typedef","private":false,"summary":"\nCreates a type that is safe for SF scripts to use.","description":"\nCreates a type that is safe for SF scripts to use. Instances of the type \ncannot access the type's metatable or metamethods.","param":{"1":"name","2":"supermeta","name":"Name of table","supermeta":"The metatable to inheret from"}},{"comment":["\t--- The default environment metatable"],"code":["\tSF.DefaultEnvironmentMT = metatable"],"summary":"\nThe default environment metatable ","description":"\nThe default environment metatable","param":[]},{"comment":["\t--- The default environment contents"],"code":["\tSF.DefaultEnvironment = env","end",""],"summary":"\nThe default environment contents ","description":"\nThe default environment contents","param":[]},{"comment":["--- A set of all instances that have been created. It has weak keys and values.","-- Instances are put here after initialization."],"code":["SF.allInstances = setmetatable({},{__mode=\"kv\"})",""],"summary":"\nA set of all instances that have been created.","description":"\nA set of all instances that have been created. It has weak keys and values. \nInstances are put here after initialization.","param":[]},{"summary":"\nCalls a script hook on all processors.","description":"\nCalls a script hook on all processors.","comment":["--- Calls a script hook on all processors."],"code":["function SF.RunScriptHook(hook,...)","\tfor _,instance in pairs(SF.allInstances) do","\t\tif not instance.error then","\t\t\tlocal ok, err = instance:runScriptHook(hook,...)","\t\t\tif not ok then","\t\t\t\tinstance.error = true","\t\t\t\tif instance.runOnError then","\t\t\t\t\tinstance:runOnError( err )","\t\t\t\tend","\t\t\tend","\t\tend","\tend","end",""],"private":false,"class":"function","name":"SF.RunScriptHook","param":["hook","..."]},{"summary":"\nCreates a new context.","description":"\nCreates a new context. A context is used to define what scripts will have access to.","comment":["--- Creates a new context. A context is used to define what scripts will have access to.","-- @param env The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","-- @param directives Additional Preprocessor directives to use. Default is an empty table","-- @param cpuTime Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","-- @param libs Additional (local) libraries for the script to access. Default is an empty table."],"code":["function SF.CreateContext ( env, directives, cpuTime, libs )","\tlocal context = {}","\tcontext.env = env or SF.DefaultEnvironmentMT","\tcontext.directives = directives or {}","\tcontext.cpuTime = cpuTime or {","\t\tgetBufferN = function () return SF.cpuBufferN:GetInt() or 3 end,","\t\tgetMax = function () return SF.cpuQuota:GetFloat() end","\t}","\tcontext.libs = libs or {}","\treturn context","end",""],"private":false,"class":"function","name":"SF.CreateContext","param":{"1":"env","2":"directives","3":"cpuTime","4":"libs","env":"The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","directives":"Additional Preprocessor directives to use. Default is an empty table","cpuTime":"Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","libs":"Additional (local) libraries for the script to access. Default is an empty table."}},{"summary":"\nChecks the type of val.","description":"\nChecks the type of val. Errors if the types don't match","comment":["--- Checks the type of val. Errors if the types don't match","-- @param val The value to be checked.","-- @param typ A string type or metatable.","-- @param level Level at which to error at. 3 is added to this value. Default is 0.","-- @param default A value to return if val is nil."],"code":["function SF.CheckType(val, typ, level, default)","\tlocal meta = dgetmeta(val)","\tif meta == typ or (meta and typemetatables[meta] and meta.__supertypes and meta.__supertypes[typ]) or type(val) == typ then ","\t\treturn val","\telseif val == nil and default then","\t\treturn default","\telse","\t\t-- Failed, throw error","\t\tlevel = (level or 0) + 3","\t\t","\t\tlocal typname","\t\tif type(typ) == \"table\" then","\t\t\tassert(typ.__metatable and type(typ.__metatable) == \"string\")","\t\t\ttypname = typ.__metatable","\t\telse","\t\t\ttypname = typ","\t\tend","\t\t","\t\tlocal funcname = debug.getinfo(level-1, \"n\").name or \"<unnamed>\"","\t\tlocal mt = getmetatable(val)","\t\tSF.throw( \"Type mismatch (Expected \" .. typname .. \", got \" .. ( type( mt ) == \"string\" and mt or type( val ) ) .. \") in function \" .. funcname, level )","\tend","end",""],"private":false,"class":"function","name":"SF.CheckType","param":{"1":"val","2":"typ","3":"level","4":"default","level":"Level at which to error at. 3 is added to this value. Default is 0.","typ":"A string type or metatable.","default":"A value to return if val is nil.","val":"The value to be checked."}},{"summary":"\nGets the type of val.","description":"\nGets the type of val.","comment":["--- Gets the type of val.","-- @param val The value to be checked."],"code":["function SF.GetType( val )","\tlocal mt = dgetmeta(val)","\treturn (mt and mt.__metatable and type(mt.__metatable) == \"string\") and mt.__metatable or type(val)","end","","-- ------------------------------------------------------------------------- --","","local object_wrappers = {}","local sensitive2sf_tables = {}","local sf2sensitive_tables = {}",""],"private":false,"class":"function","name":"SF.GetType","param":{"1":"val","val":"The value to be checked."}},{"ret":["The function to wrap sensitive values to a SF-safe table","The function to unwrap the SF-safe table to the sensitive table"],"comment":["--- Creates wrap/unwrap functions for sensitive values, by using a lookup table","-- (which is set to have weak keys and values)","-- @param metatable The metatable to assign the wrapped value.","-- @param weakwrapper Make the wrapper weak inside the internal lookup table. Default: True","-- @param weaksensitive Make the sensitive data weak inside the internal lookup table. Default: True","-- @param target_metatable (optional) The metatable of the object that will get","-- \t\twrapped by these wrapper functions.  This is required if you want to","-- \t\thave the object be auto-recognized by the generic SF.WrapObject","--\t\tfunction.","-- @return The function to wrap sensitive values to a SF-safe table","-- @return The function to unwrap the SF-safe table to the sensitive table"],"code":["function SF.CreateWrapper(metatable, weakwrapper, weaksensitive, target_metatable, shared_meta)","\tlocal s2sfmode = \"\"","\tlocal sf2smode = \"\"","\t","\tif weakwrapper == nil or weakwrapper then","\t\tsf2smode = \"k\"","\t\ts2sfmode = \"v\"","\tend","\tif weaksensitive then","\t\tsf2smode = sf2smode..\"v\"","\t\ts2sfmode = s2sfmode..\"k\"","\tend ","","\tlocal sensitive2sf, sf2sensitive","\tif shared_meta then","\t\tsensitive2sf = sensitive2sf_tables[ shared_meta ]","\t\tsf2sensitive = sf2sensitive_tables[ shared_meta ]","\telse","\t\tsensitive2sf = setmetatable({},{__mode=s2sfmode})","\t\tsf2sensitive = setmetatable({},{__mode=sf2smode})","\t\tsensitive2sf_tables[ metatable ] = sensitive2sf","\t\tsf2sensitive_tables[ metatable ] = sf2sensitive","\tend","\t","\tlocal function wrap(value)","\t\tif value == nil then return nil end","\t\tif sensitive2sf[value] then return sensitive2sf[value] end","\t\tlocal tbl = setmetatable({},metatable)","\t\tsensitive2sf[value] = tbl","\t\tsf2sensitive[tbl] = value","\t\treturn tbl","\tend","\t","\tlocal function unwrap(value)","\t\treturn sf2sensitive[value]","\tend","\t","\tif target_metatable ~= nil then","\t\tobject_wrappers[target_metatable] = wrap","\t\tmetatable.__wrap = wrap","\tend","\t","\tmetatable.__unwrap = unwrap","\t","\treturn wrap, unwrap","end",""],"class":"function","name":"SF.CreateWrapper","private":false,"summary":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values) ","description":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values)","param":{"1":"metatable","2":"weakwrapper","3":"weaksensitive","4":"target_metatable","5":"shared_meta","target_metatable":"(optional) The metatable of the object that will get \nwrapped by these wrapper functions.  This is required if you want to \nhave the object be auto-recognized by the generic SF.WrapObject \nfunction.","metatable":"The metatable to assign the wrapped value.","weaksensitive":"Make the sensitive data weak inside the internal lookup table. Default: True","weakwrapper":"Make the wrapper weak inside the internal lookup table. Default: True"}},{"summary":"\nHelper function for adding custom wrappers ","description":"\nHelper function for adding custom wrappers","comment":["--- Helper function for adding custom wrappers","-- @param object_meta metatable of object","-- @param sf_object_meta starfall metatable of object","-- @param wrapper function that wraps object"],"code":["function SF.AddObjectWrapper( object_meta, sf_object_meta, wrapper )","\tsf_object_meta.__wrap = wrapper","\tobject_wrappers[object_meta] = wrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectWrapper","param":{"1":"object_meta","2":"sf_object_meta","3":"wrapper","sf_object_meta":"starfall metatable of object","wrapper":"function that wraps object","object_meta":"metatable of object"}},{"summary":"\nHelper function for adding custom unwrappers ","description":"\nHelper function for adding custom unwrappers","comment":["--- Helper function for adding custom unwrappers","-- @param object_meta metatable of object","-- @param unwrapper function that unwraps object"],"code":["function SF.AddObjectUnwrapper( object_meta, unwrapper )","\tobject_meta.__unwrap = unwrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectUnwrapper","param":{"1":"object_meta","2":"unwrapper","unwrapper":"function that unwraps object","object_meta":"metatable of object"}},{"ret":"returns nil if the object doesn't have a known wrapper, \nor returns the wrapped object if it does have a wrapper.","comment":["--- Wraps the given object so that it is safe to pass into starfall","-- It will wrap it as long as we have the metatable of the object that is","-- getting wrapped.","-- @param object the object needing to get wrapped as it's passed into starfall","-- @return returns nil if the object doesn't have a known wrapper,","-- or returns the wrapped object if it does have a wrapper."],"code":["function SF.WrapObject( object )","\tlocal metatable = dgetmeta(object)","\tif not metatable and type(object)~=\"table\" then return object end","\tlocal wrap = object_wrappers[metatable]","\treturn wrap and wrap(object)","end",""],"class":"function","name":"SF.WrapObject","private":false,"summary":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","description":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","param":{"1":"object","object":"the object needing to get wrapped as it's passed into starfall"}},{"ret":"the unwrapped starfall object","comment":["--- Takes a wrapped starfall object and returns the unwrapped version","-- @param object the wrapped starfall object, should work on any starfall","-- wrapped object.","-- @return the unwrapped starfall object"],"code":["function SF.UnwrapObject( object )","\tlocal metatable = dgetmeta(object)","\t","\tif metatable and metatable.__unwrap then","\t\treturn metatable.__unwrap( object )","\tend","end",""],"class":"function","name":"SF.UnwrapObject","private":false,"summary":"\nTakes a wrapped starfall object and returns the unwrapped version ","description":"\nTakes a wrapped starfall object and returns the unwrapped version","param":{"1":"object","object":"the wrapped starfall object, should work on any starfall \nwrapped object."}},{"summary":"\nManages data tied to entities so that the data is cleaned when the entity is removed ","description":"\nManages data tied to entities so that the data is cleaned when the entity is removed","comment":["--- Manages data tied to entities so that the data is cleaned when the entity is removed"],"code":["function SF.EntityTable( key )","\treturn setmetatable({}, ","\t{__newindex = function(t, e, v)","\t\trawset(t, e, v)","\t\te:CallOnRemove(\"SF_\" .. key, function() t[e] = nil end)","\tend})","end",""],"private":false,"class":"function","name":"SF.EntityTable","param":["key"]},{"summary":"\nReturns a class that can keep track of burst ","description":"\nReturns a class that can keep track of burst","comment":["--- Returns a class that can keep track of burst"],"code":["function SF.BurstObject( rate, max )","\tlocal burstclass = {","\t\tuse = function(self, amount)","\t\t\tself:check()","\t\t\tif self.val>= amount then","\t\t\t\tself.val = self.val - amount","\t\t\t\treturn true","\t\t\tend","\t\t\treturn false","\t\tend,","\t\tcheck = function(self)","\t\t\tself.val = math.min( self.val + (CurTime() - self.lasttick)*self.rate, self.max )","\t\t\tself.lasttick = CurTime()","\t\t\treturn self.val","\t\tend","\t}","\tlocal t = {","\t\trate = rate, ","\t\tmax = max,","\t\tval = max,","\t\tlasttick = 0","\t}","\treturn setmetatable(t, {__index=burstclass})","end","","local wrappedfunctions = setmetatable({},{__mode=\"kv\"})","local wrappedfunctions2instance = setmetatable({},{__mode=\"kv\"})"],"private":false,"class":"function","name":"SF.BurstObject","param":["rate","max"]},{"ret":"a function That when called will call the wrapped starfall function","comment":["--- Wraps the given starfall function so that it may called directly by GMLua","-- @param func The starfall function getting wrapped","-- @param instance The instance the function originated from","-- @return a function That when called will call the wrapped starfall function"],"code":["function SF.WrapFunction( func, instance )","\tif wrappedfunctions[func] then return wrappedfunctions[func] end","\t","\tlocal function returned_func( ... )","\t\treturn SF.Unsanitize( instance:runFunction( func, SF.Sanitize(...) ) )","\tend","\twrappedfunctions[func] = returned_func","\twrappedfunctions2instance[returned_func] = instance","\t","\treturn returned_func","end",""],"class":"function","name":"SF.WrapFunction","private":false,"summary":"\nWraps the given starfall function so that it may called directly by GMLua ","description":"\nWraps the given starfall function so that it may called directly by GMLua","param":{"1":"func","2":"instance","func":"The starfall function getting wrapped","instance":"The instance the function originated from"}},{"ret":"Instance","comment":["--- Gets the instance a wrapped function is bound to","-- @param func Function","-- @return Instance"],"code":["function SF.WrappedFunctionInstance(func)","\treturn wrappedfunctions2instance[func]","end","","-- A list of safe data types","local safe_types = {","\t[\"number\"  ] = true,","\t[\"string\"  ] = true,","\t[\"Vector\"  ] = false,","\t[\"Color\"   ] = false,","\t[\"Angle\"   ] = false,","\t[\"Entity\"  ] = false,","\t[\"VMatrix\" ] = false,","\t[\"boolean\" ] = true,","\t[\"nil\"     ] = true,","}",""],"class":"function","name":"SF.WrappedFunctionInstance","private":false,"summary":"\nGets the instance a wrapped function is bound to ","description":"\nGets the instance a wrapped function is bound to","param":{"1":"func","func":"Function"}},{"summary":"\nSanitizes and returns its argument list.","description":"\nSanitizes and returns its argument list. \nBasic types are returned unchanged. Non-object tables will be \nrecursed into and their keys and values will be sanitized. Object \ntypes will be wrapped if a wrapper is available. When a wrapper is \nnot available objects will be replaced with nil, so as to prevent \nany possiblitiy of leakage. Functions will always be replaced with \nnil as there is no way to verify that they are safe.","comment":["--- Sanitizes and returns its argument list.","-- Basic types are returned unchanged. Non-object tables will be","-- recursed into and their keys and values will be sanitized. Object","-- types will be wrapped if a wrapper is available. When a wrapper is","-- not available objects will be replaced with nil, so as to prevent","-- any possiblitiy of leakage. Functions will always be replaced with","-- nil as there is no way to verify that they are safe."],"code":["function SF.Sanitize( ... )","\t-- Sanitize ALL the things.","\tlocal return_list = {}","\tlocal args = { ... }","\t","\tfor key, value in pairs( args ) do","\t\tlocal typmeta = getmetatable( value )","\t\tlocal typ = type( typmeta ) == \"string\" and typmeta or type( value )","\t\tif safe_types[ typ ] then","\t\t\treturn_list[ key ] = value","\t\telseif SF.WrapObject( value ) then","\t\t\treturn_list[ key ] = SF.WrapObject( value )","\t\telseif typ == \"table\" then","\t\t\tlocal tbl = {}","\t\t\tfor k,v in pairs( value ) do","\t\t\t\ttbl[ SF.Sanitize( k ) ] = SF.Sanitize( v )","\t\t\tend","\t\t\treturn_list[ key ] = tbl","\t\telse ","\t\t\treturn_list[ key ] = nil","\t\tend","\tend","\t","\treturn unpack( return_list )","end",""],"private":false,"class":"function","name":"SF.Sanitize","param":["..."]},{"summary":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment ","description":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment","comment":["--- Takes output from starfall and does it's best to make the output","-- fully usable outside of starfall environment"],"code":["function SF.Unsanitize( ... )","\tlocal return_list = {}","\t","\tlocal args = {...}","\t","\tfor key, value in pairs( args ) do","\t\tlocal typ = type(value)","\t\tif typ == \"table\" and SF.UnwrapObject(value) then","\t\t\treturn_list[key] = SF.UnwrapObject(value)","\t\telseif typ == \"table\" then","\t\t\treturn_list[key] = {}","","\t\t\tfor k,v in pairs(value) do","\t\t\t\treturn_list[key][SF.Unsanitize(k)] = SF.Unsanitize(v)","\t\t\tend","\t\telse","\t\t\treturn_list[key] = value","\t\tend","\tend","","\treturn unpack( return_list )","end","","-- ------------------------------------------------------------------------- --","","local function isnan(n)","\treturn n ~= n","end","","-- Taken from E2Lib","","-- This function clamps the position before moving the entity","local minx, miny, minz = -16384, -16384, -16384","local maxx, maxy, maxz = 16384, 16384, 16384","local clamp = math.Clamp","local function clampPos(pos)","\tpos.x = clamp(pos.x, minx, maxx)","\tpos.y = clamp(pos.y, miny, maxy)","\tpos.z = clamp(pos.z, minz, maxz)","\treturn pos","end","","function SF.setPos(ent, pos)","\tif isnan(pos.x) or isnan(pos.y) or isnan(pos.z) then return end","\treturn ent:SetPos(clampPos(pos))","end","","local huge, abs = math.huge, math.abs","function SF.setAng(ent, ang)","\tif isnan(ang.pitch) or isnan(ang.yaw) or isnan(ang.roll) then return end","\tif abs(ang.pitch) == huge or abs(ang.yaw) == huge or abs(ang.roll) == huge then return false end -- SetAngles'ing inf crashes the server","\treturn ent:SetAngles(ang)","end","","-- ------------------------------------------------------------------------- --","","local serialize_replace_regex = \"[\\\"\\n]\"","local serialize_replace_tbl = { [ \"\\n\" ] = string.char( 5 ), [ '\"' ] = string.char( 4 ) }",""],"private":false,"class":"function","name":"SF.Unsanitize","param":["..."]},{"summary":"\nSerializes an instance's code in a format compatible with the duplicator library ","description":"\nSerializes an instance's code in a format compatible with the duplicator library","comment":["--- Serializes an instance's code in a format compatible with the duplicator library","-- @param sources The table of filename = source entries. Ususally instance.source","-- @param mainfile The main filename. Usually instance.mainfile"],"code":["function SF.SerializeCode(sources, mainfile)","\tlocal rt = {source = {}}","\tfor filename, source in pairs(sources) do","\t\trt.source[filename] = string.gsub(source, serialize_replace_regex, serialize_replace_tbl)","\tend","\trt.mainfile = mainfile","\treturn rt","end","","local deserialize_replace_regex = \"[\" .. string.char( 5 ) .. string.char( 4 ) .. \"]\"","local deserialize_replace_tbl = { [ string.char( 5 )[ 1 ] ] = \"\\n\", [ string.char( 4 )[ 1 ] ] = '\"' }"],"private":false,"class":"function","name":"SF.SerializeCode","param":{"1":"sources","2":"mainfile","mainfile":"The main filename. Usually instance.mainfile","sources":"The table of filename = source entries. Ususally instance.source"}},{"ret":["The table of filename = source entries","The main filename"],"comment":["--- Deserializes an instance's code.","-- @return The table of filename = source entries","-- @return The main filename"],"code":["function SF.DeserializeCode(tbl)","\tlocal sources = {}","\tfor filename, source in pairs(tbl.source) do","\t\tsources[filename] = string.gsub(source, deserialize_replace_regex, deserialize_replace_tbl)","\tend","\treturn sources, tbl.mainfile","end","","-- ------------------------------------------------------------------------- --","","if SERVER then","\tutil.AddNetworkString(\"starfall_requpload\")","\tutil.AddNetworkString(\"starfall_upload\")","\tutil.AddNetworkString( \"starfall_addnotify\" )","\tutil.AddNetworkString( \"starfall_console_print\" )","\tutil.AddNetworkString( \"starfall_openeditor\" )","\t","\tlocal uploaddata = SF.EntityTable( \"sfTransfer\" )",""],"class":"function","name":"SF.DeserializeCode","private":false,"summary":"\nDeserializes an instance's code.","description":"\nDeserializes an instance's code.","param":["tbl"]},{"ret":"True if the code was requested, false if an incomplete request is still in progress for that player","comment":["\t--- Requests a player to send whatever code they have open in his/her editor to","\t-- the server.","\t-- @server","\t-- @param ply Player to request code from","\t-- @param callback Called when all of the code is recieved. Arguments are either the main filename and a table","\t-- of filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)","\t-- @return True if the code was requested, false if an incomplete request is still in progress for that player"],"code":["\tfunction SF.RequestCode(ply, callback)","\t\tif uploaddata[ply] and uploaddata[ply].timeout > CurTime() then return false end","\t\t","\t\tnet.Start(\"starfall_requpload\")","\t\tnet.Send(ply)","","\t\tuploaddata[ply] = {","\t\t\tfiles={},","\t\t\tmainfile = nil,","\t\t\tneedHeader=true,","\t\t\tcallback = callback,","\t\t\ttimeout = CurTime() + 1","\t\t}","\t\treturn true","\tend","\t","\tnet.Receive(\"starfall_upload\", function(len, ply)","\t\tlocal updata = uploaddata[ply]","\t\tif not updata then","\t\t\tErrorNoHalt(\"SF: Player \"..ply:GetName()..\" tried to upload code without being requested (expect this message multiple times)\\n\")","\t\t\treturn","\t\tend","\t\t","\t\tupdata.mainfile = net.ReadString()","\t\t","\t\tlocal I = 0","\t\twhile I < 256 do","\t\t\tif net.ReadBit() ~= 0 then break end","\t\t\tlocal filename = net.ReadString()","","\t\t\tnet.ReadStream( ply, function( data )","\t\t\t\tupdata.Completed = updata.Completed + 1","\t\t\t\tupdata.files[ filename ] = data","\t\t\t\tif updata.Completed == updata.NumFiles then","\t\t\t\t\tupdata.callback(updata.mainfile, updata.files)","\t\t\t\t\tuploaddata[ply] = nil","\t\t\t\tend","\t\t\tend )","\t\t\tI = I + 1","\t\tend","","\t\tupdata.Completed = 0","\t\tupdata.NumFiles = I","\t\t","\t\tif I == 0 then","\t\t\tuploaddata[ply] = nil","\t\tend","\tend)","","\tfunction SF.AddNotify ( ply, msg, notifyType, duration, sound )","\t\tif not IsValid( ply ) then return end","","\t\tnet.Start( \"starfall_addnotify\" )","\t\tnet.WriteString( msg )","\t\tnet.WriteUInt( notifyType, 8 or 0, 8 )","\t\tnet.WriteFloat( duration )","\t\tnet.WriteUInt( sound, 8 or 0, 8 )","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tfunction SF.Print ( ply, msg )","\t\tnet.Start( \"starfall_console_print\" )","\t\t\tnet.WriteString( msg )","\t\tnet.Send( ply )","\tend","else","\tnet.Receive(\"starfall_openeditor\",function(len)\t\t","\t\tSF.Editor.open()","\t\t","\t\tlocal gate = net.ReadEntity()","\t\t","\t\thook.Add(\"Think\",\"WaitForEditor\",function()","\t\t\tif SF.Editor.initialized then","\t\t\t\tif IsValid(gate) and gate.files then","\t\t\t\t\tfor name, code in pairs(gate.files) do","\t\t\t\t\t\tlocal found = false","\t\t\t\t\t\tfor _, tab in pairs(SF.Editor.getTabHolder().tabs) do","\t\t\t\t\t\t\tif tab.filename == name and tab.code == code then","\t\t\t\t\t\t\t\tfound = tab","\t\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t\tend","\t\t\t\t\t\tend","\t\t\t\t\t\tif found then","\t\t\t\t\t\t\tSF.Editor.selectTab( found )","\t\t\t\t\t\telse","\t\t\t\t\t\t\tSF.Editor.addTab( name, code )","\t\t\t\t\t\tend","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\thook.Remove(\"Think\",\"WaitForEditor\")","\t\t\tend","\t\tend)","\tend)","\t","\tnet.Receive(\"starfall_requpload\", function(len)","\t\tlocal ok, list = SF.Editor.BuildIncludesTable()","\t\tif ok then","\t\t\t--print(\"Uploading SF code\")","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteString(list.mainfile)","\t\t\t","\t\t\tfor name, data in pairs( list.files ) do","\t\t\t\tnet.WriteBit( false )","\t\t\t\tnet.WriteString( name )","\t\t\t\tnet.WriteStream( data )","\t\t\tend","","\t\t\tnet.WriteBit( true )","\t\t\tnet.SendToServer()","\t\t\t--print(\"Done sending\")","\t\telse","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteString(\"\")","\t\t\tnet.WriteBit(false)","\t\t\tnet.SendToServer()","\t\t\tif list then","\t\t\t\tSF.AddNotify( LocalPlayer(), list, NOTIFY_ERROR, 7, NOTIFYSOUND_ERROR1 )","\t\t\tend","\t\tend","\tend)","","\tlocal sounds = {","\t\t[ NOTIFYSOUND_DRIP1 ] = \"ambient/water/drip1.wav\",","\t\t[ NOTIFYSOUND_DRIP2 ] = \"ambient/water/drip2.wav\",","\t\t[ NOTIFYSOUND_DRIP3 ] = \"ambient/water/drip3.wav\",","\t\t[ NOTIFYSOUND_DRIP4 ] = \"ambient/water/drip4.wav\",","\t\t[ NOTIFYSOUND_DRIP5 ] = \"ambient/water/drip5.wav\",","\t\t[ NOTIFYSOUND_ERROR1 ] = \"buttons/button10.wav\",","\t\t[ NOTIFYSOUND_CONFIRM1 ] = \"buttons/button3.wav\",","\t\t[ NOTIFYSOUND_CONFIRM2 ] = \"buttons/button14.wav\",","\t\t[ NOTIFYSOUND_CONFIRM3 ] = \"buttons/button15.wav\",","\t\t[ NOTIFYSOUND_CONFIRM4 ] = \"buttons/button17.wav\"","\t}","","\tfunction SF.AddNotify ( ply, msg, type, duration, sound )","\t\tif not IsValid( ply ) then return end","","\t\tif ply ~= LocalPlayer() then","\t\t\treturn","\t\tend","","\t\tprint( msg )","","\t\tlocal newline = string.find( msg, \"\\n\" )","\t\tif newline then","\t\t\tmsg = string.sub( msg, 1, newline - 1 )","\t\tend","\t\t","\t\tGAMEMODE:AddNotify( msg, type, duration )","","\t\tif sound and sounds[ sound ] then","\t\t\tsurface.PlaySound( sounds[ sound ] )","\t\tend","\tend","","\tnet.Receive( \"starfall_addnotify\", function ()","\t\tSF.AddNotify( LocalPlayer(), net.ReadString(), net.ReadUInt( 8 ), net.ReadFloat(), net.ReadUInt( 8 ) )","\tend )","","\tnet.Receive( \"starfall_console_print\", function ()","\t\tprint( net.ReadString() )","\tend )","end","","-- ------------------------------------------------------------------------- --","","local function cleanHooks( file )","\tfor k, v in pairs(SF.Libraries.hooks) do","\t\tlocal i = 1","\t\twhile i <= #v do","\t\t\tlocal hookfile = string.lower(string.sub(string.GetFileFromFilename( debug.getinfo( v[i], \"S\" ).short_src or \"\" ), 1, -5))","\t\t\tif file == hookfile then","\t\t\t\ttable.remove( v, i )","\t\t\telse","\t\t\t\ti = i + 1","\t\t\tend","\t\tend","\tend","end","","if SERVER then","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\t\tAddCSLuaFile(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading SF server-side libraries\")","\tl = file.Find(\"starfall/libs_sv/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sv/\"..filename)","\tend","\tMsgN(\"- End loading server-side libraries\")","","\t","\tMsgN(\"- Adding client-side libraries to send list\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Adding \"..filename)","\t\tAddCSLuaFile(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","\t","\tMsgN(\"-End Loading SF Libraries\")","\t","\t-- Command to reload the libraries","\tutil.AddNetworkString(\"sf_reloadlibrary\")","\tconcommand.Add(\"sf_reloadlibrary\", function(ply, com, arg)","\t\tif ply:IsValid() and not ply:IsSuperAdmin() then return end","\t\tlocal filename = arg[1]","\t\tif not filename then return end","\t\tfilename = string.lower( filename )","\t\t","\t\tlocal function sendToClient(name)","\t\t\tnet.Start(\"sf_reloadlibrary\")","\t\t\tlocal data = util.Compress(file.Read(name,\"LUA\"))","\t\t\tnet.WriteString(filename)","\t\t\tnet.WriteStream( data )","\t\t\tnet.Broadcast()","\t\tend","\t\t","\t\tlocal sv_filename = \"starfall/libs_sv/\"..filename..\".lua\"","\t\tlocal sh_filename = \"starfall/libs_sh/\"..filename..\".lua\"","\t\tlocal cl_filename = \"starfall/libs_cl/\"..filename..\".lua\"","\t\t","\t\tcleanHooks( filename )","\t\t","\t\tlocal postload","\t\tif file.Exists( sh_filename, \"LUA\" ) then","\t\t\tprint(\"Reloaded library: \" .. filename)","\t\t\tinclude(sh_filename)","\t\t\tsendToClient(sh_filename)","\t\t\tpostload = true","\t\tend","\t\tif file.Exists( sv_filename, \"LUA\" ) then","\t\t\tprint(\"Reloaded library: \" .. filename)","\t\t\tinclude(sv_filename)","\t\t\tpostload = true","\t\tend","\t\tif file.Exists( cl_filename, \"LUA\" ) then","\t\t\tsendToClient(cl_filename)","\t\tend","\t\tif postload then","\t\t\tSF.Libraries.CallHook(\"postload\")","\t\tend","\tend)","\t","else","","\tnet.Receive(\"sf_reloadlibrary\", function(len)","\t\tlocal name = net.ReadString()","\t\tnet.ReadStream( nil, function( data )","\t\t\tlocal file = util.Decompress( data )","\t\t\tif file then","\t\t\t\tprint(\"Reloaded library: \" .. name)","\t\t\t\tcleanHooks( name )","\t\t\t\tlocal func = CompileString( file, \"starfall/\" .. name .. \".lua\" )","\t\t\t\tfunc()","\t\t\t\tSF.Libraries.CallHook(\"postload\")","\t\t\tend","\t\tend )","\tend)","","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading client-side libraries\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","","\t","\tMsgN(\"-End Loading SF Libraries\")","end","","SF.Libraries.CallHook(\"postload\")"],"class":"function","name":"SF.RequestCode","summary":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","private":false,"server":true,"description":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","param":{"1":"ply","2":"callback","ply":"Player to request code from","callback":"Called when all of the code is recieved. Arguments are either the main filename and a table \nof filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)"}}],"tables":[],"description":"\n \nThe main Starfall library \n","summary":"\n \nThe main Starfall library \n "},"libs_cl/bass.lua":{"libraries":{"1":"bass","bass":{"comment":["--- Bass library.","-- @client"],"functions":{"1":"loadFile","2":"loadURL","loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}}},"class":"library","summary":"\nBass library.","fields":[],"name":"bass","client":true,"description":"\nBass library.","libtbl":"bass_library","tables":[],"code":["local bass_library, _ = SF.Libraries.Register( \"bass\" )","","SF.Bass.Wrap = wrap","SF.Bass.Unwrap = unwrap","SF.Bass.Methods = bass_methods","SF.Bass.Metatable = bass_metamethods","","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.bass = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.bass.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tif s:IsValid() then","\t\t\ts:Stop()","\t\tend","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""]}},"type":"file","name":"libs_cl/bass.lua","functions":{"1":"bass_library.loadFile","2":"bass_library.loadURL","3":"bass_methods:getFFT","4":"bass_methods:getLength","5":"bass_methods:getTime","6":"bass_methods:play","7":"bass_methods:setFade","8":"bass_methods:setLooping","9":"bass_methods:setPitch","10":"bass_methods:setPos","11":"bass_methods:setTime","12":"bass_methods:setVolume","13":"bass_methods:stop","bass_library.loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"bass_methods:setFade":{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},"bass_methods:stop":{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw =  unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},"bass_library.loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}},"bass_methods:getTime":{"ret":"Current time in seconds of the sound","comment":["--- Gets the current time of a sound","-- @return Current time in seconds of the sound"],"code":["function bass_methods:getTime ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetTime()","\tend","end",""],"class":"function","name":"bass_methods:getTime","summary":"\nGets the current time of a sound ","private":false,"classlib":"Bass","description":"\nGets the current time of a sound","param":[]},"bass_methods:getFFT":{"ret":"FFT table of the sound","comment":["--- Gets the FFT of a sound","-- @param n Sample size of the hamming window. Must be power of 2","-- @return FFT table of the sound"],"code":["function bass_methods:getFFT ( n )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tlocal arr = {}","\t\tuw:FFT( arr, n )","\t\treturn arr","\tend","end","",""],"class":"function","name":"bass_methods:getFFT","summary":"\nGets the FFT of a sound ","private":false,"classlib":"Bass","description":"\nGets the FFT of a sound","param":{"1":"n","n":"Sample size of the hamming window. Must be power of 2"}},"bass_methods:getLength":{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]},"bass_methods:setTime":{"comment":["--- Sets the current time of a sound","-- @param time Time to set a sound in seconds"],"code":["function bass_methods:setTime ( time )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( time, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetTime( time )","\tend","end",""],"class":"function","name":"bass_methods:setTime","summary":"\nSets the current time of a sound ","private":false,"classlib":"Bass","description":"\nSets the current time of a sound","param":{"1":"time","time":"Time to set a sound in seconds"}},"bass_methods:setLooping":{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},"bass_methods:setPos":{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},"bass_methods:setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}},"bass_methods:setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},"bass_methods:play":{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]}},"doc":[{"comment":["--- Bass type","-- @client"],"code":["local bass_methods, bass_metamethods = SF.Typedef( \"Bass\" )","local wrap, unwrap = SF.CreateWrapper( bass_metamethods, true, false, debug.getregistry().IGModAudioChannel )",""],"typtbl":"bass_methods","fields":[],"name":"Bass","summary":"\nBass type ","description":"\nBass type","client":true,"class":"class","methods":{"1":"getFFT","2":"getLength","3":"getTime","4":"play","5":"setFade","6":"setLooping","7":"setPitch","8":"setPos","9":"setTime","10":"setVolume","11":"stop","setLooping":{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},"setFade":{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},"getFFT":{"ret":"FFT table of the sound","comment":["--- Gets the FFT of a sound","-- @param n Sample size of the hamming window. Must be power of 2","-- @return FFT table of the sound"],"code":["function bass_methods:getFFT ( n )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tlocal arr = {}","\t\tuw:FFT( arr, n )","\t\treturn arr","\tend","end","",""],"class":"function","name":"bass_methods:getFFT","summary":"\nGets the FFT of a sound ","private":false,"classlib":"Bass","description":"\nGets the FFT of a sound","param":{"1":"n","n":"Sample size of the hamming window. Must be power of 2"}},"getTime":{"ret":"Current time in seconds of the sound","comment":["--- Gets the current time of a sound","-- @return Current time in seconds of the sound"],"code":["function bass_methods:getTime ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetTime()","\tend","end",""],"class":"function","name":"bass_methods:getTime","summary":"\nGets the current time of a sound ","private":false,"classlib":"Bass","description":"\nGets the current time of a sound","param":[]},"setPos":{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},"stop":{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw =  unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},"setTime":{"comment":["--- Sets the current time of a sound","-- @param time Time to set a sound in seconds"],"code":["function bass_methods:setTime ( time )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( time, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetTime( time )","\tend","end",""],"class":"function","name":"bass_methods:setTime","summary":"\nSets the current time of a sound ","private":false,"classlib":"Bass","description":"\nSets the current time of a sound","param":{"1":"time","time":"Time to set a sound in seconds"}},"getLength":{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},"play":{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}}}},{"comment":["--- Bass library.","-- @client"],"functions":{"1":"loadFile","2":"loadURL","loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}}},"class":"library","summary":"\nBass library.","fields":[],"name":"bass","client":true,"description":"\nBass library.","libtbl":"bass_library","tables":[],"code":["local bass_library, _ = SF.Libraries.Register( \"bass\" )","","SF.Bass.Wrap = wrap","SF.Bass.Unwrap = unwrap","SF.Bass.Methods = bass_methods","SF.Bass.Metatable = bass_metamethods","","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.bass = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.bass.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tif s:IsValid() then","\t\t\ts:Stop()","\t\tend","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""]},{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}},{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tif instance.error then","\t\t\t\tsnd:Stop()","\t\t\telse","\t\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},{"summary":"\n ","description":"\n","comment":["--------------------------------------------------"],"code":[""]},{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]},{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw =  unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}},{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]},{"comment":["--- Sets the current time of a sound","-- @param time Time to set a sound in seconds"],"code":["function bass_methods:setTime ( time )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( time, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetTime( time )","\tend","end",""],"class":"function","name":"bass_methods:setTime","summary":"\nSets the current time of a sound ","private":false,"classlib":"Bass","description":"\nSets the current time of a sound","param":{"1":"time","time":"Time to set a sound in seconds"}},{"ret":"Current time in seconds of the sound","comment":["--- Gets the current time of a sound","-- @return Current time in seconds of the sound"],"code":["function bass_methods:getTime ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetTime()","\tend","end",""],"class":"function","name":"bass_methods:getTime","summary":"\nGets the current time of a sound ","private":false,"classlib":"Bass","description":"\nGets the current time of a sound","param":[]},{"ret":"FFT table of the sound","comment":["--- Gets the FFT of a sound","-- @param n Sample size of the hamming window. Must be power of 2","-- @return FFT table of the sound"],"code":["function bass_methods:getFFT ( n )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tlocal arr = {}","\t\tuw:FFT( arr, n )","\t\treturn arr","\tend","end","",""],"class":"function","name":"bass_methods:getFFT","summary":"\nGets the FFT of a sound ","private":false,"classlib":"Bass","description":"\nGets the FFT of a sound","param":{"1":"n","n":"Sample size of the hamming window. Must be power of 2"}}],"tables":[],"description":"\nBass type","summary":"\nBass type "},"libs_sh/vehicles.lua":{"libraries":[],"type":"file","name":"libs_sh/vehicles.lua","functions":{"1":"vehicle_metamethods:__tostring","2":"vehicle_methods:ejectDriver","3":"vehicle_methods:getDriver","4":"vehicle_methods:getPassenger","vehicle_methods:ejectDriver":{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},"vehicle_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function vehicle_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","if SERVER then"],"class":"function","summary":"\nTo string ","name":"vehicle_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"vehicle_methods:getDriver":{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},"vehicle_methods:getPassenger":{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param n The index of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","n":"The index of the passenger to get"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Vehicle functions.","-------------------------------------------------------------------------------"],"code":["","SF.Vehicles = {}"],"summary":"\n \nVehicle functions.","description":"\n \nVehicle functions. \n","param":[]},{"comment":["--- Vehicle type"],"code":["local vehicle_methods, vehicle_metamethods = SF.Typedef(\"Vehicle\", SF.Entities.Metatable)","","SF.Vehicles.Methods = vehicle_methods","SF.Vehicles.Metatable = vehicle_metamethods",""],"typtbl":"vehicle_methods","fields":[],"name":"Vehicle","summary":"\nVehicle type ","description":"\nVehicle type","class":"class","methods":{"1":"ejectDriver","2":"getDriver","3":"getPassenger","getDriver":{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},"ejectDriver":{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},"getPassenger":{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param n The index of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","n":"The index of the passenger to get"}}}},{"comment":["--- Custom wrapper/unwrapper is necessary for vehicle objects","-- wrapper"],"code":["local dsetmeta = debug.setmetatable","local function wrap( object )","\tobject = SF.Entities.Wrap( object )","\tdsetmeta( object, vehicle_metamethods )","\treturn object","end","","SF.AddObjectWrapper( debug.getregistry().Vehicle, vehicle_metamethods, wrap )","SF.AddObjectUnwrapper( vehicle_metamethods, SF.Entities.Unwrap )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"vehicle.eject\", \"Vehicle eject\", \"Removes a driver from vehicle\" )","end",""],"summary":"\nCustom wrapper/unwrapper is necessary for vehicle objects \nwrapper ","description":"\nCustom wrapper/unwrapper is necessary for vehicle objects \nwrapper","param":[]},{"comment":["--- To string","-- @shared"],"code":["function vehicle_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","if SERVER then"],"class":"function","summary":"\nTo string ","name":"vehicle_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param n The index of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","n":"The index of the passenger to get"}}],"tables":[],"description":"\n \nVehicle functions. \n","summary":"\n \nVehicle functions."},"compiler.lua":{"libraries":[],"type":"file","name":"compiler.lua","functions":{"1":"SF.Compiler.Compile","SF.Compiler.Compile":{"ret":["True if no errors, false if errors occured.","The compiled instance, or the error message."],"comment":["--- Preprocesses and Compiles code and returns an Instance","-- @param code Either a string of code, or a {path=source} table","-- @param context The context to use in the resulting Instance","-- @param mainfile If code is a table, this specifies the first file to parse.","-- @param player The \"owner\" of the instance","-- @param data The table to set instance.data to. Default is a new table.","-- @param dontpreprocess Set to true to skip preprocessing","-- @return True if no errors, false if errors occured.","-- @return The compiled instance, or the error message."],"code":["function SF.Compiler.Compile(code, context, mainfile, player, data, dontpreprocess)","\tif type(code) == \"string\" then","\t\tmainfile = mainfile or \"generic\"","\t\tcode = {[mainfile]=code}","\tend","\t","\tlocal instance = setmetatable({},SF.Instance)","\t","\tdata = data or {}","\t","\tinstance.player = player","\tinstance.env = setmetatable({},context.env)","\tinstance.env._G = instance.env","\tinstance.data = data","\tinstance.ppdata = {}","\tinstance.ops = 0","\tinstance.hooks = {}","\tinstance.scripts = {}","\tinstance.source = code","\tinstance.initialized = false","\tinstance.context = context","\tinstance.mainfile = mainfile","","\t-- Add local libraries","\tfor k, v in pairs( context.libs ) do instance.env[ k ] = setmetatable( {}, v ) end","","\t-- Call onLoad functions","\tfor k, v in pairs( context.env.__index ) do","\t\tif type( v ) == \"table\" then","\t\t\tlocal meta = debug.getmetatable( v )","\t\t\tif meta.onLoad then meta.onLoad( instance ) end","\t\tend","\tend","\tfor k, v in pairs( context.libs ) do","\t\tif type( v ) == \"table\" then","\t\t\tif v.onLoad then v.onLoad( instance ) end","\t\tend","\tend","\t","\tfor filename, source in pairs(code) do","\t\tif not dontpreprocess then","\t\t\tSF.Preprocessor.ParseDirectives(filename,source,context.directives,instance.ppdata)","\t\tend","\t\t","\t\tlocal serverorclient","\t\tif  instance.ppdata.serverorclient then","\t\t\tserverorclient = instance.ppdata.serverorclient[ filename ]","\t\tend","\t\t","\t\tif string.match(source, \"^[%s\\n]*$\") or (serverorclient == \"server\" and CLIENT) or (serverorclient == \"client\" and SERVER) then","\t\t\t-- Lua doesn't have empty statements, so an empty file gives a syntax error","\t\t\tinstance.scripts[filename] = function() end","\t\telse","\t\t\tlocal func = CompileString(source, \"SF:\"..filename, false)","\t\t\tif type(func) == \"string\" then","\t\t\t\treturn false, func","\t\t\tend","\t\t\tdebug.setfenv(func, instance.env)","\t\t\tinstance.scripts[filename] = func","\t\tend","\tend","\t","\treturn true, instance","end"],"class":"function","name":"SF.Compiler.Compile","private":false,"summary":"\nPreprocesses and Compiles code and returns an Instance ","description":"\nPreprocesses and Compiles code and returns an Instance","param":{"1":"code","2":"context","3":"mainfile","4":"player","5":"data","6":"dontpreprocess","mainfile":"If code is a table, this specifies the first file to parse.","player":"The \"owner\" of the instance","code":"Either a string of code, or a {path=source} table","dontpreprocess":"Set to true to skip preprocessing","context":"The context to use in the resulting Instance","data":"The table to set instance.data to. Default is a new table."}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Compiler.","-- Compiles code into an uninitialized Instance.","---------------------------------------------------------------------"],"code":["","SF.Compiler = {}",""],"summary":"\n \nSF Compiler.","description":"\n \nSF Compiler. \nCompiles code into an uninitialized Instance. \n","param":[]},{"ret":["True if no errors, false if errors occured.","The compiled instance, or the error message."],"comment":["--- Preprocesses and Compiles code and returns an Instance","-- @param code Either a string of code, or a {path=source} table","-- @param context The context to use in the resulting Instance","-- @param mainfile If code is a table, this specifies the first file to parse.","-- @param player The \"owner\" of the instance","-- @param data The table to set instance.data to. Default is a new table.","-- @param dontpreprocess Set to true to skip preprocessing","-- @return True if no errors, false if errors occured.","-- @return The compiled instance, or the error message."],"code":["function SF.Compiler.Compile(code, context, mainfile, player, data, dontpreprocess)","\tif type(code) == \"string\" then","\t\tmainfile = mainfile or \"generic\"","\t\tcode = {[mainfile]=code}","\tend","\t","\tlocal instance = setmetatable({},SF.Instance)","\t","\tdata = data or {}","\t","\tinstance.player = player","\tinstance.env = setmetatable({},context.env)","\tinstance.env._G = instance.env","\tinstance.data = data","\tinstance.ppdata = {}","\tinstance.ops = 0","\tinstance.hooks = {}","\tinstance.scripts = {}","\tinstance.source = code","\tinstance.initialized = false","\tinstance.context = context","\tinstance.mainfile = mainfile","","\t-- Add local libraries","\tfor k, v in pairs( context.libs ) do instance.env[ k ] = setmetatable( {}, v ) end","","\t-- Call onLoad functions","\tfor k, v in pairs( context.env.__index ) do","\t\tif type( v ) == \"table\" then","\t\t\tlocal meta = debug.getmetatable( v )","\t\t\tif meta.onLoad then meta.onLoad( instance ) end","\t\tend","\tend","\tfor k, v in pairs( context.libs ) do","\t\tif type( v ) == \"table\" then","\t\t\tif v.onLoad then v.onLoad( instance ) end","\t\tend","\tend","\t","\tfor filename, source in pairs(code) do","\t\tif not dontpreprocess then","\t\t\tSF.Preprocessor.ParseDirectives(filename,source,context.directives,instance.ppdata)","\t\tend","\t\t","\t\tlocal serverorclient","\t\tif  instance.ppdata.serverorclient then","\t\t\tserverorclient = instance.ppdata.serverorclient[ filename ]","\t\tend","\t\t","\t\tif string.match(source, \"^[%s\\n]*$\") or (serverorclient == \"server\" and CLIENT) or (serverorclient == \"client\" and SERVER) then","\t\t\t-- Lua doesn't have empty statements, so an empty file gives a syntax error","\t\t\tinstance.scripts[filename] = function() end","\t\telse","\t\t\tlocal func = CompileString(source, \"SF:\"..filename, false)","\t\t\tif type(func) == \"string\" then","\t\t\t\treturn false, func","\t\t\tend","\t\t\tdebug.setfenv(func, instance.env)","\t\t\tinstance.scripts[filename] = func","\t\tend","\tend","\t","\treturn true, instance","end"],"class":"function","name":"SF.Compiler.Compile","private":false,"summary":"\nPreprocesses and Compiles code and returns an Instance ","description":"\nPreprocesses and Compiles code and returns an Instance","param":{"1":"code","2":"context","3":"mainfile","4":"player","5":"data","6":"dontpreprocess","mainfile":"If code is a table, this specifies the first file to parse.","player":"The \"owner\" of the instance","code":"Either a string of code, or a {path=source} table","dontpreprocess":"Set to true to skip preprocessing","context":"The context to use in the resulting Instance","data":"The table to set instance.data to. Default is a new table."}}],"tables":[],"description":"\n \nSF Compiler. \nCompiles code into an uninitialized Instance. \n","summary":"\n \nSF Compiler."},"libs_sh/input.lua":{"libraries":{"1":"input","input":{"comment":["---- Input library.","--- @client"],"functions":{"1":"getCursorPos","2":"getKeyName","3":"isControlDown","4":"isKeyDown","5":"isShiftDown","6":"lookupBinding","getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["---- Gets the position of the mouse","--- @return The x position of the mouse","--- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end","","local function runInputHook( hookname, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif SF.Permissions.check( instance.player, nil, \"input\" ) then","\t\t","\t\t","\t\t\tlocal ok, err, tr = instance:runScriptHook( hookname, key )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"Hook 'input' errored with \" .. err, tr )","\t\t\tend","\t\tend","\tend","end","","function PlayerButtonDown(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputPressed\", button )","\tend","end","","function PlayerButtonUp(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputReleased\", button )","\tend","end","","hook.Add( \"PlayerButtonDown\", \"SF_PlayerButtonDown\", PlayerButtonDown)","hook.Add( \"PlayerButtonUp\", \"SF_PlayerButtonUp\", PlayerButtonUp)",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["---- Gets the first key that is bound to the command passed","--- @param binding The name of the bind","--- @return The id of the first key bound","--- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","binding":"The name of the bind"}},"getKeyName":{"ret":"The name of the key","comment":["---- Gets the name of a key from the id","--- @param key The key id, see input","--- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input"}},"isKeyDown":{"ret":"True if the key is down","comment":["---- Gets whether a key is down","--- @param key The key id, see input","--- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input"}},"isControlDown":{"ret":"True if the control key is down","comment":["---- Gets whether the control key is down","--- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"isShiftDown":{"ret":"True if the shift key is down","comment":["---- Gets whether the shift key is down","--- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]}},"class":"library","summary":"\nInput library.","fields":[],"name":"input","client":true,"description":"\nInput library.","libtbl":"input_methods","tables":[],"code":["local input_methods, input_metamethods = SF.Libraries.Register( \"input\" )","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"input\", \"Input\", \"Allows the user to use the input library\" )","end",""]}},"type":"file","name":"libs_sh/input.lua","functions":{"1":"input_methods.getCursorPos","2":"input_methods.getKeyName","3":"input_methods.isControlDown","4":"input_methods.isKeyDown","5":"input_methods.isShiftDown","6":"input_methods.lookupBinding","input_methods.lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["---- Gets the first key that is bound to the command passed","--- @param binding The name of the bind","--- @return The id of the first key bound","--- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","binding":"The name of the bind"}},"input_methods.getKeyName":{"ret":"The name of the key","comment":["---- Gets the name of a key from the id","--- @param key The key id, see input","--- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input"}},"input_methods.getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["---- Gets the position of the mouse","--- @return The x position of the mouse","--- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end","","local function runInputHook( hookname, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif SF.Permissions.check( instance.player, nil, \"input\" ) then","\t\t","\t\t","\t\t\tlocal ok, err, tr = instance:runScriptHook( hookname, key )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"Hook 'input' errored with \" .. err, tr )","\t\t\tend","\t\tend","\tend","end","","function PlayerButtonDown(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputPressed\", button )","\tend","end","","function PlayerButtonUp(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputReleased\", button )","\tend","end","","hook.Add( \"PlayerButtonDown\", \"SF_PlayerButtonDown\", PlayerButtonDown)","hook.Add( \"PlayerButtonUp\", \"SF_PlayerButtonUp\", PlayerButtonUp)",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"input_methods.isControlDown":{"ret":"True if the control key is down","comment":["---- Gets whether the control key is down","--- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"input_methods.isKeyDown":{"ret":"True if the key is down","comment":["---- Gets whether a key is down","--- @param key The key id, see input","--- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input"}},"input_methods.isShiftDown":{"ret":"True if the shift key is down","comment":["---- Gets whether the shift key is down","--- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]}},"doc":[{"comment":["--- This should manage the player button hooks for singleplayer games."],"code":["local PlayerButtonDown, PlayerButtonUp","if game.SinglePlayer() then","\tif SERVER then","\t\tutil.AddNetworkString(\"sf_relayinput\")","\t\t"],"summary":"\nThis should manage the player button hooks for singleplayer games.","description":"\nThis should manage the player button hooks for singleplayer games.","param":[]},{"comment":["\t\t--- These should only get called if the game is singleplayer or listen"],"code":["\t\thook.Add( \"PlayerButtonDown\", \"SF_PlayerButtonDown\", function(ply, but)","\t\t\tnet.Start(\"sf_relayinput\")","\t\t\tnet.WriteBool(true)","\t\t\tnet.WriteInt(but, 16)","\t\t\tnet.Send(ply)","\t\tend )","\t\t","\t\thook.Add( \"PlayerButtonUp\", \"SF_PlayerButtonUp\", function(ply, but)","\t\t\tnet.Start(\"sf_relayinput\")","\t\t\tnet.WriteBool(false)","\t\t\tnet.WriteInt(but, 16)","\t\t\tnet.Send(ply)","\t\tend)","\telse","\t\tnet.Receive( \"sf_relayinput\", function(len, ply)","\t\t\tlocal down = net.ReadBool()","\t\t\tlocal key = net.ReadInt(16)","\t\t\tif down then","\t\t\t\tPlayerButtonDown(LocalPlayer(), key)","\t\t\telse","\t\t\t\tPlayerButtonUp(LocalPlayer(), key)","\t\t\tend","\t\tend )","\tend\t","end","if SERVER then return end",""],"summary":"\nThese should only get called if the game is singleplayer or listen ","description":"\nThese should only get called if the game is singleplayer or listen","param":[]},{"comment":["---- Input library.","--- @client"],"functions":{"1":"getCursorPos","2":"getKeyName","3":"isControlDown","4":"isKeyDown","5":"isShiftDown","6":"lookupBinding","getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["---- Gets the position of the mouse","--- @return The x position of the mouse","--- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end","","local function runInputHook( hookname, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif SF.Permissions.check( instance.player, nil, \"input\" ) then","\t\t","\t\t","\t\t\tlocal ok, err, tr = instance:runScriptHook( hookname, key )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"Hook 'input' errored with \" .. err, tr )","\t\t\tend","\t\tend","\tend","end","","function PlayerButtonDown(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputPressed\", button )","\tend","end","","function PlayerButtonUp(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputReleased\", button )","\tend","end","","hook.Add( \"PlayerButtonDown\", \"SF_PlayerButtonDown\", PlayerButtonDown)","hook.Add( \"PlayerButtonUp\", \"SF_PlayerButtonUp\", PlayerButtonUp)",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["---- Gets the first key that is bound to the command passed","--- @param binding The name of the bind","--- @return The id of the first key bound","--- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","binding":"The name of the bind"}},"getKeyName":{"ret":"The name of the key","comment":["---- Gets the name of a key from the id","--- @param key The key id, see input","--- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input"}},"isKeyDown":{"ret":"True if the key is down","comment":["---- Gets whether a key is down","--- @param key The key id, see input","--- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input"}},"isControlDown":{"ret":"True if the control key is down","comment":["---- Gets whether the control key is down","--- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"isShiftDown":{"ret":"True if the shift key is down","comment":["---- Gets whether the shift key is down","--- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]}},"class":"library","summary":"\nInput library.","fields":[],"name":"input","client":true,"description":"\nInput library.","libtbl":"input_methods","tables":[],"code":["local input_methods, input_metamethods = SF.Libraries.Register( \"input\" )","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"input\", \"Input\", \"Allows the user to use the input library\" )","end",""]},{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["---- Gets the first key that is bound to the command passed","--- @param binding The name of the bind","--- @return The id of the first key bound","--- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","binding":"The name of the bind"}},{"ret":"True if the key is down","comment":["---- Gets whether a key is down","--- @param key The key id, see input","--- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input"}},{"ret":"The name of the key","comment":["---- Gets the name of a key from the id","--- @param key The key id, see input","--- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input"}},{"ret":"True if the shift key is down","comment":["---- Gets whether the shift key is down","--- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]},{"ret":"True if the control key is down","comment":["---- Gets whether the control key is down","--- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["---- Gets the position of the mouse","--- @return The x position of the mouse","--- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end","","local function runInputHook( hookname, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif SF.Permissions.check( instance.player, nil, \"input\" ) then","\t\t","\t\t","\t\t\tlocal ok, err, tr = instance:runScriptHook( hookname, key )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"Hook 'input' errored with \" .. err, tr )","\t\t\tend","\t\tend","\tend","end","","function PlayerButtonDown(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputPressed\", button )","\tend","end","","function PlayerButtonUp(ply, button)","\tif IsFirstTimePredicted() then","\t\trunInputHook( \"inputReleased\", button )","\tend","end","","hook.Add( \"PlayerButtonDown\", \"SF_PlayerButtonDown\", PlayerButtonDown)","hook.Add( \"PlayerButtonUp\", \"SF_PlayerButtonUp\", PlayerButtonUp)",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},{"classForced":true,"summary":"\nCalled when a button is pressed ","comment":["---- Called when a button is pressed","--- @name inputPressed","--- @class hook","--- @param button Number of the button"],"code":[""],"description":"\nCalled when a button is pressed","class":"hook","name":"inputPressed","param":{"1":"button","button":"Number of the button"}},{"classForced":true,"summary":"\nCalled when a button is released ","comment":["---- Called when a button is released","--- @name inputReleased","--- @class hook","--- @param button Number of the button"],"code":[],"description":"\nCalled when a button is released","class":"hook","name":"inputReleased","param":{"1":"button","button":"Number of the button"}}],"tables":[],"description":"\nThis should manage the player button hooks for singleplayer games.","summary":"\nThis should manage the player button hooks for singleplayer games."},"permissions/providers_cl/files.lua":{"libraries":[],"type":"file","name":"permissions/providers_cl/files.lua","functions":[],"doc":[{"comment":["--- Starfall file library permission provider"],"code":["","-- start the provider table and set it to inherit from the default provider","local P = {}","P.__index = SF.Permissions.Provider","setmetatable( P, P )","","-- localize the result set","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","-- define what permission keys we will allow","local keys = {","\t[ \"file.read\" ] = true,","\t[ \"file.write\" ] = true,","\t[ \"file.exists\" ] = true","}","","function P:check ( principal, target, key )","\tif type( target ) ~= \"string\" then return NEUTRAL end","","\t-- allow if the localplayer is trying to write a file to their computer","\tif keys[ key ] and principal == LocalPlayer() then","\t\treturn ALLOW","\telse","\t\treturn DENY","\tend","end","","-- register the provider","SF.Permissions.registerProvider( P )"],"summary":"\nStarfall file library permission provider ","description":"\nStarfall file library permission provider","param":[]}],"tables":[],"description":"\nStarfall file library permission provider","summary":"\nStarfall file library permission provider "},"libs_sv/holograms.lua":{"libraries":{"1":"holograms","holograms":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Holograms\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"hologramsLeft","canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return false end","\treturn plyCount[ SF.instance.player ] < SF.Holograms.personalquota:GetInt()","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","\tSF.CheckType( pos, vec_meta )","\tSF.CheckType( ang, ang_meta )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","\tif scale then","\t\tSF.CheckType( scale, vec_meta )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = aunwrap( ang )","","\tlocal instance = SF.instance","\tlocal holodata = instance.data.holograms","\t","\tif plyCount[ instance.player ] >= SF.Holograms.personalquota:GetInt() then ","\t\tSF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 ) ","\tend","","\tlocal holoent = ents.Create( \"starfall_hologram\" )","\tif holoent and holoent:IsValid() then","\t\tSF.setPos( holoent, pos )","\t\tSF.setAng( holoent, ang )","\t\tholoent:SetModel( model )","\t\tholoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","\t\tholoent:Spawn()","","\t\tif CPPI then","\t\t\tholoent:CPPISetOwner( instance.player )","\t\tend","\t\t","\t\tif scale then","\t\t\tholoent:SetScale( scale )","\t\tend","","\t\tholodata.holos[ holoent ] = true","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t\t","\t\treturn wrap( holoent )","\tend","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},"hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\treturn SF.Holograms.personalquota:GetInt() - plyCount[ SF.instance.player ]","end"],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","code":["local holograms_library, holograms_library_metamethods = SF.Libraries.Register(\"holograms\")",""],"fields":[],"name":"holograms","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","libtbl":"holograms_library","tables":[],"server":true}},"type":"file","name":"libs_sv/holograms.lua","functions":{"1":"hologram_methods:getAnimationLength","2":"hologram_methods:getAnimationNumber","3":"hologram_methods:getFlexes","4":"hologram_methods:getPose","5":"hologram_methods:setAngVel","6":"hologram_methods:setAnimation","7":"hologram_methods:setClip","8":"hologram_methods:setFlexScale","9":"hologram_methods:setFlexWeight","10":"hologram_methods:setModel","11":"hologram_methods:setPose","12":"hologram_methods:setScale","13":"hologram_methods:setVel","14":"hologram_methods:suppressEngineLighting","15":"holograms_library.canSpawn","16":"holograms_library.create","17":"holograms_library.hologramsLeft","hologram_methods:getFlexes":{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},"hologram_methods:setModel":{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetModel( model )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},"hologram_methods:setFlexWeight":{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},"hologram_methods:getAnimationNumber":{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},"hologram_methods:setPose":{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},"hologram_methods:suppressEngineLighting":{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","\tSF.CheckType( suppress, \"boolean\" )","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetNetworkedBool( \"suppressEngineLighting\", suppress )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},"hologram_methods:setAnimation":{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},"holograms_library.canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return false end","\treturn plyCount[ SF.instance.player ] < SF.Holograms.personalquota:GetInt()","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"hologram_methods:setVel":{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, vec_meta )","\tlocal vel = vunwrap( vel )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},"hologram_methods:setFlexScale":{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},"hologram_methods:setScale":{"comment":["--- Sets the hologram scale","-- @param scale Vector new scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, vec_meta )","\tlocal scale = vunwrap( scale )","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"Vector new scale"}},"hologram_methods:getPose":{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},"hologram_methods:getAnimationLength":{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},"hologram_methods:setAngVel":{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, ang_meta )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( aunwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},"holograms_library.hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\treturn SF.Holograms.personalquota:GetInt() - plyCount[ SF.instance.player ]","end"],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]},"hologram_methods:setClip":{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, vec_meta )","\tSF.CheckType(normal, vec_meta )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]},"holograms_library.create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","\tSF.CheckType( pos, vec_meta )","\tSF.CheckType( ang, ang_meta )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","\tif scale then","\t\tSF.CheckType( scale, vec_meta )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = aunwrap( ang )","","\tlocal instance = SF.instance","\tlocal holodata = instance.data.holograms","\t","\tif plyCount[ instance.player ] >= SF.Holograms.personalquota:GetInt() then ","\t\tSF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 ) ","\tend","","\tlocal holoent = ents.Create( \"starfall_hologram\" )","\tif holoent and holoent:IsValid() then","\t\tSF.setPos( holoent, pos )","\t\tSF.setAng( holoent, ang )","\t\tholoent:SetModel( model )","\t\tholoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","\t\tholoent:Spawn()","","\t\tif CPPI then","\t\t\tholoent:CPPISetOwner( instance.player )","\t\tend","\t\t","\t\tif scale then","\t\t\tholoent:SetScale( scale )","\t\tend","","\t\tholodata.holos[ holoent ] = true","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t\t","\t\treturn wrap( holoent )","\tend","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]}},"doc":[{"comment":["--- Library for creating and manipulating physics-less models AKA \"Holograms\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"hologramsLeft","canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return false end","\treturn plyCount[ SF.instance.player ] < SF.Holograms.personalquota:GetInt()","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","\tSF.CheckType( pos, vec_meta )","\tSF.CheckType( ang, ang_meta )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","\tif scale then","\t\tSF.CheckType( scale, vec_meta )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = aunwrap( ang )","","\tlocal instance = SF.instance","\tlocal holodata = instance.data.holograms","\t","\tif plyCount[ instance.player ] >= SF.Holograms.personalquota:GetInt() then ","\t\tSF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 ) ","\tend","","\tlocal holoent = ents.Create( \"starfall_hologram\" )","\tif holoent and holoent:IsValid() then","\t\tSF.setPos( holoent, pos )","\t\tSF.setAng( holoent, ang )","\t\tholoent:SetModel( model )","\t\tholoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","\t\tholoent:Spawn()","","\t\tif CPPI then","\t\t\tholoent:CPPISetOwner( instance.player )","\t\tend","\t\t","\t\tif scale then","\t\t\tholoent:SetScale( scale )","\t\tend","","\t\tholodata.holos[ holoent ] = true","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t\t","\t\treturn wrap( holoent )","\tend","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},"hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\treturn SF.Holograms.personalquota:GetInt() - plyCount[ SF.instance.player ]","end"],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","code":["local holograms_library, holograms_library_metamethods = SF.Libraries.Register(\"holograms\")",""],"fields":[],"name":"holograms","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","libtbl":"holograms_library","tables":[],"server":true},{"comment":["--- Hologram type"],"code":["local hologram_methods, hologram_metamethods = SF.Typedef(\"Hologram\", SF.Entities.Metatable)","local wrap, unwrap = SF.CreateWrapper( hologram_metamethods, true, false, nil, SF.Entities.Metatable )","","local ang_meta, vec_meta, ent_meta","local vunwrap, aunwrap, ewrap, eunwrap","","SF.Libraries.AddHook(\"postload\", function()","\tang_meta = SF.Angles.Metatable","\tvec_meta = SF.Vectors.Metatable","\tent_meta = SF.Entities.Metatable","","\tvunwrap = SF.Vectors.Unwrap","\taunwrap = SF.Angles.Unwrap","\tewrap = SF.Entities.Wrap","\teunwrap = SF.Entities.Unwrap","end)","","SF.Holograms = {}","","SF.Holograms.personalquota = CreateConVar( \"sf_holograms_personalquota\", \"100\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of holograms allowed to spawn via Starfall scripts for a single instance\" )","","SF.Holograms.Methods = hologram_methods","SF.Holograms.Metatable = hologram_metamethods","SF.Holograms.Wrap = wrap","SF.Holograms.Unwrap = unwrap","","-- Table with player keys that automatically cleans when player leaves.","local plyCount = SF.EntityTable(\"playerHolos\")","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.holograms = {","\t\tholos = {},","\t\tcount = 0","\t}","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tlocal holos = inst.data.holograms.holos","\tlocal holo = next(holos)","\twhile holo do","\t\tif IsValid(holo) then","\t\t\tholo:Remove()","\t\tend","\t\tholo = next(holos, holo)","\tend","end)","","local function hologramOnDestroy(holoent, holodata, ply)","\tholodata.holos[holoent] = nil","\tif plyCount[ply] then","\t\tplyCount[ply] = plyCount[ply] - 1","\tend","end",""],"typtbl":"hologram_methods","fields":[],"name":"Hologram","summary":"\nHologram type ","description":"\nHologram type","class":"class","methods":{"1":"getAnimationLength","2":"getAnimationNumber","3":"getFlexes","4":"getPose","5":"setAngVel","6":"setAnimation","7":"setClip","8":"setFlexScale","9":"setFlexWeight","10":"setModel","11":"setPose","12":"setScale","13":"setVel","14":"suppressEngineLighting","setScale":{"comment":["--- Sets the hologram scale","-- @param scale Vector new scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, vec_meta )","\tlocal scale = vunwrap( scale )","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"Vector new scale"}},"getFlexes":{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},"setFlexWeight":{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},"getPose":{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},"setAngVel":{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, ang_meta )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( aunwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},"getAnimationNumber":{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},"setAnimation":{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},"setFlexScale":{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},"setPose":{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},"setVel":{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, vec_meta )","\tlocal vel = vunwrap( vel )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},"getAnimationLength":{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},"suppressEngineLighting":{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","\tSF.CheckType( suppress, \"boolean\" )","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetNetworkedBool( \"suppressEngineLighting\", suppress )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},"setModel":{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetModel( model )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},"setClip":{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, vec_meta )","\tSF.CheckType(normal, vec_meta )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]}}},{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, vec_meta )","\tlocal vel = vunwrap( vel )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, ang_meta )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( aunwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},{"comment":["--- Sets the hologram scale","-- @param scale Vector new scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, vec_meta )","\tlocal scale = vunwrap( scale )","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"Vector new scale"}},{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, vec_meta )","\tSF.CheckType(normal, vec_meta )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]},{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetModel( model )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","\tSF.CheckType( suppress, \"boolean\" )","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetNetworkedBool( \"suppressEngineLighting\", suppress )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","\tSF.CheckType( pos, vec_meta )","\tSF.CheckType( ang, ang_meta )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","\tif scale then","\t\tSF.CheckType( scale, vec_meta )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = aunwrap( ang )","","\tlocal instance = SF.instance","\tlocal holodata = instance.data.holograms","\t","\tif plyCount[ instance.player ] >= SF.Holograms.personalquota:GetInt() then ","\t\tSF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 ) ","\tend","","\tlocal holoent = ents.Create( \"starfall_hologram\" )","\tif holoent and holoent:IsValid() then","\t\tSF.setPos( holoent, pos )","\t\tSF.setAng( holoent, ang )","\t\tholoent:SetModel( model )","\t\tholoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","\t\tholoent:Spawn()","","\t\tif CPPI then","\t\t\tholoent:CPPISetOwner( instance.player )","\t\tend","\t\t","\t\tif scale then","\t\t\tholoent:SetScale( scale )","\t\tend","","\t\tholodata.holos[ holoent ] = true","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t\t","\t\treturn wrap( holoent )","\tend","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return false end","\treturn plyCount[ SF.instance.player ] < SF.Holograms.personalquota:GetInt()","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\treturn SF.Holograms.personalquota:GetInt() - plyCount[ SF.instance.player ]","end"],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]}],"tables":[],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\"."},"libs_sv/wire.lua":{"libraries":{"1":"wire","wire":{"comment":["--- Wire library. Handles wire inputs/outputs, wirelinks, etc."],"functions":{"1":"adjustInputs","2":"adjustOutputs","3":"create","4":"delete","5":"getInputs","6":"getOutputs","7":"getWirelink","8":"self","adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}}},"class":"library","fields":[],"name":"wire","summary":"\nWire library.","description":"\nWire library. Handles wire inputs/outputs, wirelinks, etc.","libtbl":"wire_library","tables":{"1":"ports","ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]}},"code":["local wire_library, wire_metamethods = SF.Libraries.Register( \"wire\" )","","function wire_metamethods.onLoad ( instance )","\tif not WireLib then return end","\tlocal ent = instance.data.entity","\tif ent.Inputs == nil then","\t\tWireLib.CreateInputs( ent, {} )","\tend","\tif ent.Outputs == nil then","\t\tWireLib.CreateOutputs( ent, {} )","\tend","","\tfunction ent:TriggerInput ( key, value )","\t\tself:runScriptHook( \"input\", key, SF.Wire.InputConverters[ self.Inputs[ key ].Type ]( value ) )","\tend","","\tfunction ent:ReadCell ( address )","\t\tlocal ret = tonumber( self:runScriptHookForResult( \"readcell\", address ) ) or 0","\t\treturn ret","\tend","","\tfunction ent:WriteCell ( address, data )","\t\tlocal ret = self:runScriptHookForResult( \"writecell\", address, data )","\t\treturn ret==nil or ret==true","\tend","","end","","SF.Wire = {}","SF.Wire.Library = wire_library",""]}},"type":"file","name":"libs_sv/wire.lua","functions":{"1":"SF.Wire.AddInputType","2":"SF.Wire.AddOutputType","3":"SF.Wire.WlUnwrap","4":"SF.Wire.WlWrap","5":"wire_library.adjustInputs","6":"wire_library.adjustOutputs","7":"wire_library.create","8":"wire_library.delete","9":"wire_library.getInputs","10":"wire_library.getOutputs","11":"wire_library.getWirelink","12":"wire_library.self","13":"wirelink_metatable.__index","14":"wirelink_metatable.__newindex","15":"wirelink_methods:entity","16":"wirelink_methods:getWiredTo","17":"wirelink_methods:getWiredToName","18":"wirelink_methods:inputType","19":"wirelink_methods:inputs","20":"wirelink_methods:isValid","21":"wirelink_methods:isWired","22":"wirelink_methods:outputType","23":"wirelink_methods:outputs","wirelink_methods:entity":{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},"wirelink_metatable.__index":{"summary":"\nRetrieves an output.","description":"\nRetrieves an output. Returns nil if the output doesn't exist.","comment":["--- Retrieves an output. Returns nil if the output doesn't exist."],"code":["wirelink_metatable.__index = function(self,k)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tif wirelink_methods[k] then","\t\treturn wirelink_methods[k]","\telse","\t\tlocal wl = wlunwrap(self)","\t\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\t\t","\t\tif type(k) == \"number\" then","\t\t\treturn wl.ReadCell and wl:ReadCell(k) or nil","\t\telse","\t\t\tlocal output = wl.Outputs and wl.Outputs[k]","\t\t\tif not output or not inputConverters[output.Type] then return end","\t\t\treturn inputConverters[output.Type](output.Value)","\t\tend","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__index","param":["self","k"]},"wirelink_methods:getWiredTo":{"ret":"The entity the wirelink is wired to","comment":["--- Returns what an input of the wirelink is wired to.","-- @param name Name of the input","-- @return The entity the wirelink is wired to"],"code":["function wirelink_methods:getWiredTo(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn SF.Entities.Wrap( input.Src )","\tend","end",""],"class":"function","name":"wirelink_methods:getWiredTo","summary":"\nReturns what an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns what an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input"}},"SF.Wire.WlUnwrap":{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlUnwrap","-- @param wrapped"],"code":["SF.Wire.WlUnwrap = wlunwrap","","-- ------------------------- Internal Library ------------------------- --","","-- Allowed Expression2's types in tables and their short names","local expression2types = {","\tn = \"NORMAL\",","\ts = \"STRING\",","\tv = \"VECTOR\",","\ta = \"ANGLE\",","\txwl = \"WIRELINK\",","\te = \"ENTITY\",","\tt = \"TABLE\"","}","","local function convertFromExpression2(value, shortTypeName)","\tlocal typ = expression2types[shortTypeName]","\tif not typ or not SF.Wire.InputConverters[typ] then return nil end","","\treturn SF.Wire.InputConverters[typ](value)","end","","local function convertToExpression2(value)","\tlocal typ = type(value)","","\t-- Simple type?","\tif typ == \"number\" then return value, \"n\"","\telseif typ == \"string\" then return value, \"s\"","\telseif typ == \"Vector\" then return {value.x, value.y, value.z}, \"v\"","\telseif typ == \"Angle\" then return {value.p, value.y, value.r}, \"a\"","","\t-- We've got a table there. Is it wrapped object?","\telseif typ == \"table\" then","\t\tlocal value = SF.Unsanitize(value)","\t\ttyp = type(value)","","\t\tif typ == \"table\" then ","\t\t\t-- It is still table, do recursive convert","\t\t\treturn SF.Wire.OutputConverters.TABLE(value), \"t\"","","\t\t-- Unwrapped entity (wirelink goes to this, but it returns it as entity; don't think somebody needs to put wirelinks in table)","\t\telseif typ == \"Entity\" then return value, \"e\" end","\tend","","\t-- Nothing found / unallowed type","\treturn nil, nil","end","","local function identity(data) return data end","local inputConverters =","{","\tNORMAL = identity,","\tSTRING = identity,","\tVECTOR = vwrap,","\tANGLE = vwrap,","\tWIRELINK = wlwrap,","\tENTITY = vwrap,","","\tTABLE = function(tbl)","\t\tif not tbl.s or not tbl.stypes or not tbl.n or not tbl.ntypes or not tbl.size then return {} end","\t\tif tbl.size == 0 then return {} end -- Don't waste our time","\t\tlocal conv = {}","","\t\t-- Key-numeric part of table","\t\tfor key, typ in pairs(tbl.ntypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.n[key], typ)","\t\tend","","\t\t-- Key-string part of table","\t\tfor key, typ in pairs(tbl.stypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.s[key], typ)","\t\tend","","\t\treturn conv","\tend","}","","local outputConverters =","{","\tNORMAL = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tNUMBER = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tSTRING = function(data)","\t\tSF.CheckType(data,\"string\",1)","\t\treturn data","\tend,","\tVECTOR = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Vector\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tANGLE = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Angle\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tENTITY = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Entity\" ] )","\t\treturn vunwrap( data )","\tend,","","\tTABLE = function(data)","\t\tSF.CheckType(data,\"table\",1)","","\t\tlocal tbl = {istable=true, size=0, n={}, ntypes={}, s={}, stypes={}}","","\t\tfor key, value in pairs(data) do","\t\t\tlocal value, shortType = convertToExpression2(value)","","\t\t\tif shortType then","\t\t\t\tif type(key) == \"string\" then","\t\t\t\t\ttbl.s[key] = value","\t\t\t\t\ttbl.stypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","","\t\t\t\telseif type(key) == \"number\" then","\t\t\t\t\ttbl.n[key] = value","\t\t\t\t\ttbl.ntypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","\t\t\t\tend","\t\t\tend","\t\tend","","\t\treturn tbl","\tend","}","","SF.Wire.InputConverters = inputConverters","SF.Wire.OutputConverters = outputConverters",""],"name":"SF.Wire.WlUnwrap","class":"function","description":"\n","param":{"1":"wrapped","wrapped":""}},"SF.Wire.WlWrap":{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlWrap","-- @param wirelink"],"code":["SF.Wire.WlWrap = wlwrap",""],"name":"SF.Wire.WlWrap","class":"function","description":"\n","param":{"1":"wirelink","wirelink":""}},"SF.Wire.AddOutputType":{"summary":"\nAdds an output type ","description":"\nAdds an output type","comment":["--- Adds an output type","-- @param name Output type name. Case insensitive.","-- @param deconverter The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"],"code":["function SF.Wire.AddOutputType(name, deconverter)","\toutputConverters[name:upper()] = deconverter","end","","-- ------------------------- Basic Wire Functions ------------------------- --",""],"private":false,"class":"function","name":"SF.Wire.AddOutputType","param":{"1":"name","2":"deconverter","name":"Output type name. Case insensitive.","deconverter":"The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"}},"wirelink_methods:isWired":{"comment":["--- Checks if an input is wired.","-- @param name Name of the input to check"],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":{"1":"name","name":"Name of the input to check"}},"wire_library.getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"wire_library.adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"wirelink_methods:outputType":{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},"wirelink_methods:outputs":{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]},"wire_library.create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"SF.Wire.AddInputType":{"summary":"\nAdds an input type ","description":"\nAdds an input type","comment":["--- Adds an input type","-- @param name Input type name. Case insensitive.","-- @param converter The function used to convert the wire data to SF data (eg, wrapping)"],"code":["function SF.Wire.AddInputType(name, converter)","\tinputConverters[name:upper()] = converter","end",""],"private":false,"class":"function","name":"SF.Wire.AddInputType","param":{"1":"name","2":"converter","name":"Input type name. Case insensitive.","converter":"The function used to convert the wire data to SF data (eg, wrapping)"}},"wirelink_methods:getWiredToName":{"ret":"String name of the output that the input is wired to.","comment":["--- Returns the name of the output an input of the wirelink is wired to.","-- @param name Name of the input of the wirelink.","-- @return String name of the output that the input is wired to."],"code":["function wirelink_methods:getWiredToName(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn input.SrcId","\tend","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:getWiredToName","summary":"\nReturns the name of the output an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns the name of the output an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input of the wirelink."}},"wire_library.getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"wirelink_methods:inputs":{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},"wire_library.delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"wire_library.getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"wirelink_methods:isValid":{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},"wire_library.self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"wirelink_methods:inputType":{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},"wire_library.adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}},"wirelink_metatable.__newindex":{"summary":"\nWrites to an input.","description":"\nWrites to an input.","comment":["--- Writes to an input."],"code":["wirelink_metatable.__newindex = function(self,k,v)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\tif type(k) == \"number\" then","\t\tSF.CheckType(v,\"number\")","\t\tif not wl.WriteCell then return","\t\telse wl:WriteCell(k,v) end","\telse","\t\tlocal input = wl.Inputs and wl.Inputs[k]","\t\tif not input or not outputConverters[input.Type] then return end","\t\tWireLib.TriggerInput(wl,k,outputConverters[input.Type](v))","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__newindex","param":["self","k","v"]}},"doc":[{"summary":"\n \nWire library.","description":"\n \nWire library. \n","comment":["-------------------------------------------------------------------------------","-- Wire library.","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Wire library. Handles wire inputs/outputs, wirelinks, etc."],"functions":{"1":"adjustInputs","2":"adjustOutputs","3":"create","4":"delete","5":"getInputs","6":"getOutputs","7":"getWirelink","8":"self","adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}}},"class":"library","fields":[],"name":"wire","summary":"\nWire library.","description":"\nWire library. Handles wire inputs/outputs, wirelinks, etc.","libtbl":"wire_library","tables":{"1":"ports","ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]}},"code":["local wire_library, wire_metamethods = SF.Libraries.Register( \"wire\" )","","function wire_metamethods.onLoad ( instance )","\tif not WireLib then return end","\tlocal ent = instance.data.entity","\tif ent.Inputs == nil then","\t\tWireLib.CreateInputs( ent, {} )","\tend","\tif ent.Outputs == nil then","\t\tWireLib.CreateOutputs( ent, {} )","\tend","","\tfunction ent:TriggerInput ( key, value )","\t\tself:runScriptHook( \"input\", key, SF.Wire.InputConverters[ self.Inputs[ key ].Type ]( value ) )","\tend","","\tfunction ent:ReadCell ( address )","\t\tlocal ret = tonumber( self:runScriptHookForResult( \"readcell\", address ) ) or 0","\t\treturn ret","\tend","","\tfunction ent:WriteCell ( address, data )","\t\tlocal ret = self:runScriptHookForResult( \"writecell\", address, data )","\t\treturn ret==nil or ret==true","\tend","","end","","SF.Wire = {}","SF.Wire.Library = wire_library",""]},{"comment":["--- Wirelink type","-- @server"],"code":["local wirelink_methods, wirelink_metatable = SF.Typedef(\"Wirelink\")","local wlwrap, wlunwrap = SF.CreateWrapper(wirelink_metatable,true,true)","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"wire.setOutputs\", \"Set outputs\", \"Allows the user to specify the set of outputs\" )","\tP.registerPrivilege( \"wire.setInputs\", \"Set inputs\", \"Allows the user to specify the set of inputs\" )","\tP.registerPrivilege( \"wire.output\", \"Output\", \"Allows the user to set the value of an output\" )","\tP.registerPrivilege( \"wire.input\", \"Input\", \"Allows the user to read the value of an input\" )","\tP.registerPrivilege( \"wire.wirelink.read\", \"Wirelink Read\", \"Allows the user to read from wirelink\" )","\tP.registerPrivilege( \"wire.wirelink.write\", \"Wirelink Write\", \"Allows the user to write to wirelink\" )","\tP.registerPrivilege( \"wire.createWire\", \"Create Wire\", \"Allows the user to create a wire between two entities\" )","\tP.registerPrivilege( \"wire.deleteWire\", \"Delete Wire\", \"Allows the user to delete a wire between two entities\" )","\tP.registerPrivilege( \"wire.getInputs\", \"Get Inputs\", \"Allows the user to get Inputs of an entity\" )","\tP.registerPrivilege( \"wire.getOutputs\", \"Get Outputs\", \"Allows the user to get Outputs of an entity\" )","end",""],"typtbl":"wirelink_methods","fields":[],"name":"Wirelink","summary":"\nWirelink type ","server":true,"description":"\nWirelink type","class":"class","methods":{"1":"entity","2":"getWiredTo","3":"getWiredToName","4":"inputType","5":"inputs","6":"isValid","7":"isWired","8":"outputType","9":"outputs","isValid":{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},"outputType":{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},"getWiredTo":{"ret":"The entity the wirelink is wired to","comment":["--- Returns what an input of the wirelink is wired to.","-- @param name Name of the input","-- @return The entity the wirelink is wired to"],"code":["function wirelink_methods:getWiredTo(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn SF.Entities.Wrap( input.Src )","\tend","end",""],"class":"function","name":"wirelink_methods:getWiredTo","summary":"\nReturns what an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns what an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input"}},"inputType":{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},"isWired":{"comment":["--- Checks if an input is wired.","-- @param name Name of the input to check"],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":{"1":"name","name":"Name of the input to check"}},"entity":{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},"getWiredToName":{"ret":"String name of the output that the input is wired to.","comment":["--- Returns the name of the output an input of the wirelink is wired to.","-- @param name Name of the input of the wirelink.","-- @return String name of the output that the input is wired to."],"code":["function wirelink_methods:getWiredToName(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn input.SrcId","\tend","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:getWiredToName","summary":"\nReturns the name of the output an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns the name of the output an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input of the wirelink."}},"inputs":{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},"outputs":{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]}}},{"classForced":true,"summary":"\n ","comment":["---","-- @class table","-- @name SF.Wire.WlMetatable"],"code":["SF.Wire.WlMetatable = wirelink_metatable","SF.Wire.WlMethods = wirelink_methods",""],"name":"SF.Wire.WlMetatable","class":"table","description":"\n","param":[]},{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlWrap","-- @param wirelink"],"code":["SF.Wire.WlWrap = wlwrap",""],"name":"SF.Wire.WlWrap","class":"function","description":"\n","param":{"1":"wirelink","wirelink":""}},{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlUnwrap","-- @param wrapped"],"code":["SF.Wire.WlUnwrap = wlunwrap","","-- ------------------------- Internal Library ------------------------- --","","-- Allowed Expression2's types in tables and their short names","local expression2types = {","\tn = \"NORMAL\",","\ts = \"STRING\",","\tv = \"VECTOR\",","\ta = \"ANGLE\",","\txwl = \"WIRELINK\",","\te = \"ENTITY\",","\tt = \"TABLE\"","}","","local function convertFromExpression2(value, shortTypeName)","\tlocal typ = expression2types[shortTypeName]","\tif not typ or not SF.Wire.InputConverters[typ] then return nil end","","\treturn SF.Wire.InputConverters[typ](value)","end","","local function convertToExpression2(value)","\tlocal typ = type(value)","","\t-- Simple type?","\tif typ == \"number\" then return value, \"n\"","\telseif typ == \"string\" then return value, \"s\"","\telseif typ == \"Vector\" then return {value.x, value.y, value.z}, \"v\"","\telseif typ == \"Angle\" then return {value.p, value.y, value.r}, \"a\"","","\t-- We've got a table there. Is it wrapped object?","\telseif typ == \"table\" then","\t\tlocal value = SF.Unsanitize(value)","\t\ttyp = type(value)","","\t\tif typ == \"table\" then ","\t\t\t-- It is still table, do recursive convert","\t\t\treturn SF.Wire.OutputConverters.TABLE(value), \"t\"","","\t\t-- Unwrapped entity (wirelink goes to this, but it returns it as entity; don't think somebody needs to put wirelinks in table)","\t\telseif typ == \"Entity\" then return value, \"e\" end","\tend","","\t-- Nothing found / unallowed type","\treturn nil, nil","end","","local function identity(data) return data end","local inputConverters =","{","\tNORMAL = identity,","\tSTRING = identity,","\tVECTOR = vwrap,","\tANGLE = vwrap,","\tWIRELINK = wlwrap,","\tENTITY = vwrap,","","\tTABLE = function(tbl)","\t\tif not tbl.s or not tbl.stypes or not tbl.n or not tbl.ntypes or not tbl.size then return {} end","\t\tif tbl.size == 0 then return {} end -- Don't waste our time","\t\tlocal conv = {}","","\t\t-- Key-numeric part of table","\t\tfor key, typ in pairs(tbl.ntypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.n[key], typ)","\t\tend","","\t\t-- Key-string part of table","\t\tfor key, typ in pairs(tbl.stypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.s[key], typ)","\t\tend","","\t\treturn conv","\tend","}","","local outputConverters =","{","\tNORMAL = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tNUMBER = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tSTRING = function(data)","\t\tSF.CheckType(data,\"string\",1)","\t\treturn data","\tend,","\tVECTOR = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Vector\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tANGLE = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Angle\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tENTITY = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Entity\" ] )","\t\treturn vunwrap( data )","\tend,","","\tTABLE = function(data)","\t\tSF.CheckType(data,\"table\",1)","","\t\tlocal tbl = {istable=true, size=0, n={}, ntypes={}, s={}, stypes={}}","","\t\tfor key, value in pairs(data) do","\t\t\tlocal value, shortType = convertToExpression2(value)","","\t\t\tif shortType then","\t\t\t\tif type(key) == \"string\" then","\t\t\t\t\ttbl.s[key] = value","\t\t\t\t\ttbl.stypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","","\t\t\t\telseif type(key) == \"number\" then","\t\t\t\t\ttbl.n[key] = value","\t\t\t\t\ttbl.ntypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","\t\t\t\tend","\t\t\tend","\t\tend","","\t\treturn tbl","\tend","}","","SF.Wire.InputConverters = inputConverters","SF.Wire.OutputConverters = outputConverters",""],"name":"SF.Wire.WlUnwrap","class":"function","description":"\n","param":{"1":"wrapped","wrapped":""}},{"summary":"\nAdds an input type ","description":"\nAdds an input type","comment":["--- Adds an input type","-- @param name Input type name. Case insensitive.","-- @param converter The function used to convert the wire data to SF data (eg, wrapping)"],"code":["function SF.Wire.AddInputType(name, converter)","\tinputConverters[name:upper()] = converter","end",""],"private":false,"class":"function","name":"SF.Wire.AddInputType","param":{"1":"name","2":"converter","name":"Input type name. Case insensitive.","converter":"The function used to convert the wire data to SF data (eg, wrapping)"}},{"summary":"\nAdds an output type ","description":"\nAdds an output type","comment":["--- Adds an output type","-- @param name Output type name. Case insensitive.","-- @param deconverter The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"],"code":["function SF.Wire.AddOutputType(name, deconverter)","\toutputConverters[name:upper()] = deconverter","end","","-- ------------------------- Basic Wire Functions ------------------------- --",""],"private":false,"class":"function","name":"SF.Wire.AddOutputType","param":{"1":"name","2":"deconverter","name":"Output type name. Case insensitive.","deconverter":"The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"}},{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}},{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},{"summary":"\nRetrieves an output.","description":"\nRetrieves an output. Returns nil if the output doesn't exist.","comment":["--- Retrieves an output. Returns nil if the output doesn't exist."],"code":["wirelink_metatable.__index = function(self,k)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tif wirelink_methods[k] then","\t\treturn wirelink_methods[k]","\telse","\t\tlocal wl = wlunwrap(self)","\t\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\t\t","\t\tif type(k) == \"number\" then","\t\t\treturn wl.ReadCell and wl:ReadCell(k) or nil","\t\telse","\t\t\tlocal output = wl.Outputs and wl.Outputs[k]","\t\t\tif not output or not inputConverters[output.Type] then return end","\t\t\treturn inputConverters[output.Type](output.Value)","\t\tend","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__index","param":["self","k"]},{"summary":"\nWrites to an input.","description":"\nWrites to an input.","comment":["--- Writes to an input."],"code":["wirelink_metatable.__newindex = function(self,k,v)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\tif type(k) == \"number\" then","\t\tSF.CheckType(v,\"number\")","\t\tif not wl.WriteCell then return","\t\telse wl:WriteCell(k,v) end","\telse","\t\tlocal input = wl.Inputs and wl.Inputs[k]","\t\tif not input or not outputConverters[input.Type] then return end","\t\tWireLib.TriggerInput(wl,k,outputConverters[input.Type](v))","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__newindex","param":["self","k","v"]},{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]},{"comment":["--- Checks if an input is wired.","-- @param name Name of the input to check"],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":{"1":"name","name":"Name of the input to check"}},{"ret":"The entity the wirelink is wired to","comment":["--- Returns what an input of the wirelink is wired to.","-- @param name Name of the input","-- @return The entity the wirelink is wired to"],"code":["function wirelink_methods:getWiredTo(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn SF.Entities.Wrap( input.Src )","\tend","end",""],"class":"function","name":"wirelink_methods:getWiredTo","summary":"\nReturns what an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns what an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input"}},{"ret":"String name of the output that the input is wired to.","comment":["--- Returns the name of the output an input of the wirelink is wired to.","-- @param name Name of the input of the wirelink.","-- @return String name of the output that the input is wired to."],"code":["function wirelink_methods:getWiredToName(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn input.SrcId","\tend","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:getWiredToName","summary":"\nReturns the name of the output an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns the name of the output an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input of the wirelink."}},{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]},{"classForced":true,"summary":"\nCalled when an input on a wired SF chip is written to ","comment":["--- Called when an input on a wired SF chip is written to","-- @name input","-- @class hook","-- @param input The input name","-- @param value The value of the input"],"code":[""],"description":"\nCalled when an input on a wired SF chip is written to","class":"hook","name":"input","param":{"1":"input","2":"value","input":"The input name","value":"The value of the input"}},{"ret":"The value read","description":"\nCalled when a high speed device reads from a wired SF chip","code":[""],"class":"hook","classForced":true,"name":"readcell","summary":"\nCalled when a high speed device reads from a wired SF chip ","server":true,"comment":["--- Called when a high speed device reads from a wired SF chip","-- @name readcell","-- @class hook","-- @server","-- @param address The address requested","-- @return The value read"],"param":{"1":"address","address":"The address requested"}},{"classForced":true,"summary":"\nCalled when a high speed device writes to a wired SF chip ","comment":["--- Called when a high speed device writes to a wired SF chip","-- @name writecell","-- @class hook","-- @param address The address written to","-- @param data The data being written"],"code":[],"description":"\nCalled when a high speed device writes to a wired SF chip","class":"hook","name":"writecell","param":{"1":"address","2":"data","data":"The data being written","address":"The address written to"}}],"tables":{"1":"SF.Wire.WlMetatable","2":"wire_library.ports","wire_library.ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]},"SF.Wire.WlMetatable":{"classForced":true,"summary":"\n ","comment":["---","-- @class table","-- @name SF.Wire.WlMetatable"],"code":["SF.Wire.WlMetatable = wirelink_metatable","SF.Wire.WlMethods = wirelink_methods",""],"name":"SF.Wire.WlMetatable","class":"table","description":"\n","param":[]}},"description":"\n \nWire library. \n","summary":"\n \nWire library."},"sfderma.lua":{"libraries":[],"type":"file","name":"sfderma.lua","functions":[],"doc":[{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- Starfall Button","PANEL = {}","","function PANEL:Init ()","\tself:SetText( \"\" )","\tself:SetSize( 22, 22 )","end","function PANEL:SetIcon ( icon )","\tself.icon = SF.Editor.icons[ icon ]","end","function PANEL:PerformLayout ()","\tif self:GetText() ~= \"\" then","\t\tself:SizeToContentsX()","\t\tself:SetWide( self:GetWide() + 14 )","\tend","end","PANEL.Paint = function ( button, w, h )","\tif button.Hovered or button.active then","\t\tdraw.RoundedBox( 0, 0, 0, w, h, button.backgroundHoverCol or SF.Editor.colors.med )","\telse","\t\tdraw.RoundedBox( 0, 0, 0, w, h, button.backgroundCol or SF.Editor.colors.meddark )","\tend","\tif button.icon then","\t\tsurface.SetDrawColor( SF.Editor.colors.medlight )","\t\tsurface.SetMaterial( button.icon )","\t\tsurface.DrawTexturedRect( 2, 2, w - 4, h - 4 )","\tend","end","function PANEL:UpdateColours ( skin )","\treturn self:SetTextStyleColor( self.labelCol or SF.Editor.colors.light )","end","function PANEL:SetHoverColor ( col )","\tself.backgroundHoverCol = col","end","function PANEL:SetColor ( col )","\tself.backgroundCol = col","end","function PANEL:SetLabelColor ( col )","\tself.labelCol = col","end","function PANEL:DoClick ()","","end","","vgui.Register( \"StarfallButton\", PANEL, \"DButton\" )","-- End Starfall Button",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- Starfall Panel","PANEL = {}","PANEL.Paint = function ( panel, w, h )","\tdraw.RoundedBox( 0, 0, 0, w, h, SF.Editor.colors.light )","end","vgui.Register( \"StarfallPanel\", PANEL, \"DPanel\" )","-- End Starfall Panel",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- Tab Holder","PANEL = {}","","function PANEL:Init ()","\tself:SetTall( 22 )","\tself.offsetTabs = 0","\tself.tabs = {}","","\tlocal parent = self","","\tself.offsetRight = vgui.Create( \"StarfallButton\", self )","\tself.offsetRight:SetVisible( false )","\tself.offsetRight:SetSize( 22, 22 )","\tself.offsetRight:SetIcon( \"arrowr\" )","\tfunction self.offsetRight:PerformLayout ()","\t\tlocal wide = 0","\t\tif parent.offsetLeft:IsVisible() then ","\t\t\twide = parent.offsetLeft:GetWide() + 2 ","\t\tend","\t\tfor i = parent.offsetTabs + 1, #parent.tabs do","\t\t\tif wide + parent.tabs[ i ]:GetWide() > parent:GetWide() - self:GetWide() - 2 then ","\t\t\t\tbreak ","\t\t\telse","\t\t\t\twide = wide + parent.tabs[ i ]:GetWide() + 2","\t\t\tend","\t\tend","\t\tself:SetPos( wide, 0 )","\tend","\tfunction self.offsetRight:DoClick ()","\t\tparent.offsetTabs = parent.offsetTabs + 1","\t\tif parent.offsetTabs > #parent.tabs - 1 then","\t\t\tparent.offsetTabs = #parent.tabs - 1","\t\tend","\t\tparent:InvalidateLayout()","\tend","","\tself.offsetLeft = vgui.Create( \"StarfallButton\", self )","\tself.offsetLeft:SetVisible( false )","\tself.offsetLeft:SetSize( 22, 22 )","\tself.offsetLeft:SetIcon( \"arrowl\" )","\tfunction self.offsetLeft:DoClick ()","\t\tparent.offsetTabs = parent.offsetTabs - 1","\t\tif parent.offsetTabs < 0 then","\t\t\tparent.offsetTabs = 0","\t\tend","\t\tparent:InvalidateLayout()","\tend","","\tself.menuoptions = {}","","\tself.menuoptions[ #self.menuoptions + 1 ] = { \"Close\", function ()","\t\tif not self.targetTab then return end","\t\tself:removeTab( self.targetTab )","\t\tself.targetTab = nil","\tend }","\tself.menuoptions[ #self.menuoptions + 1 ] = { \"Close Other Tabs\", function ()","\t\tif not self.targetTab then return end","\t\tlocal n = 1","\t\twhile #self.tabs ~= 1 do","\t\t\tv = self.tabs[ n ]","\t\t\tif v ~= self.targetTab then ","\t\t\t\tself:removeTab( v )","\t\t\telse","\t\t\t\tn = 2","\t\t\tend","\t\tend","\t\tself.targetTab = nil","\tend }","end ","PANEL.Paint = function () end","function PANEL:PerformLayout ()","\tlocal parent = self:GetParent()","\tself:SetWide( parent:GetWide() - 10 )","\tself.offsetRight:PerformLayout()","\tself.offsetLeft:PerformLayout()","","\tlocal offset = 0","\tif self.offsetLeft:IsVisible() then","\t\toffset = self.offsetLeft:GetWide() + 2","\tend","\tfor i = 1, self.offsetTabs do","\t\toffset = offset - self.tabs[ i ]:GetWide() - 2","\tend","\tlocal bool = false","\tfor k, v in pairs( self.tabs ) do","\t\tv:SetPos( offset, 0 )","\t\tif offset < 0 then","\t\t\tv:SetVisible( false )","\t\telseif offset + v:GetWide() > self:GetWide() - self.offsetRight:GetWide() - 2 then","\t\t\tv:SetVisible( false )","\t\t\tbool = true","\t\telse","\t\t\tv:SetVisible( true )","\t\tend","\t\toffset = offset + v:GetWide() + 2","\tend","","\tif bool then","\t\tself.offsetRight:SetVisible( true )","\telse","\t\tself.offsetRight:SetVisible( false )","\tend","\tif self.offsetTabs > 0 then","\t\tself.offsetLeft:SetVisible( true )","\telse","\t\tself.offsetLeft:SetVisible( false )","\tend","end","function PANEL:addTab ( text )","\tlocal panel = self","\tlocal tab = vgui.Create( \"StarfallButton\", self )","\ttab:SetText( text )","\ttab.isTab = true","","\tfunction tab:DoClick ()","\t\tpanel:selectTab( self )","\tend","","\tfunction tab:DoRightClick ()","\t\tpanel.targetTab = self","\t\tlocal menu = vgui.Create( \"DMenu\", panel:GetParent() )","\t\tfor k, v in pairs( panel.menuoptions ) do","\t\t\tlocal option, func = v[ 1 ], v[ 2 ]","\t\t\tif func == \"SPACER\" then","\t\t\t\tmenu:AddSpacer()","\t\t\telse","\t\t\t\tmenu:AddOption( option, func )","\t\t\tend","\t\tend","\t\tmenu:Open()","\tend","","\tfunction tab:DoMiddleClick ()","\t\tpanel:removeTab( self )","\tend","","\tself.tabs[ #self.tabs + 1 ] = tab","","\treturn tab","end","function PANEL:removeTab ( tab )","\tlocal tabIndex ","\tif type( tab ) == \"number\" then","\t\ttabIndex = tab","\t\ttab = self.tabs[ tab ]  ","\telse","\t\ttabIndex = self:getTabIndex( tab )","\tend","","\ttable.remove( self.tabs, tabIndex )","\ttab:Remove()","","\tself:OnRemoveTab( tabIndex )","end","function PANEL:getActiveTab ()","\tfor k,v in pairs( self.tabs ) do","\t\tif v.active then return v end","\tend","end","function PANEL:getTabIndex ( tab )","\treturn table.KeyFromValue( self.tabs, tab )","end","function PANEL:selectTab ( tab )","\tif type( tab ) == \"number\" then","\t\ttab = self.tabs[ tab ]  ","\tend","\tif tab == nil then return end","","\tif self:getActiveTab() == tab then return end","","\tfor k,v in pairs( self.tabs ) do","\t\tv.active = false","\tend","\ttab.active = true","","\tif self:getTabIndex( tab ) <= self.offsetTabs then","\t\tself.offsetTabs = self:getTabIndex( tab ) - 1","\telseif not tab:IsVisible() then","\t\twhile not tab:IsVisible() do","\t\t\tself.offsetTabs = self.offsetTabs + 1","\t\t\tself:PerformLayout()","\t\tend","\tend","end","function PANEL:OnRemoveTab ( tabIndex )","","end","vgui.Register( \"StarfallTabHolder\", PANEL, \"DPanel\" )","-- End Tab Holder",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- File Tree","local invalid_filename_chars = {","\t[\"*\"] = \"\",","\t[\"?\"] = \"\",","\t[\">\"] = \"\",","\t[\"<\"] = \"\",","\t[\"|\"] = \"\",","\t[\"\\\\\"] = \"\",","\t['\"'] = \"\",","}","","PANEL = {}","","function PANEL:Init ()","","end","function PANEL:setup ( folder )","\tself.folder = folder","\tself.Root = self.RootNode:AddFolder( folder, folder, \"DATA\", true )","\tself.Root:SetExpanded( true )","end","function PANEL:reloadTree ()","\tself.Root:Remove()","\tself:setup( self.folder )","end","function PANEL:DoRightClick ( node )","\tself:openMenu( node )","end","function PANEL:openMenu ( node )","\tlocal menu","\tif node:GetFileName() then","\t\tmenu = \"file\"","\telseif node:GetFolder() then","\t\tmenu = \"folder\"","\tend","\tself.menu = vgui.Create( \"DMenu\", self:GetParent() )","\tif menu == \"file\" then","\t\tself.menu:AddOption( \"Open\", function ()","\t\t\tself:OnNodeSelected( node )","\t\tend )","\t\tself.menu:AddSpacer()","\t\tself.menu:AddOption( \"Rename\", function ()","\t\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"Rename file\",","\t\t\t\t\"\",","\t\t\t\tstring.StripExtension( node:GetText() ),","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal oldFile = node:GetFileName()","\t\t\t\t\tlocal saveFile = string.GetPathFromFilename( oldFile ) .. \"/\" .. text ..\".txt\"","\t\t\t\t\tlocal contents = file.Read( oldFile )","\t\t\t\t\tfile.Delete( node:GetFileName() )","\t\t\t\t\tfile.Write( saveFile, contents )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"File renamed as \" .. saveFile .. \".\", NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend","\t\t\t)","\t\tend )","\t\tself.menu:AddSpacer()","\t\tself.menu:AddOption( \"Delete\", function ()","\t\t\tDerma_Query(","\t\t\t\t\"Are you sure you want to delete this file?\",","\t\t\t\t\"Delete file\",","\t\t\t\t\"Delete\",","\t\t\t\tfunction ()","\t\t\t\t\tfile.Delete( node:GetFileName() )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"File deleted: \" .. node:GetFileName(), NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend,","\t\t\t\t\"Cancel\"","\t\t\t)","\t\tend )","\telseif menu == \"folder\" then","\t\tself.menu:AddOption( \"New file\", function ()","\t\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"New file\",","\t\t\t\t\"\",","\t\t\t\t\"\",","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal saveFile = node:GetFolder()..\"/\"..text..\".txt\"","\t\t\t\t\tfile.Write( saveFile, \"\" )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"New file: \" .. saveFile, NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend","\t\t\t)","\t\tend )","\t\tself.menu:AddSpacer()","\t\tself.menu:AddOption( \"New folder\", function ()","\t\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"New folder\",","\t\t\t\t\"\",","\t\t\t\t\"\",","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal saveFile = node:GetFolder()..\"/\"..text","\t\t\t\t\tfile.CreateDir( saveFile )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"New folder: \" .. saveFile, NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend","\t\t\t)","\t\tend )","\t\tself.menu:AddSpacer()","\t\tself.menu:AddOption( \"Delete\", function ()","\t\t\tDerma_Query(","\t\t\t\t\"Are you sure you want to delete this folder?\",","\t\t\t\t\"Delete folder\",","\t\t\t\t\"Delete\",","\t\t\t\tfunction ()","\t\t\t\t\t-- Recursive delete","\t\t\t\t\tlocal folders = {}","\t\t\t\t\tfolders[ #folders + 1 ] = node:GetFolder()","\t\t\t\t\twhile #folders > 0 do","\t\t\t\t\t\tlocal folder = folders[ #folders ]","\t\t\t\t\t\tlocal files, directories = file.Find( folder..\"/*\", \"DATA\" )","\t\t\t\t\t\tfor I=1, #files do","\t\t\t\t\t\t\tfile.Delete( folder .. \"/\" .. files[I] )","\t\t\t\t\t\tend","\t\t\t\t\t\tif #directories == 0 then","\t\t\t\t\t\t\tfile.Delete( folder )","\t\t\t\t\t\t\tfolders[ #folders ] = nil","\t\t\t\t\t\telse","\t\t\t\t\t\t\tfor I=1, #directories do","\t\t\t\t\t\t\t\tfolders[ #folders + 1 ] = folder .. \"/\" .. directories[ I ]","\t\t\t\t\t\t\tend","\t\t\t\t\t\tend","\t\t\t\t\tend","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"Folder deleted: \" .. node:GetFolder(), NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend,","\t\t\t\t\"Cancel\"","\t\t\t)","\t\tend )","\tend","\tself.menu:Open()","end","","","derma.DefineControl( \"StarfallFileTree\", \"\", PANEL, \"DTree\" )","-- End File Tree",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- File Browser","PANEL = {}","","function PANEL:Init ()","","\tself:Dock( FILL )","\tself:DockMargin( 0, 5, 0, 0 )","\tself.Paint = function () end","","\tlocal tree = vgui.Create( \"StarfallFileTree\", self )","\ttree:Dock( FILL )","","\tself.tree = tree","","\tlocal searchBox = vgui.Create( \"DTextEntry\", self )","\tsearchBox:Dock( TOP )","\tsearchBox:SetValue( \"Search...\" )","","\tsearchBox._OnGetFocus = searchBox.OnGetFocus","\tfunction searchBox:OnGetFocus ()","\t\tif self:GetValue() == \"Search...\" then","\t\t\tself:SetValue( \"\" )","\t\tend","\t\tsearchBox:_OnGetFocus()","\tend","","\tsearchBox._OnLoseFocus = searchBox.OnLoseFocus","\tfunction searchBox:OnLoseFocus ()","\t\tif self:GetValue() == \"\" then","\t\t\tself:SetText( \"Search...\" )","\t\tend","\t\tsearchBox:_OnLoseFocus()","\tend","","\tfunction searchBox:OnChange ()","","\t\tif self:GetValue() == \"\" then","\t\t\ttree:reloadTree()","\t\t\treturn","\t\tend","","\t\ttree.Root.ChildNodes:Clear()","\t\tlocal function containsFile ( dir, search )","\t\t\tlocal files, folders = file.Find( dir .. \"/*\", \"DATA\" )","\t\t\tfor k, file in pairs( files ) do","\t\t\t\tif string.find( string.lower( file ), string.lower( search ) ) then return true end","\t\t\tend","\t\t\tfor k, folder in pairs( folders ) do","\t\t\t\tif containsFile( dir .. \"/\" .. folder, search ) then return true end","\t\t\tend","\t\t\treturn false","\t\tend","\t\tlocal function addFiles ( search, dir, node )","\t\t\tlocal allFiles, allFolders = file.Find( dir .. \"/*\", \"DATA\" )","\t\t\tfor k, v in pairs( allFolders ) do","\t\t\t\tif containsFile( dir .. \"/\" .. v, search ) then","\t\t\t\t\tlocal newNode = node:AddNode( v )","\t\t\t\t\tnewNode:SetExpanded( true )","\t\t\t\t\taddFiles( search, dir .. \"/\" .. v, newNode )","\t\t\t\tend","\t\t\tend","\t\t\tfor k, v in pairs( allFiles ) do","\t\t\t\tif string.find( string.lower( v ), string.lower( search ) ) then","\t\t\t\t\tnode:AddNode( v, \"icon16/page_white.png\" )","\t\t\t\tend","\t\t\tend","\t\tend","\t\taddFiles( self:GetValue():PatternSafe(), \"starfall\", tree.Root )","\t\ttree.Root:SetExpanded( true )","\tend","\tself.searchBox = searchBox","","\tself.Update = vgui.Create(\"DButton\", self)","\tself.Update:SetTall(20)","\tself.Update:Dock(BOTTOM)","\tself.Update:DockMargin(0, 0, 0, 0)","\tself.Update:SetText(\"Update\")","\tself.Update.DoClick = function(button)","\t\ttree:reloadTree()","\tend","end","function PANEL:getComponents ()","\treturn self.searchBox, self.tree","end","","derma.DefineControl( \"StarfallFileBrowser\", \"\", PANEL, \"DPanel\" )","-- End File Browser"],"summary":"\n \n ","description":"\n \n","param":[]}],"tables":[],"description":"\n \n","summary":"\n \n "},"libs_sh/coroutine.lua":{"libraries":{"1":"coroutine","coroutine":{"comment":["--- Coroutine library","-- @shared"],"functions":{"1":"create","2":"resume","3":"running","4":"status","5":"wait","6":"wrap","7":"yield","resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},"running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn SF.instance.data.coroutines[ thread ]","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedThread","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tSF.CheckType( time, \"number\" )","\tcoroutine.wait( time )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}},"class":"library","summary":"\nCoroutine library ","code":["local coroutine_library, _ = SF.Libraries.Register( \"coroutine\" )","local coroutine = coroutine","","local _, thread_metamethods = SF.Typedef( \"thread\" )","local wrap, unwrap = SF.CreateWrapper( thread_metamethods, true, false )","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.coroutines = setmetatable( {}, { __mode = \"v\" } )","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor thread, wrapped in pairs(instance.data.coroutines) do","\t\tlocal unwrapped = unwrap( wrapped )","\t\tunwrapped.thread = nil","\t\tunwrapped.func = nil","\t\tinstance.data.coroutines[ thread ] = nil","\tend","end)","","","local function createCoroutine ( func )","\t-- Can't use coroutine.create, because of a bug that prevents halting the program when it exceeds quota","","\t-- Hack to get the coroutine from a wrapped function. Necessary because coroutine.create is not available","\tlocal wrappedFunc = coroutine.wrap( function() return func( coroutine.yield( coroutine.running() ) ) end ) ","\t","\tlocal thread = wrappedFunc()","","\tlocal wrappedThread = wrap( { thread = thread, func = wrappedFunc } )","\t","\tSF.instance.data.coroutines[ thread ] = wrappedThread","\t","\treturn wrappedFunc, wrappedThread","end",""],"fields":[],"name":"coroutine","client":true,"description":"\nCoroutine library","libtbl":"coroutine_library","tables":[],"server":true}},"type":"file","name":"libs_sh/coroutine.lua","functions":{"1":"coroutine_library.create","2":"coroutine_library.resume","3":"coroutine_library.running","4":"coroutine_library.status","5":"coroutine_library.wait","6":"coroutine_library.wrap","7":"coroutine_library.yield","coroutine_library.running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn SF.instance.data.coroutines[ thread ]","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"coroutine_library.wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tSF.CheckType( time, \"number\" )","\tcoroutine.wait( time )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}},"coroutine_library.status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"coroutine_library.resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"coroutine_library.create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedThread","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"coroutine_library.wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"coroutine_library.yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}}},"doc":[{"summary":"\nCoroutine library ","description":"\nCoroutine library","comment":["--- Coroutine library"],"code":[""]},{"comment":["--- Coroutine library","-- @shared"],"functions":{"1":"create","2":"resume","3":"running","4":"status","5":"wait","6":"wrap","7":"yield","resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},"running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn SF.instance.data.coroutines[ thread ]","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedThread","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tSF.CheckType( time, \"number\" )","\tcoroutine.wait( time )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}},"class":"library","summary":"\nCoroutine library ","code":["local coroutine_library, _ = SF.Libraries.Register( \"coroutine\" )","local coroutine = coroutine","","local _, thread_metamethods = SF.Typedef( \"thread\" )","local wrap, unwrap = SF.CreateWrapper( thread_metamethods, true, false )","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.coroutines = setmetatable( {}, { __mode = \"v\" } )","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor thread, wrapped in pairs(instance.data.coroutines) do","\t\tlocal unwrapped = unwrap( wrapped )","\t\tunwrapped.thread = nil","\t\tunwrapped.func = nil","\t\tinstance.data.coroutines[ thread ] = nil","\tend","end)","","","local function createCoroutine ( func )","\t-- Can't use coroutine.create, because of a bug that prevents halting the program when it exceeds quota","","\t-- Hack to get the coroutine from a wrapped function. Necessary because coroutine.create is not available","\tlocal wrappedFunc = coroutine.wrap( function() return func( coroutine.yield( coroutine.running() ) ) end ) ","\t","\tlocal thread = wrappedFunc()","","\tlocal wrappedThread = wrap( { thread = thread, func = wrappedFunc } )","\t","\tSF.instance.data.coroutines[ thread ] = wrappedThread","\t","\treturn wrappedFunc, wrappedThread","end",""],"fields":[],"name":"coroutine","client":true,"description":"\nCoroutine library","libtbl":"coroutine_library","tables":[],"server":true},{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedThread","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\tlocal wrappedFunc, wrappedThread = createCoroutine( func )","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn SF.instance.data.coroutines[ thread ]","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tSF.CheckType( time, \"number\" )","\tcoroutine.wait( time )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}],"tables":[],"description":"\nCoroutine library","summary":"\nCoroutine library "},"libs_sh/fastlz.lua":{"libraries":{"1":"fastlz","fastlz":{"comment":["--- FastLZ library","-- @shared"],"functions":{"1":"compress","2":"decompress","decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}},"compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}}},"class":"library","summary":"\nFastLZ library ","code":["local fastlz_library, _ = SF.Libraries.Register( \"fastlz\" )","local util = util",""],"fields":[],"name":"fastlz","client":true,"description":"\nFastLZ library","libtbl":"fastlz_library","tables":[],"server":true}},"type":"file","name":"libs_sh/fastlz.lua","functions":{"1":"fastlz_library.compress","2":"fastlz_library.decompress","fastlz_library.compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}},"fastlz_library.decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}}},"doc":[{"comment":["--- FastLZ library","-- @shared"],"functions":{"1":"compress","2":"decompress","decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}},"compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}}},"class":"library","summary":"\nFastLZ library ","code":["local fastlz_library, _ = SF.Libraries.Register( \"fastlz\" )","local util = util",""],"fields":[],"name":"fastlz","client":true,"description":"\nFastLZ library","libtbl":"fastlz_library","tables":[],"server":true},{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}},{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}}],"tables":[],"description":"\nFastLZ library","summary":"\nFastLZ library "},"permissions/providers_sv/default.lua":{"libraries":[],"type":"file","name":"permissions/providers_sv/default.lua","functions":[],"doc":[{"comment":["--- Default starfall permission provider"],"code":["","-- start the provider table and set it to inherit from the default provider","local P = {}","P.__index = SF.Permissions.Provider","setmetatable( P, P )","","-- localize the result set","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","local ES = SF.DB.escape;","","local function getUsergroupID ( ply )","\tif ply:IsSuperAdmin() then","\t\treturn 2","\telseif ply:IsAdmin() then","\t\treturn 1","\tend","\treturn 0","end","","local function getUsergroupName ( ply )","\tif ply:IsSuperAdmin() then","\t\treturn \"superadmin\"","\telseif ply:IsAdmin() then","\t\treturn \"admin\"","\tend","\treturn \"user\"","end","","function P:check ( principal, target, key )","\tlocal result = SF.DB.query( [[","\t\tSELECT grant","\t\tFROM starfall_perms_grants","\t\tWHERE\trole = ]] .. ES( getUsergroupID( principal ) ) .. [[","\t\t\tAND key = \"]] .. ES( key ) .. [[\"]]","\t)","","\tif result == false then","\t\terror( \"error in default provider \" .. sql.LastError() )","\tend","","\tif result and #result >= 1 then","\t\tlocal row = result[ 1 ]","\t\tlocal grant = row[ 'grant' ]","","\t\tif \"0\" == grant then","\t\t\treturn NEUTRAL","\t\telseif \"1\" == grant then","\t\t\treturn ALLOW","\t\telseif \"2\" == grant then","\t\t\treturn DENY","\t\tend","\telse","\t\treturn NEUTRAL","\tend","end","","-- register the provider","SF.Permissions.registerProvider( P )"],"summary":"\nDefault starfall permission provider ","description":"\nDefault starfall permission provider","param":[]}],"tables":[],"description":"\nDefault starfall permission provider","summary":"\nDefault starfall permission provider "},"libs_sv/constraint.lua":{"libraries":{"1":"constraint","constraint":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @server"],"functions":{"1":"axis","2":"ballsocket","3":"ballsocketadv","4":"breakAll","5":"breakType","6":"elastic","7":"getTable","8":"nocollide","9":"rope","10":"setElasticLength","11":"setRopeLength","12":"slider","13":"weld","ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( frictionv, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = width or 0","\tstrech = strech and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( const, \"number\" )","\tSF.CheckType( damp, \"number\" )","\tSF.CheckType( rdamp, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", math.Clamp( width, 0, 50), strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\tSF.CheckType( friction, \"number\" )","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = width or 0","\trigid = rigid and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( length, \"number\" )","\tSF.CheckType( addlength, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, math.Clamp( width, 0, 50), material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},"ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = width or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( width, \"number\" )","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, math.Clamp( width, 0, 50), \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","fields":[],"name":"constraint","code":["local constraint_library, constraint_library_metamethods = SF.Libraries.Register(\"constraint\")","","local vwrap = SF.WrapObject","local vunwrap = SF.UnwrapObject","local ewrap, eunwrap, ents_metatable","","SF.Libraries.AddHook(\"postload\", function()","\tewrap = SF.Entities.Wrap","\teunwrap = SF.Entities.Unwrap","\tents_metatable = SF.Entities.Metatable","end)","","local function checkConstraint(e, t)","\tif e then","\t\tif e:IsValid() then","\t\t\tif not SF.Permissions.check( SF.instance.player, e, t ) then","\t\t\t\tSF.throw( \"Insufficient permissions\", 3 )","\t\t\tend","\t\telseif not e:IsWorld() then","\t\t\tSF.throw( \"Invalid Entity\", 3 )","\t\tend","\telse","\t\tSF.throw( \"Invalid Entity\", 3 )","\tend","end","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"constraints.weld\", \"Weld\", \"Allows the user to weld two entities\" )","\tP.registerPrivilege( \"constraints.axis\", \"Axis\", \"Allows the user to axis two entities\" )","\tP.registerPrivilege( \"constraints.ballsocket\", \"Ballsocket\", \"Allows the user to ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.ballsocketadv\", \"BallsocketAdv\", \"Allows the user to advanced ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.slider\", \"Slider\", \"Allows the user to slider two entities\" )","\tP.registerPrivilege( \"constraints.rope\", \"Rope\", \"Allows the user to rope two entities\" )","\tP.registerPrivilege( \"constraints.elastic\", \"Elastic\", \"Allows the user to elastic two entities\" )","\tP.registerPrivilege( \"constraints.nocollide\", \"Nocollide\", \"Allows the user to nocollide two entities\" )","\tP.registerPrivilege( \"constraints.any\", \"Any\", \"General constraint functions\" )","end",""],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"constraint_library","tables":[],"server":true}},"type":"file","name":"libs_sv/constraint.lua","functions":{"1":"constraint_library.axis","2":"constraint_library.ballsocket","3":"constraint_library.ballsocketadv","4":"constraint_library.breakAll","5":"constraint_library.breakType","6":"constraint_library.elastic","7":"constraint_library.getTable","8":"constraint_library.nocollide","9":"constraint_library.rope","10":"constraint_library.setElasticLength","11":"constraint_library.setRopeLength","12":"constraint_library.slider","13":"constraint_library.weld","constraint_library.weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"constraint_library.ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"constraint_library.ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( frictionv, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"constraint_library.nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"constraint_library.breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"constraint_library.getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"constraint_library.elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = width or 0","\tstrech = strech and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( const, \"number\" )","\tSF.CheckType( damp, \"number\" )","\tSF.CheckType( rdamp, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", math.Clamp( width, 0, 50), strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"constraint_library.breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"constraint_library.setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"constraint_library.rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = width or 0","\trigid = rigid and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( length, \"number\" )","\tSF.CheckType( addlength, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, math.Clamp( width, 0, 50), material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"constraint_library.axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\tSF.CheckType( friction, \"number\" )","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"constraint_library.slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = width or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( width, \"number\" )","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, math.Clamp( width, 0, 50), \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]},"constraint_library.setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]}},"doc":[{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @server"],"functions":{"1":"axis","2":"ballsocket","3":"ballsocketadv","4":"breakAll","5":"breakType","6":"elastic","7":"getTable","8":"nocollide","9":"rope","10":"setElasticLength","11":"setRopeLength","12":"slider","13":"weld","ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( frictionv, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = width or 0","\tstrech = strech and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( const, \"number\" )","\tSF.CheckType( damp, \"number\" )","\tSF.CheckType( rdamp, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", math.Clamp( width, 0, 50), strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\tSF.CheckType( friction, \"number\" )","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = width or 0","\trigid = rigid and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( length, \"number\" )","\tSF.CheckType( addlength, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, math.Clamp( width, 0, 50), material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},"ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = width or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( width, \"number\" )","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, math.Clamp( width, 0, 50), \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","fields":[],"name":"constraint","code":["local constraint_library, constraint_library_metamethods = SF.Libraries.Register(\"constraint\")","","local vwrap = SF.WrapObject","local vunwrap = SF.UnwrapObject","local ewrap, eunwrap, ents_metatable","","SF.Libraries.AddHook(\"postload\", function()","\tewrap = SF.Entities.Wrap","\teunwrap = SF.Entities.Unwrap","\tents_metatable = SF.Entities.Metatable","end)","","local function checkConstraint(e, t)","\tif e then","\t\tif e:IsValid() then","\t\t\tif not SF.Permissions.check( SF.instance.player, e, t ) then","\t\t\t\tSF.throw( \"Insufficient permissions\", 3 )","\t\t\tend","\t\telseif not e:IsWorld() then","\t\t\tSF.throw( \"Invalid Entity\", 3 )","\t\tend","\telse","\t\tSF.throw( \"Invalid Entity\", 3 )","\tend","end","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"constraints.weld\", \"Weld\", \"Allows the user to weld two entities\" )","\tP.registerPrivilege( \"constraints.axis\", \"Axis\", \"Allows the user to axis two entities\" )","\tP.registerPrivilege( \"constraints.ballsocket\", \"Ballsocket\", \"Allows the user to ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.ballsocketadv\", \"BallsocketAdv\", \"Allows the user to advanced ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.slider\", \"Slider\", \"Allows the user to slider two entities\" )","\tP.registerPrivilege( \"constraints.rope\", \"Rope\", \"Allows the user to rope two entities\" )","\tP.registerPrivilege( \"constraints.elastic\", \"Elastic\", \"Allows the user to elastic two entities\" )","\tP.registerPrivilege( \"constraints.nocollide\", \"Nocollide\", \"Allows the user to nocollide two entities\" )","\tP.registerPrivilege( \"constraints.any\", \"Any\", \"General constraint functions\" )","end",""],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"constraint_library","tables":[],"server":true},{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\tSF.CheckType( friction, \"number\" )","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxv, SF.Types[ \"Vector\" ] )","\tSF.CheckType( frictionv, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( torque_lim, \"number\" )","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = width or 0","\tstrech = strech and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( const, \"number\" )","\tSF.CheckType( damp, \"number\" )","\tSF.CheckType( rdamp, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", math.Clamp( width, 0, 50), strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = width or 0","\trigid = rigid and true or false","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( length, \"number\" )","\tSF.CheckType( addlength, \"number\" )","\tSF.CheckType( force_lim, \"number\" )","\tSF.CheckType( width, \"number\" )","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, math.Clamp( width, 0, 50), material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = width or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\tSF.CheckType( width, \"number\" )","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, math.Clamp( width, 0, 50), \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]},{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tSF.CheckType( bone1, \"number\" )","\tSF.CheckType( bone2, \"number\" )","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( length, \"number\" )","\tlength = math.max( length, 0 )","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}}],"tables":[],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\"."},"permissions/providers_sv/CPPI.lua":{"libraries":[],"type":"file","name":"permissions/providers_sv/CPPI.lua","functions":[],"doc":[{"comment":["--- Provides permissions for entities based on CPPI if present"],"code":["","local P = setmetatable( {}, { __index = SF.Permissions.Provider } )","","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","local canTool = {","\t[ \"entities.parent\" ] = true,","\t[ \"entities.unparent\" ] = true,","\t[ \"entities.setSolid\" ] = true,","\t[ \"entities.setMass\" ] = true,","\t[ \"entities.enableGravity\" ] = true,","\t[ \"entities.enableMotion\" ] = true,","\t[ \"entities.enableDrag\" ] = true,","\t[ \"entities.applyDamage\" ] = true,","\t[ \"entities.remove\" ] = true,","\t[ \"entities.ignite\" ] = true,","\t[ \"entities.emitSound\" ] = true,","\t[ \"entities.setRenderPropery\" ] = true,","\t[ \"entities.canTool\" ] = true,","\t[ \"wire.createWire\" ] = true,","\t[ \"wire.deleteWire\" ] = true,","\t[ \"constraints.weld\" ] = true,","\t[ \"constraints.axis\" ] = true,","\t[ \"constraints.ballsocket\" ] = true,","\t[ \"constraints.ballsocketadv\" ] = true,","\t[ \"constraints.slider\" ] = true,","\t[ \"constraints.rope\" ] = true,","\t[ \"constraints.elastic\" ] = true,","\t[ \"constraints.nocollide\" ] = true,","\t[ \"constraints.any\" ] = true,","\t[ \"npcs.modify\" ] = true","}","","local canPhysgun = {","\t[ \"entities.applyForce\" ] = true,","\t[ \"entities.setPos\" ] = true,","\t[ \"entities.setAngles\" ] = true,","\t[ \"entities.setVelocity\" ] = true,","\t[ \"entities.setFrozen\" ] = true","}","","function P:check ( principal, target, key )","\tif not CPPI then return NEUTRAL end","\t","\tif canTool[ key ] then","\t\tif not IsValid( target:CPPIGetOwner() ) then return DENY end","\t\tif target:CPPICanTool( principal, \"starfall_ent_lib\" ) then return ALLOW end","\t\treturn DENY","\telseif canPhysgun[ key ] then","\t\tif target:IsPlayer() then","\t\t\tif hook.Call( \"PhysgunPickup\", GAMEMODE, principal, target ) ~= false then","\t\t\t\t-- Some mods expect a release when there's a player pickup involved.","\t\t\t\thook.Call( \"PhysgunDrop\", GAMEMODE, principal, target )","\t\t\t\treturn ALLOW","\t\t\telse","\t\t\t\treturn DENY","\t\t\tend","\t\telse","\t\t\tif not IsValid( target:CPPIGetOwner() ) then return DENY end","\t\t\tif target:CPPICanPhysgun( principal ) then return ALLOW end","\t\tend","\t\treturn DENY","\tend","","\treturn NEUTRAL","end","","SF.Permissions.registerProvider( P )"],"summary":"\nProvides permissions for entities based on CPPI if present ","description":"\nProvides permissions for entities based on CPPI if present","param":[]}],"tables":[],"description":"\nProvides permissions for entities based on CPPI if present","summary":"\nProvides permissions for entities based on CPPI if present "},"permissions/providers_sh/placeholder.lua":{"libraries":[],"type":"file","name":"permissions/providers_sh/placeholder.lua","functions":[],"doc":[{"comment":["--- Placeholder for the default provider. Allows a bunch of permissions for everyone"],"code":["","local P = setmetatable( {}, { __index = SF.Permissions.Provider } )","","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","local allow = {","\t[ \"find\" ] = true,","\t[ \"sound.create\" ] = true,","\t[ \"sound.modify\" ] = true,","\t[ \"wire.setOutputs\" ] = true,","\t[ \"wire.setInputs\" ] = true,","\t[ \"wire.output\" ] = true,","\t[ \"wire.input\" ] = true,","\t[ \"wire.wirelink.read\" ] = true,","\t[ \"wire.wirelink.write\" ] = true,","\t[ \"trace\" ] = true,","\t[ \"find\" ] = true","}","","function P:check ( principal, target, key )","\tif allow[ key ] then return ALLOW end","\treturn NEUTRAL","end","","SF.Permissions.registerProvider( P )"],"summary":"\nPlaceholder for the default provider.","description":"\nPlaceholder for the default provider. Allows a bunch of permissions for everyone","param":[]}],"tables":[],"description":"\nPlaceholder for the default provider. Allows a bunch of permissions for everyone","summary":"\nPlaceholder for the default provider."},"sfhelper.lua":{"libraries":[],"type":"file","name":"sfhelper.lua","functions":{"1":"helper.updateDocView","2":"helper.updateInfoPanel","helper.updateDocView":{"summary":"\nDoc View ---- \n ","description":"\nDoc View ---- \n","comment":["\t---- Doc View ----","\t------------------"],"code":["\tfunction helper.updateDocView( Line, Type )","\t\tlocal view = helper.DocView","\t\tview.DocName = Line:GetColumnText( 1 )","","\t\tview:GetVBar():SetScroll( 0 )","","\t\tif Type == 1 then","\t\t\tview.Title:SetText( \"Library - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.libraries[ view.DocName ]","\t\telseif Type == 2 then","\t\t\tview.Title:SetText( \"Type - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.classes[ view.DocName ]","\t\telseif Type == 3 then","\t\t\tview.Title:SetText( \"Hooks\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.hooks = SF.Docs.hooks","\t\t\tview.Doc.description = \"List of hooks available to SF scripts\"","\t\telseif Type == 4 then","\t\t\tview.Title:SetText( \"Preprocessor directives\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.directives = SF.Docs.directives","\t\t\tview.Doc.description = \"List of preprocessor directives\"","\t\telseif Type == 5 then","\t\t\tview.Title:SetText( view.DocName )","\t\t\tview.Doc = {example=SF.Docs.examples[view.DocName]}","\t\tend","\t\tlocal doc = view.Doc","\t\tview.Title:SizeToContents()","","\t\tif doc.description then","\t\t\tview.Description:SetText( string.Replace( doc.description, \"\\n\", \"\" ) )","\t\t\tview.Description:SizeToContents()","\t\t\tview.Description:SetWrap( true )","\t\t\tview.Description:SetAutoStretchVertical( true )","\t\t\tview.Description.Enabled = true","\t\telse","\t\t\tview.Description.Enabled = false","\t\tend","\t\t","\t\tif doc.example then","\t\t\tview.exampleCode:SetText( doc.example )","\t\t\tview.exampleCode:SetVisible(true)","\t\telse","\t\t\tview.exampleCode:SetVisible(false)","\t\tend","\t\t\t","\t\tif doc.deprecated then","\t\t\tview.Deprecated:SetVisible( true )","\t\t\tview.Deprecated.Enabled = true","\t\telse","\t\t\tview.Deprecated:SetVisible( false )","\t\t\tview.Deprecated.Enabled = false","\t\tend","\t\tfor _, labellist in pairs( helper.LabelLists ) do","\t\t\tif doc[ labellist.name ] and #doc[ labellist.name ] > 0 then","\t\t\t\tlabellist.label:SetVisible( true )","\t\t\t\tlabellist.label.Enabled = true","\t\t\t\tlabellist.label:SizeToContents()","\t\t\t\tlabellist.list:SetVisible( true )","\t\t\t\tlabellist.list:Clear()","\t\t\t\tlocal height = labellist.func( view, doc )","\t\t\t\tlabellist.list:SetTall( height )","\t\t\telse","\t\t\t\tlabellist.label:SetVisible( false )","\t\t\t\tlabellist.label.Enabled = false","\t\t\t\tlabellist.list:SetVisible( false )","\t\t\tend","\t\tend","","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView:SetPos( 166, 30 )","\thelper.DocView:SetVisible( false )","\thelper.Views.Doc = helper.DocView","","\thelper.DocView.Panel = vgui.Create( \"StarfallPanel\", helper.DocView )","","\thelper.DocView.Title = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Title:SetPos( 10, 5 )","\thelper.DocView.Title:SetFont( \"HelperTitle\" )","\thelper.DocView.Title.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Description = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Description:SetPos( 25, 40 )","\thelper.DocView.Description:SetFont( \"HelperText\" )","\thelper.DocView.Description.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Deprecated = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Deprecated:SetText( \"This library/type has been deprecated and will be removed in the future for the following reason: Pure Lua implementation. This can be done with a user library.\" )","\thelper.DocView.Deprecated:SetPos( 25, 40 )","\thelper.DocView.Deprecated:SetFont( \"HelperTextBold\" )","\thelper.DocView.Deprecated:SizeToContents()","\thelper.DocView.Deprecated:SetWrap( true )","\thelper.DocView.Deprecated:SetAutoStretchVertical( true )","\thelper.DocView.Deprecated.m_colText = Color( 210, 0, 0 )","\t","\thelper.DocView.exampleCode = vgui.Create( \"DTextEntry\", helper.DocView.Panel )","\thelper.DocView.exampleCode:SetMultiline( true )","\thelper.DocView.exampleCode:SetEditable( true )","\thelper.DocView.exampleCode:SetPos( 25, 60 )","\thelper.DocView.exampleCode:SetSize( 800, 1600 )","\thelper.DocView.exampleCode:SetFont( \"CodeBlock\" )","\thelper.DocView.exampleCode.m_colText = Color( 60, 60, 60 )","\thelper.DocView.exampleCode:SetVisible(false)","","\thelper.LabelLists = {}","\tlocal function createDocList( name, func, update )","\t\tlocal label = Label( name, helper.DocView.Panel )","\t\tlabel:SetPos( 10, 40 )","\t\tlabel:SetFont( \"HelperTitle\" )","\t\tlabel.m_colText = Color( 60, 60, 60 )","\t\thelper.DocView[ name .. \"Label\" ] = label","","\t\tlocal list = vgui.Create( \"DListView\", helper.DocView.Panel )","\t\tlist:SetPos( 25, 40 )","\t\tlist:SetMultiSelect( false )","\t\tlist:AddColumn( name ):SetFixedWidth( 150 )","\t\tlist:AddColumn( \"Description\" )","\t\thelper.DocView[ name .. \"List\" ] = list","\t\thelper.LabelLists[ #helper.LabelLists + 1 ] = { label = label, list = list, func = func, name = string.lower( name ) }","","\t\tfunction list:OnRowSelected( LineID, Line )","\t\t\tfor _, labellist in pairs( helper.LabelLists ) do ","\t\t\t\tif labellist.list ~= list then","\t\t\t\t\tlabellist.list:ClearSelection()","\t\t\t\tend","\t\t\tend","\t\t\tupdate( LineID, Line )","\t\tend","\tend","\tlocal function formatText( text, dontRemoveNewLines )","\t\ttext = text:Trim()","\t\tif not dontRemoveNewLines then text = string.Replace( text, \"\\n\", \"\" ) end","\t\ttext = string.gsub( text, \"<[^>]*>\", \"\" )","\t\treturn text","\tend","\tcreateDocList( \"Functions\", function ( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.functions ) do","\t\t\tlocal func_data = doc.functions[ func ]","\t\t\tlocal line = view.FunctionsList:AddLine( func .. \"( \" .. table.concat( func_data.param, \", \" ) .. \" )\", formatText( func_data.summary ) )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.functions[ Line.func ] )","\tend )","\tcreateDocList( \"Tables\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, table in ipairs( doc.tables ) do","\t\t\tlocal table_data = doc.tables[ table ]","\t\t\tlocal line = view.TablesList:AddLine( table, formatText( table_data.summary ) )","\t\t\tline.table = table","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.tables[ Line.table ] )","\tend  )","\tcreateDocList( \"Fields\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, field in ipairs( doc.fields ) do","\t\t\tlocal field_data = doc.fields[ field ]","\t\t\tview.FieldsList:AddLine( field, formatText( field_data.summary ) )","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line)  end )","\tcreateDocList( \"Methods\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.methods ) do","\t\t\tlocal func_data = doc.methods[ func ]","\t\t\tlocal line = view.MethodsList:AddLine( func .. \"( \" .. table.concat( func_data.param, \", \" ) .. \" )\", formatText( func_data.summary ) )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.methods[ Line.func ] )","\tend  )","\tcreateDocList( \"Hooks\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, hook in ipairs( doc.hooks ) do","\t\t\tlocal hook_data = doc.hooks[ hook ]","\t\t\tlocal line = view.HooksList:AddLine( hook, formatText( hook_data.summary ) )","\t\t\tline.hook = hook","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.hooks[ Line.hook ] )","\tend  )","\tcreateDocList( \"Directives\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, directive in ipairs( doc.directives ) do","\t\t\tlocal directive_data = doc.directives[ directive ]","\t\t\tlocal line = view.DirectivesList:AddLine( directive, formatText( directive_data.summary ) )","\t\t\tline.directive = directive","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.directives[ Line.directive ], true )","\tend  )","",""],"private":false,"class":"function","name":"helper.updateDocView","param":["Line","Type"]},"helper.updateInfoPanel":{"summary":"\nInfoPanel ---- \n ","description":"\nInfoPanel ---- \n","comment":["\t---- InfoPanel ----","\t-------------------"],"code":["\tfunction helper.updateInfoPanel( func, directive )","\t\tlocal infopanel = helper.DocView.InfoPanel","\t\thelper.DocView.Info:GetVBar():SetScroll( 0 )","","\t\tdirective = nil or directive ","","\t\tif not directive then","\t\t\tinfopanel.funcName:SetText( formatText( func.name .. \"( \" .. table.concat( func.param, \", \" ) .. \" )\" ) )","\t\telse","\t\t\tinfopanel.funcName:SetText( formatText( \"--@\" .. func.name .. \" \" .. table.concat( func.param, \", \" ) ) )","\t\tend","\t\tinfopanel.funcName.Enabled = true","","\t\tinfopanel.description:SetText( formatText( func.description or \"\", true ) )","\t\tinfopanel.description.Enabled = true","","\t\tif func.deprecated then ","\t\t\tinfopanel.deprecated:SetText( \"Deprecated: \" .. formatText( func.deprecated ) ) ","\t\t\tinfopanel.deprecated.Enabled = true","\t\telse ","\t\t\tinfopanel.deprecated.Enabled = false","\t\tend","","\t\tif type( func.param ) == \"table\" and #func.param > 0 then","\t\t\tlocal params = \"\"","\t\t\tfor p = 1, #func.param do","\t\t\t\tparams = params .. \"» \" .. func.param[ p ] .. \": \" .. ( func.param[ func.param[ p ] ] or \"\" ) .. ( p ~= #func.param and \"\\n\" or \"\" ) ","\t\t\tend","\t\t\tinfopanel.parameters:SetText( \"Parameters: \" )","\t\t\tinfopanel.parameterList:SetText( formatText( params, true ) )","\t\t\tinfopanel.parameters.Enabled = true","\t\t\tinfopanel.parameterList.Enabled = true","\t\telseif #func.param == 0 then","\t\t\tinfopanel.parameters.Enabled = false","\t\t\tinfopanel.parameterList.Enabled = false","\t\tend","","\t\tif type( func.ret ) == \"string\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return value: \" )","\t\t\tinfopanel.returnvalueList:SetText( formatText( func.ret, true ) )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telseif type( func.ret ) == \"table\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return values: \" )","\t\t\tlocal rets = \"\"","\t\t\tlocal count = 1","\t\t\tfor _, ret in ipairs( func.ret ) do","\t\t\t\trets = rets .. count .. \". \" .. ret .. \"\\n\"","\t\t\t\tcount = count + 1","\t\t\tend","\t\t\tinfopanel.returnvalueList:SetText( formatText( rets, true ) )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telse","\t\t\tinfopanel.returnvalue.Enabled = false","\t\t\tinfopanel.returnvalueList.Enabled = false","\t\tend","","\t\tif type( func.usage ) == \"string\" then","\t\t\tinfopanel.usage:SetText( \"Usage:\" )","\t\t\tinfopanel.usage.Enabled = true","\t\t\tinfopanel.usageBlock:SetText( string.gsub( string.Replace( func.usage , string.char( 9 ), \"    \" ), \"\\n\", \"\", 1 ) )","\t\t\tinfopanel.usageBlock.Enabled = true","\t\telseif not func.usage then","\t\t\tinfopanel.usage.Enabled = false","\t\t\tinfopanel.usageBlock.Enabled = false","\t\tend","","\t\tfor _, label in pairs( infopanel.labels ) do\t\t","\t\t\tlabel:SizeToContents()","\t\t\tlabel:SetWrap( true )","\t\t\tlabel:SetAutoStretchVertical( true )\t","\t\tend\t","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView.Info = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView.Info:SetTall( 150 )","\thelper.DocView.Info:SetVisible( false )","","\thelper.DocView.InfoPanel = vgui.Create( \"StarfallPanel\", helper.DocView.Info )","\thelper.DocView.InfoPanel:SetSize( 200, 100 )","\tlocal infopanel = helper.DocView.InfoPanel","","\thelper.DocView.Div = vgui.Create( \"DVerticalDivider\", helper.Frame )","\thelper.DocView.Div:SetPos( 166, 30 )","\thelper.DocView.Div:SetTop( helper.DocView )","\thelper.DocView.Div:SetBottom( helper.DocView.Info )","\thelper.DocView.Div:SetTopMin( 100 )","\thelper.DocView.Div:SetBottomMin( 100 )","\thelper.DocView.Div:SetDividerHeight( 5 )","\thelper.DocView.Div:SetVisible( false )","\thelper.DocView.Div._PerformLayout = helper.DocView.Div.PerformLayout","\tfunction helper.DocView.Div:PerformLayout()","\t\thelper.DocView.Div:_PerformLayout()","\t\thelper.resize()","\tend","","\tinfopanel.labels = {}","","\tinfopanel.funcName = Label( \"Nothing selected\", infopanel )","\tinfopanel.funcName:SetFont( \"HelperTextBold\" )","\tinfopanel.funcName:SizeToContents()","\tinfopanel.funcName.m_colText = Color( 60, 60, 60 )","\tinfopanel.funcName.indent = 0","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.funcName","","\tinfopanel.description = Label( \"\", infopanel )","\tinfopanel.description:SetFont( \"HelperText\" )","\tinfopanel.description.m_colText = Color( 60, 60, 60 )","\tinfopanel.description.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.description","","\tinfopanel.deprecated = Label( \"\", infopanel )","\tinfopanel.deprecated:SetText( \"\" )","\tinfopanel.deprecated:SetFont( \"HelperTextBold\" )","\tinfopanel.deprecated:SizeToContents()","\tinfopanel.deprecated:SetWrap( true )","\tinfopanel.deprecated:SetAutoStretchVertical( true )","\tinfopanel.deprecated.m_colText = Color( 210, 0, 0 )","\tinfopanel.deprecated.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.deprecated","","\tinfopanel.parameters = Label( \"Parameters:\", infopanel )","\tinfopanel.parameters:SetFont( \"HelperTextBold\" )","\tinfopanel.parameters.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameters.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameters","","\tinfopanel.parameterList = Label( \"\", infopanel )","\tinfopanel.parameterList:SetFont( \"HelperText\" )","\tinfopanel.parameterList.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameterList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameterList","","\tinfopanel.returnvalue = Label( \"Return Value:\", infopanel )","\tinfopanel.returnvalue:SetFont( \"HelperTextBold\" )","\tinfopanel.returnvalue.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalue.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalue","","\tinfopanel.returnvalueList = Label( \"\", infopanel )","\tinfopanel.returnvalueList:SetFont( \"HelperText\" )","\tinfopanel.returnvalueList.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalueList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalueList","","\tinfopanel.usage = Label( \"Usage:\", infopanel )","\tinfopanel.usage:SetFont( \"HelperTextBold\" )","\tinfopanel.usage.m_colText = Color( 60, 60, 60 )","\tinfopanel.usage.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usage","","\tinfopanel.usageBlock = Label( \"\", infopanel )","\tinfopanel.usageBlock:SetFont( \"CodeBlock\" )","\tinfopanel.usageBlock.m_colText = Color( 60, 60, 60 )","\tinfopanel.usageBlock.indent = 3","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usageBlock",""],"private":false,"class":"function","name":"helper.updateInfoPanel","param":["func","directive"]}},"doc":[{"summary":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n ","description":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n","comment":["-------------------------------------------------------------------------------","-- SF Helper for Starfall","-- By Jazzelhawk","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- TO DO ---","--- search page"],"code":["","SF.Helper = {}","SF.Docs = {}","local helper = SF.Helper","local docs_set = false","local docs_downloading = false","local settings_set = false","","if CLIENT then","\tCreateClientConVar( \"sf_helper_width\", 930, true, false )","\tCreateClientConVar( \"sf_helper_height\", 615, true, false )","\tCreateClientConVar( \"sf_helper_posx\", ( ScrW() - 930 ) / 2, true, false )","\tCreateClientConVar( \"sf_helper_posy\", ( ScrH() - 615 ) / 2, true, false )","\tCreateClientConVar( \"sf_helper_divheight\", 400, true, false )","end","","local function saveSettings()","\tRunConsoleCommand( \"sf_helper_width\", helper.Frame:GetWide() )","\tRunConsoleCommand( \"sf_helper_height\", helper.Frame:GetTall() )","\tlocal x, y = helper.Frame:GetPos()","\tRunConsoleCommand( \"sf_helper_posx\", x )","\tRunConsoleCommand( \"sf_helper_posy\", y )","\tRunConsoleCommand( \"sf_helper_divheight\", helper.DocView.Div:GetTopHeight() )","end","","function helper.create()","","\thelper.Views = {}","","\thelper.Frame = vgui.Create( \"StarfallFrame\" )","\thelper.Frame:SetSize( 930, 615 )","\thelper.Frame:Center( )","\thelper.Frame:SetTitle( \"SF Helper\" )","\thelper.Frame._PerformLayout2 = helper.Frame.PerformLayout","\tfunction helper.Frame:PerformLayout ( ... )","\t\tlocal w, h = helper.Frame:GetSize()","\t\tif w < 620 then w = 620 end","\t\tif h < 410 then h = 410 end","\t\thelper.Frame:SetSize( w, h )","","\t\tself:_PerformLayout2( ... )","\t\thelper.resize( )","\tend","\tfunction helper.Frame:OnOpen ()","\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Helper\" ).active = true","\tend","\tfunction helper.Frame:OnClose ()","\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Helper\" ).active = false","\t\tsaveSettings()","\tend","","\thelper.ScrollPanel = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.ScrollPanel:SetPos( 5, 30 )","","\thelper.CatList = vgui.Create( \"DCategoryList\", helper.ScrollPanel )","","\tlocal lists = {}","\tlocal panels = {}","","\tlocal function createList( name, listfunc )","\t\tlocal Cat = helper.CatList:Add( name )","\t\tif name ~= \"SF Helper\" then Cat:SetExpanded( false ) end","\t\tlocal DPanel = vgui.Create( \"StarfallPanel\", Cat )","\t\tDPanel:SetPos( 2, 22 )","","\t\tlocal List = vgui.Create( \"DListView\", DPanel )","\t\tList:SetHideHeaders( true )","\t\tList:SetMultiSelect( false )","\t\tList:DisableScrollbar()","\t\tList:AddColumn( \"\" )","","\t\tlocal height = listfunc( List ) - 15","","\t\tDPanel:SetSize( 113, height )","\t\tList:SetSize( 113, height )","","\t\tList._OnRowSelected = List.OnRowSelected","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\tfor k, v in pairs( lists ) do","\t\t\t\tif v ~= List then","\t\t\t\t\tv:ClearSelection()","\t\t\t\tend","\t\t\tend","\t\t\tList:_OnRowSelected( LineID, Line )","\t\tend","","\t\tlists[ name ] = List","\t\ttable.insert( panels, DPanel )","\tend","","\thelper.CatList._PerformLayout = helper.CatList.PerformLayout","\tfunction helper.CatList:PerformLayout( ... )","\t\tself:_PerformLayout( ... )","\t\tfor k, v in pairs( panels ) do","\t\t\tv:SetSize( self:GetCanvas():GetWide() - 8, v:GetTall() )","\t\tend","\t\tfor k, v in pairs( lists ) do","\t\t\tv:SetSize( self:GetCanvas():GetWide() - 8, v:GetTall() )","\t\tend","\tend","","\tcreateList( \"SF Helper\", function( List ) ","\t\tlocal height = 16;","\t\tList:AddLine( \"Index\" )","\t\theight = height + 17","\t\tList:AddLine( \"About\" )","\t\theight = height + 17","\t\tList:SelectFirstItem()","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\tif LineID == 1 then","\t\t\t\thelper.openView( \"Index\" )","\t\t\telse","\t\t\t\thelper.openView( \"About\" )","\t\t\tend","\t\tend","","\t\treturn height","\tend )","","\tcreateList( \"Preprocessor directives\", function( List )","\t\tlocal height = 16","\t\tfor _, directive in ipairs(SF.Docs.directives) do","\t\t\tList:AddLine( \"--@\" .. directive )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 4 )","\t\t\thelper.DocView.DirectivesList:SelectItem( helper.DocView.DirectivesList:GetLine( LineID ) )","\t\tend","","\t\treturn height","\tend )","","\tcreateList( \"Libraries\", function( List )","\t\tlocal height = 16","\t\tfor _, modulename in ipairs(SF.Docs.libraries) do","\t\t\tList:AddLine( modulename )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 1 )","\t\tend","","\t\treturn height","\tend )","\t","\tcreateList( \"Types\", function( List )","\t\tlocal height = 16","\t\tfor _, typename in ipairs(SF.Docs.classes) do","\t\t\tList:AddLine( typename )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 2 )","\t\tend","","\t\treturn height","\tend )","\t","\tcreateList( \"Hooks\", function( List )","\t\tlocal height = 16","\t\tfor _, hookname in ipairs(SF.Docs.hooks) do","\t\t\tList:AddLine( hookname )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 3 )","\t\t\thelper.DocView.HooksList:SelectItem( helper.DocView.HooksList:GetLine( LineID ) )","\t\tend","","\t\treturn height","\tend )","\t","\tcreateList( \"Examples\", function( List )","\t\tlocal height = 16","\t\tfor name, code in pairs(SF.Docs.examples) do","\t\t\tlocal Line = List:AddLine( name )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 5 )","\t\tend","","\t\treturn height","\tend )","","\tfunction helper.clearViews()","\t\tfor _, View in pairs( helper.Views ) do","\t\t\tView:SetVisible( false )","\t\t\tif View.Info then","\t\t\t\tView.Info:SetVisible( false )","\t\t\t\tView.Div:SetVisible( false )","\t\t\tend","\t\tend","\tend","","\tfunction helper.openView( view )","\t\thelper.clearViews()","\t\tif helper.Views[ view ] then","\t\t\thelper.Views[ view ]:SetVisible( true )","\t\t\tif helper.Views[ view ].Info then","\t\t\t\thelper.Views[ view ].Info:SetVisible( true )","\t\t\t\thelper.Views[ view ].Div:SetVisible( true )","\t\t\tend","\t\tend","\tend","","\tsurface.CreateFont( \"HelperTitle\", {","\t\tfont = \"Tahoma\",","\t\tsize = 30,","\t\tweight = 1000","\t} )","","\tsurface.CreateFont( \"HelperText\", {","\t\tfont = \"Tahoma\",","\t\tsize = 22,","\t\tweight = 500","\t} )","","\tsurface.CreateFont( \"HelperTextBold\", {","\t\tfont = \"Tahoma\",","\t\tsize = 22,","\t\tweight = 1000","\t} )","","\tsurface.CreateFont( \"CodeBlock\", {","\t\tfont = \"Courier New\",","\t\tsize = 16,","\t\tweight = 500","\t} )",""],"summary":"\nTO DO --- \nsearch page ","description":"\nTO DO --- \nsearch page","param":[]},{"comment":["\t---- Index View ----","\t--------------------"],"code":["\thelper.IndexView = vgui.Create( \"StarfallPanel\", helper.Frame )","\thelper.IndexView:SetPos( 166, 30 )","\thelper.Views.Index = helper.IndexView","","\thelper.IndexLibs = vgui.Create( \"DListView\", helper.IndexView )","\thelper.IndexLibs:SetPos( 5, 5 )","\thelper.IndexLibs:SetMultiSelect( false )","\thelper.IndexLibs:AddColumn( \"Libraries\" ):SetFixedWidth( 100 )","\thelper.IndexLibs:AddColumn( \"Description\" )","\tfor _, modulename in ipairs( SF.Docs.libraries ) do","\t\thelper.IndexLibs:AddLine( modulename, string.Trim( SF.Docs.libraries[ modulename ].summary ) )","\tend","\tfunction helper.IndexLibs:OnRowSelected( LineID, Line )","\t\thelper.IndexHooks:ClearSelection()","\t\tlists[ \"Libraries\" ]:GetParent():GetParent():DoExpansion( true )","\t\tlists[ \"Libraries\" ]:SelectItem( lists[ \"Libraries\" ]:GetLine( LineID ) )","\tend","","\thelper.IndexHooks = vgui.Create( \"DListView\", helper.IndexView )","\thelper.IndexHooks:SetMultiSelect( false )","\thelper.IndexHooks:AddColumn( \"Hooks\" ):SetFixedWidth( 100 )","\thelper.IndexHooks:AddColumn( \"Description\" )","\tfor _, hookname in ipairs(SF.Docs.hooks) do","\t\thelper.IndexHooks:AddLine( hookname, string.Trim( SF.Docs.hooks[ hookname ].summary ) )","\tend","\tfunction helper.IndexHooks:OnRowSelected( LineID, Line )","\t\thelper.IndexLibs:ClearSelection()","\t\tlists[ \"Hooks\" ]:GetParent():GetParent():DoExpansion( true )","\t\tlists[ \"Hooks\" ]:SelectItem( lists[ \"Hooks\" ]:GetLine( LineID ) )","\tend",""],"summary":"\nIndex View ---- \n ","description":"\nIndex View ---- \n","param":[]},{"summary":"\nDoc View ---- \n ","description":"\nDoc View ---- \n","comment":["\t---- Doc View ----","\t------------------"],"code":["\tfunction helper.updateDocView( Line, Type )","\t\tlocal view = helper.DocView","\t\tview.DocName = Line:GetColumnText( 1 )","","\t\tview:GetVBar():SetScroll( 0 )","","\t\tif Type == 1 then","\t\t\tview.Title:SetText( \"Library - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.libraries[ view.DocName ]","\t\telseif Type == 2 then","\t\t\tview.Title:SetText( \"Type - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.classes[ view.DocName ]","\t\telseif Type == 3 then","\t\t\tview.Title:SetText( \"Hooks\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.hooks = SF.Docs.hooks","\t\t\tview.Doc.description = \"List of hooks available to SF scripts\"","\t\telseif Type == 4 then","\t\t\tview.Title:SetText( \"Preprocessor directives\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.directives = SF.Docs.directives","\t\t\tview.Doc.description = \"List of preprocessor directives\"","\t\telseif Type == 5 then","\t\t\tview.Title:SetText( view.DocName )","\t\t\tview.Doc = {example=SF.Docs.examples[view.DocName]}","\t\tend","\t\tlocal doc = view.Doc","\t\tview.Title:SizeToContents()","","\t\tif doc.description then","\t\t\tview.Description:SetText( string.Replace( doc.description, \"\\n\", \"\" ) )","\t\t\tview.Description:SizeToContents()","\t\t\tview.Description:SetWrap( true )","\t\t\tview.Description:SetAutoStretchVertical( true )","\t\t\tview.Description.Enabled = true","\t\telse","\t\t\tview.Description.Enabled = false","\t\tend","\t\t","\t\tif doc.example then","\t\t\tview.exampleCode:SetText( doc.example )","\t\t\tview.exampleCode:SetVisible(true)","\t\telse","\t\t\tview.exampleCode:SetVisible(false)","\t\tend","\t\t\t","\t\tif doc.deprecated then","\t\t\tview.Deprecated:SetVisible( true )","\t\t\tview.Deprecated.Enabled = true","\t\telse","\t\t\tview.Deprecated:SetVisible( false )","\t\t\tview.Deprecated.Enabled = false","\t\tend","\t\tfor _, labellist in pairs( helper.LabelLists ) do","\t\t\tif doc[ labellist.name ] and #doc[ labellist.name ] > 0 then","\t\t\t\tlabellist.label:SetVisible( true )","\t\t\t\tlabellist.label.Enabled = true","\t\t\t\tlabellist.label:SizeToContents()","\t\t\t\tlabellist.list:SetVisible( true )","\t\t\t\tlabellist.list:Clear()","\t\t\t\tlocal height = labellist.func( view, doc )","\t\t\t\tlabellist.list:SetTall( height )","\t\t\telse","\t\t\t\tlabellist.label:SetVisible( false )","\t\t\t\tlabellist.label.Enabled = false","\t\t\t\tlabellist.list:SetVisible( false )","\t\t\tend","\t\tend","","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView:SetPos( 166, 30 )","\thelper.DocView:SetVisible( false )","\thelper.Views.Doc = helper.DocView","","\thelper.DocView.Panel = vgui.Create( \"StarfallPanel\", helper.DocView )","","\thelper.DocView.Title = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Title:SetPos( 10, 5 )","\thelper.DocView.Title:SetFont( \"HelperTitle\" )","\thelper.DocView.Title.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Description = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Description:SetPos( 25, 40 )","\thelper.DocView.Description:SetFont( \"HelperText\" )","\thelper.DocView.Description.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Deprecated = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Deprecated:SetText( \"This library/type has been deprecated and will be removed in the future for the following reason: Pure Lua implementation. This can be done with a user library.\" )","\thelper.DocView.Deprecated:SetPos( 25, 40 )","\thelper.DocView.Deprecated:SetFont( \"HelperTextBold\" )","\thelper.DocView.Deprecated:SizeToContents()","\thelper.DocView.Deprecated:SetWrap( true )","\thelper.DocView.Deprecated:SetAutoStretchVertical( true )","\thelper.DocView.Deprecated.m_colText = Color( 210, 0, 0 )","\t","\thelper.DocView.exampleCode = vgui.Create( \"DTextEntry\", helper.DocView.Panel )","\thelper.DocView.exampleCode:SetMultiline( true )","\thelper.DocView.exampleCode:SetEditable( true )","\thelper.DocView.exampleCode:SetPos( 25, 60 )","\thelper.DocView.exampleCode:SetSize( 800, 1600 )","\thelper.DocView.exampleCode:SetFont( \"CodeBlock\" )","\thelper.DocView.exampleCode.m_colText = Color( 60, 60, 60 )","\thelper.DocView.exampleCode:SetVisible(false)","","\thelper.LabelLists = {}","\tlocal function createDocList( name, func, update )","\t\tlocal label = Label( name, helper.DocView.Panel )","\t\tlabel:SetPos( 10, 40 )","\t\tlabel:SetFont( \"HelperTitle\" )","\t\tlabel.m_colText = Color( 60, 60, 60 )","\t\thelper.DocView[ name .. \"Label\" ] = label","","\t\tlocal list = vgui.Create( \"DListView\", helper.DocView.Panel )","\t\tlist:SetPos( 25, 40 )","\t\tlist:SetMultiSelect( false )","\t\tlist:AddColumn( name ):SetFixedWidth( 150 )","\t\tlist:AddColumn( \"Description\" )","\t\thelper.DocView[ name .. \"List\" ] = list","\t\thelper.LabelLists[ #helper.LabelLists + 1 ] = { label = label, list = list, func = func, name = string.lower( name ) }","","\t\tfunction list:OnRowSelected( LineID, Line )","\t\t\tfor _, labellist in pairs( helper.LabelLists ) do ","\t\t\t\tif labellist.list ~= list then","\t\t\t\t\tlabellist.list:ClearSelection()","\t\t\t\tend","\t\t\tend","\t\t\tupdate( LineID, Line )","\t\tend","\tend","\tlocal function formatText( text, dontRemoveNewLines )","\t\ttext = text:Trim()","\t\tif not dontRemoveNewLines then text = string.Replace( text, \"\\n\", \"\" ) end","\t\ttext = string.gsub( text, \"<[^>]*>\", \"\" )","\t\treturn text","\tend","\tcreateDocList( \"Functions\", function ( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.functions ) do","\t\t\tlocal func_data = doc.functions[ func ]","\t\t\tlocal line = view.FunctionsList:AddLine( func .. \"( \" .. table.concat( func_data.param, \", \" ) .. \" )\", formatText( func_data.summary ) )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.functions[ Line.func ] )","\tend )","\tcreateDocList( \"Tables\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, table in ipairs( doc.tables ) do","\t\t\tlocal table_data = doc.tables[ table ]","\t\t\tlocal line = view.TablesList:AddLine( table, formatText( table_data.summary ) )","\t\t\tline.table = table","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.tables[ Line.table ] )","\tend  )","\tcreateDocList( \"Fields\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, field in ipairs( doc.fields ) do","\t\t\tlocal field_data = doc.fields[ field ]","\t\t\tview.FieldsList:AddLine( field, formatText( field_data.summary ) )","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line)  end )","\tcreateDocList( \"Methods\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.methods ) do","\t\t\tlocal func_data = doc.methods[ func ]","\t\t\tlocal line = view.MethodsList:AddLine( func .. \"( \" .. table.concat( func_data.param, \", \" ) .. \" )\", formatText( func_data.summary ) )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.methods[ Line.func ] )","\tend  )","\tcreateDocList( \"Hooks\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, hook in ipairs( doc.hooks ) do","\t\t\tlocal hook_data = doc.hooks[ hook ]","\t\t\tlocal line = view.HooksList:AddLine( hook, formatText( hook_data.summary ) )","\t\t\tline.hook = hook","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.hooks[ Line.hook ] )","\tend  )","\tcreateDocList( \"Directives\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, directive in ipairs( doc.directives ) do","\t\t\tlocal directive_data = doc.directives[ directive ]","\t\t\tlocal line = view.DirectivesList:AddLine( directive, formatText( directive_data.summary ) )","\t\t\tline.directive = directive","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.directives[ Line.directive ], true )","\tend  )","",""],"private":false,"class":"function","name":"helper.updateDocView","param":["Line","Type"]},{"summary":"\nInfoPanel ---- \n ","description":"\nInfoPanel ---- \n","comment":["\t---- InfoPanel ----","\t-------------------"],"code":["\tfunction helper.updateInfoPanel( func, directive )","\t\tlocal infopanel = helper.DocView.InfoPanel","\t\thelper.DocView.Info:GetVBar():SetScroll( 0 )","","\t\tdirective = nil or directive ","","\t\tif not directive then","\t\t\tinfopanel.funcName:SetText( formatText( func.name .. \"( \" .. table.concat( func.param, \", \" ) .. \" )\" ) )","\t\telse","\t\t\tinfopanel.funcName:SetText( formatText( \"--@\" .. func.name .. \" \" .. table.concat( func.param, \", \" ) ) )","\t\tend","\t\tinfopanel.funcName.Enabled = true","","\t\tinfopanel.description:SetText( formatText( func.description or \"\", true ) )","\t\tinfopanel.description.Enabled = true","","\t\tif func.deprecated then ","\t\t\tinfopanel.deprecated:SetText( \"Deprecated: \" .. formatText( func.deprecated ) ) ","\t\t\tinfopanel.deprecated.Enabled = true","\t\telse ","\t\t\tinfopanel.deprecated.Enabled = false","\t\tend","","\t\tif type( func.param ) == \"table\" and #func.param > 0 then","\t\t\tlocal params = \"\"","\t\t\tfor p = 1, #func.param do","\t\t\t\tparams = params .. \"» \" .. func.param[ p ] .. \": \" .. ( func.param[ func.param[ p ] ] or \"\" ) .. ( p ~= #func.param and \"\\n\" or \"\" ) ","\t\t\tend","\t\t\tinfopanel.parameters:SetText( \"Parameters: \" )","\t\t\tinfopanel.parameterList:SetText( formatText( params, true ) )","\t\t\tinfopanel.parameters.Enabled = true","\t\t\tinfopanel.parameterList.Enabled = true","\t\telseif #func.param == 0 then","\t\t\tinfopanel.parameters.Enabled = false","\t\t\tinfopanel.parameterList.Enabled = false","\t\tend","","\t\tif type( func.ret ) == \"string\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return value: \" )","\t\t\tinfopanel.returnvalueList:SetText( formatText( func.ret, true ) )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telseif type( func.ret ) == \"table\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return values: \" )","\t\t\tlocal rets = \"\"","\t\t\tlocal count = 1","\t\t\tfor _, ret in ipairs( func.ret ) do","\t\t\t\trets = rets .. count .. \". \" .. ret .. \"\\n\"","\t\t\t\tcount = count + 1","\t\t\tend","\t\t\tinfopanel.returnvalueList:SetText( formatText( rets, true ) )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telse","\t\t\tinfopanel.returnvalue.Enabled = false","\t\t\tinfopanel.returnvalueList.Enabled = false","\t\tend","","\t\tif type( func.usage ) == \"string\" then","\t\t\tinfopanel.usage:SetText( \"Usage:\" )","\t\t\tinfopanel.usage.Enabled = true","\t\t\tinfopanel.usageBlock:SetText( string.gsub( string.Replace( func.usage , string.char( 9 ), \"    \" ), \"\\n\", \"\", 1 ) )","\t\t\tinfopanel.usageBlock.Enabled = true","\t\telseif not func.usage then","\t\t\tinfopanel.usage.Enabled = false","\t\t\tinfopanel.usageBlock.Enabled = false","\t\tend","","\t\tfor _, label in pairs( infopanel.labels ) do\t\t","\t\t\tlabel:SizeToContents()","\t\t\tlabel:SetWrap( true )","\t\t\tlabel:SetAutoStretchVertical( true )\t","\t\tend\t","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView.Info = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView.Info:SetTall( 150 )","\thelper.DocView.Info:SetVisible( false )","","\thelper.DocView.InfoPanel = vgui.Create( \"StarfallPanel\", helper.DocView.Info )","\thelper.DocView.InfoPanel:SetSize( 200, 100 )","\tlocal infopanel = helper.DocView.InfoPanel","","\thelper.DocView.Div = vgui.Create( \"DVerticalDivider\", helper.Frame )","\thelper.DocView.Div:SetPos( 166, 30 )","\thelper.DocView.Div:SetTop( helper.DocView )","\thelper.DocView.Div:SetBottom( helper.DocView.Info )","\thelper.DocView.Div:SetTopMin( 100 )","\thelper.DocView.Div:SetBottomMin( 100 )","\thelper.DocView.Div:SetDividerHeight( 5 )","\thelper.DocView.Div:SetVisible( false )","\thelper.DocView.Div._PerformLayout = helper.DocView.Div.PerformLayout","\tfunction helper.DocView.Div:PerformLayout()","\t\thelper.DocView.Div:_PerformLayout()","\t\thelper.resize()","\tend","","\tinfopanel.labels = {}","","\tinfopanel.funcName = Label( \"Nothing selected\", infopanel )","\tinfopanel.funcName:SetFont( \"HelperTextBold\" )","\tinfopanel.funcName:SizeToContents()","\tinfopanel.funcName.m_colText = Color( 60, 60, 60 )","\tinfopanel.funcName.indent = 0","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.funcName","","\tinfopanel.description = Label( \"\", infopanel )","\tinfopanel.description:SetFont( \"HelperText\" )","\tinfopanel.description.m_colText = Color( 60, 60, 60 )","\tinfopanel.description.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.description","","\tinfopanel.deprecated = Label( \"\", infopanel )","\tinfopanel.deprecated:SetText( \"\" )","\tinfopanel.deprecated:SetFont( \"HelperTextBold\" )","\tinfopanel.deprecated:SizeToContents()","\tinfopanel.deprecated:SetWrap( true )","\tinfopanel.deprecated:SetAutoStretchVertical( true )","\tinfopanel.deprecated.m_colText = Color( 210, 0, 0 )","\tinfopanel.deprecated.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.deprecated","","\tinfopanel.parameters = Label( \"Parameters:\", infopanel )","\tinfopanel.parameters:SetFont( \"HelperTextBold\" )","\tinfopanel.parameters.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameters.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameters","","\tinfopanel.parameterList = Label( \"\", infopanel )","\tinfopanel.parameterList:SetFont( \"HelperText\" )","\tinfopanel.parameterList.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameterList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameterList","","\tinfopanel.returnvalue = Label( \"Return Value:\", infopanel )","\tinfopanel.returnvalue:SetFont( \"HelperTextBold\" )","\tinfopanel.returnvalue.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalue.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalue","","\tinfopanel.returnvalueList = Label( \"\", infopanel )","\tinfopanel.returnvalueList:SetFont( \"HelperText\" )","\tinfopanel.returnvalueList.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalueList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalueList","","\tinfopanel.usage = Label( \"Usage:\", infopanel )","\tinfopanel.usage:SetFont( \"HelperTextBold\" )","\tinfopanel.usage.m_colText = Color( 60, 60, 60 )","\tinfopanel.usage.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usage","","\tinfopanel.usageBlock = Label( \"\", infopanel )","\tinfopanel.usageBlock:SetFont( \"CodeBlock\" )","\tinfopanel.usageBlock.m_colText = Color( 60, 60, 60 )","\tinfopanel.usageBlock.indent = 3","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usageBlock",""],"private":false,"class":"function","name":"helper.updateInfoPanel","param":["func","directive"]},{"comment":["\t---- About View ----","\t--------------------"],"code":["\thelper.AboutView = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.AboutView:SetPos( 166, 30 )","\thelper.AboutView:SetVisible( false )","\thelper.Views.About = helper.AboutView","","\thelper.AboutView.Panel = vgui.Create( \"StarfallPanel\", helper.AboutView )","","\thelper.AboutView.About = Label( \"Starfall is a Lua sandbox for Garry's mod. It allows players to write Lua scripts for the server without exposing server functionality that could be used maliciously. Since it works with Lua code directly, it's much faster than similar projects like E2 or Lemongate.\\n\\nStarfall by default includes a 'processor' entity, which is a purely server-side environment with an entity representation, and can have Wiremod inputs/outputs. It also includes a 'screen' entity, which runs code both on the server and each client to allow for fast, lag-free drawing that was previously only possible with GPU.\\n\\nThis Starfall Helper was originally made by Jazzelhawk.\", helper.AboutView.Panel )","\thelper.AboutView.About:SetPos( 10, 10 )","\thelper.AboutView.About:SetFont( \"HelperText\" )","\thelper.AboutView.About:SizeToContents()","\thelper.AboutView.About:SetWrap( true )","\thelper.AboutView.About:SetAutoStretchVertical( true )","\thelper.AboutView.About.m_colText = Color( 60, 60, 60 )","","end","","function helper.show()","\tif docs_downloading then return end","\tif not docs_set then","\t\tdocs_downloading = true","\t\tSF.AddNotify( LocalPlayer(), \"Loading starfall helper now...\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\t\t","\t\thttp.Fetch( \"http://thegrb93.github.io/StarfallEx/doc.json\", ","\t\tfunction( body, len, headers, code )","\t\t\tSF.Docs = util.JSONToTable( body )","\t\t\tdocs_set = true","\t\t\tdocs_downloading = false","\t\t\thelper.show()","\t\tend, ","\t\tfunction( error ) ","\t\t\tprint(\"Starfall failed to load documentation, Error: \", error) ","\t\t\tSF.AddNotify( LocalPlayer(), \"Failed to load the helper...\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 ) ","\t\t\tdocs_downloading = false","\t\tend )","\t\t","\t\treturn","\tend","","\tif not helper.Frame then helper.create() end","\thelper.Frame:open()","end","","local lastw, lasth = 0, 0","function helper.resize()","\tlocal w, h = helper.Frame:GetSize()","","\tlocal changew, changeh = w - lastw, h - lasth","","\thelper.CatList:SetSize( 155, 375 + h - 410)","\thelper.ScrollPanel:SetSize( 155, 375 + h - 410)","","\thelper.IndexView:SetSize( w - 173, h - 37 )","\thelper.IndexLibs:SetSize( w - 183, h / 2 - 26 )","\thelper.IndexHooks:SetPos( 5, 10 + helper.IndexLibs:GetTall() )","\thelper.IndexHooks:SetSize( w - 183, h / 2 - 27 )","","\thelper.DocView:SetSize( w - 173, h - 37 - helper.DocView.Info:GetTall() - 5 )","\tlocal w2 = helper.DocView:GetCanvas():GetWide()","\thelper.DocView.Description:SetWide( w2 - 50 )","\thelper.DocView.Deprecated:SetWide( w2 - 50 )","","\t--helper.DocView.Info:SetPos( 166, 30 + helper.DocView:GetTall() + 6 )","\thelper.DocView.Info:SetWide( w - 173 )","\thelper.DocView.InfoPanel:SetWide( w - 173 )","","\thelper.DocView.Div:SetSize( w - 173, h - 37 )","\thelper.DocView.Div:SetTopHeight( helper.DocView.Div:GetTopHeight() + changeh )","","\thelper.AboutView:SetSize( w - 173, h - 37 )","\thelper.AboutView.About:SetWide( helper.AboutView:GetWide() - 20 )","\thelper.AboutView.Panel:SetSize( helper.AboutView:GetWide(), math.max( helper.AboutView.About:GetTall() + 10, helper.AboutView:GetTall() ) )","","\tlocal runningHeight = 40","\trunningHeight = runningHeight + helper.DocView.Description:GetTall() + 10","\tif helper.DocView.Deprecated.Enabled then","\t\thelper.DocView.Deprecated:SetPos( 25, runningHeight )","\t\trunningHeight = runningHeight + helper.DocView.Deprecated:GetTall() + 10","\tend","\tif helper.DocView.exampleCode:IsVisible() then","\t\thelper.DocView.exampleCode:SetPos( 25, runningHeight )","\t\trunningHeight = runningHeight + helper.DocView.exampleCode:GetTall() + 10","\tend","\tfor _, labellist in pairs( helper.LabelLists ) do ","\t\tlabellist.list:SetWide( w2 - 50 )","\t\tif labellist.label.Enabled then","\t\t\tlabellist.label:SetPos( 10, runningHeight )","\t\t\trunningHeight = runningHeight + labellist.label:GetTall() + 10","\t\t\tlabellist.list:SetPos( 25, runningHeight )","\t\t\trunningHeight = runningHeight + labellist.list:GetTall() + 10","\t\tend","\tend","","\thelper.DocView.Panel:SetSize( helper.DocView:GetWide(), math.max( runningHeight, helper.DocView:GetTall() ) )","","\tlocal infopanel = helper.DocView.InfoPanel","\tlocal runningHeight = 10","\tfor _, label in pairs( infopanel.labels ) do","\t\tlabel:SetWide( w2 - 50 )","\t\tif label.Enabled then","\t\t\tlabel:SetVisible( true )","\t\t\tlabel:SetPos( 10 + label.indent*20, runningHeight )","\t\t\trunningHeight = runningHeight + label:GetTall() + 10","\t\telse","\t\t\tlabel:SetVisible( false )","\t\tend","\tend","","\tinfopanel:SetSize( infopanel:GetWide(), math.max( runningHeight, helper.DocView.Info:GetTall() ) )","","\thelper.DocView:GetVBar():SetScroll( helper.DocView:GetVBar():GetScroll() )","\thelper.CatList:GetVBar():SetScroll( helper.CatList:GetVBar():GetScroll() )","\thelper.IndexLibs.VBar:SetScroll( helper.IndexLibs.VBar:GetScroll() )","\thelper.IndexHooks.VBar:SetScroll( helper.IndexHooks.VBar:GetScroll() )","\thelper.DocView.Info.VBar:SetScroll( helper.DocView.Info.VBar:GetScroll() )","\thelper.AboutView.VBar:SetScroll( helper.AboutView.VBar:GetScroll() )","","\tif not settings_set then","\t\thelper.Frame:SetSize( GetConVarNumber( \"sf_helper_width\" ), GetConVarNumber( \"sf_helper_height\" ) )","\t\thelper.Frame:SetPos( GetConVarNumber( \"sf_helper_posx\" ), GetConVarNumber( \"sf_helper_posy\" ) )","\t\ttimer.Simple( 0.5, function () helper.DocView.Div:SetTopHeight( GetConVarNumber( \"sf_helper_divheight\" ) ) end )","\t\tsettings_set = true","\tend","","\tlastw, lasth = w, h","end"],"summary":"\nAbout View ---- \n ","description":"\nAbout View ---- \n","param":[]}],"tables":[],"description":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n","summary":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n "},"permissions/provider.lua":{"libraries":[],"type":"file","name":"permissions/provider.lua","functions":{"1":"P:check","2":"P:isOwner","3":"P:supportsOwner","P:check":{"ret":"one of the SF.Permissions.Role values","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return one of the SF.Permissions.Role values"],"code":["function P:check ( principal, target, key )","\treturn NEUTRAL","end"],"class":"function","name":"P:check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}},"P:supportsOwner":{"ret":"boolean whether this provider supports the isOwner method","comment":["--- Checks whether this provider knows who the server owners are.","-- @return boolean whether this provider supports the isOwner method"],"code":["function P:supportsOwner ()","\treturn false","end",""],"class":"function","name":"P:supportsOwner","private":false,"summary":"\nChecks whether this provider knows who the server owners are.","description":"\nChecks whether this provider knows who the server owners are.","param":[]},"P:isOwner":{"ret":"boolean whether the player is in the owners group","comment":["--- Checks whether a player is considered the owner of the server.","-- @param principal the player to examine","-- @return boolean whether the player is in the owners group"],"code":["function P:isOwner ( principal )","\treturn false","end",""],"class":"function","name":"P:isOwner","private":false,"summary":"\nChecks whether a player is considered the owner of the server.","description":"\nChecks whether a player is considered the owner of the server.","param":{"1":"principal","principal":"the player to examine"}}},"doc":[{"comment":["--- Sf Provider Interface","-- TODO: Need to document the shit out of this.","--"],"code":["SF.Permissions.Provider = {}","","local P = SF.Permissions.Provider","P.__index = P","","-- localize the Result enum","local NEUTRAL = SF.Permissions.Result.NEUTRAL",""],"summary":"\nSf Provider Interface \nTODO: Need to document the shit out of this.","description":"\nSf Provider Interface \nTODO: Need to document the shit out of this. \n","param":[]},{"ret":"boolean whether this provider supports the isOwner method","comment":["--- Checks whether this provider knows who the server owners are.","-- @return boolean whether this provider supports the isOwner method"],"code":["function P:supportsOwner ()","\treturn false","end",""],"class":"function","name":"P:supportsOwner","private":false,"summary":"\nChecks whether this provider knows who the server owners are.","description":"\nChecks whether this provider knows who the server owners are.","param":[]},{"ret":"boolean whether the player is in the owners group","comment":["--- Checks whether a player is considered the owner of the server.","-- @param principal the player to examine","-- @return boolean whether the player is in the owners group"],"code":["function P:isOwner ( principal )","\treturn false","end",""],"class":"function","name":"P:isOwner","private":false,"summary":"\nChecks whether a player is considered the owner of the server.","description":"\nChecks whether a player is considered the owner of the server.","param":{"1":"principal","principal":"the player to examine"}},{"ret":"one of the SF.Permissions.Role values","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return one of the SF.Permissions.Role values"],"code":["function P:check ( principal, target, key )","\treturn NEUTRAL","end"],"class":"function","name":"P:check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}}],"tables":[],"description":"\nSf Provider Interface \nTODO: Need to document the shit out of this. \n","summary":"\nSf Provider Interface \nTODO: Need to document the shit out of this."},"netstream.lua":{"type":"file","name":"netstream.lua","functions":[],"doc":[],"libraries":[],"tables":[]},"libs_sv/prop.lua":{"libraries":{"1":"prop","prop":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"createSent","4":"propsLeft","5":"setPropClean","6":"spawnRate","canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and instance.data.props.burst:check()>1","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\t","\t\tSF.setPos( entity, pos )","\t\tSF.setAng( entity, ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\t","\tif SF.Props.personalquota:GetInt() < 0 then return -1 end","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"setPropClean":{"comment":["--- Sets whether the chip should remove created props when the chip is removed","-- @param on Boolean whether the props should be cleaned or not"],"code":["function props_library.setPropClean( on )","\tSF.instance.data.props.clean = on","end",""],"class":"function","name":"props_library.setPropClean","summary":"\nSets whether the chip should remove created props when the chip is removed ","private":false,"library":"prop","description":"\nSets whether the chip should remove created props when the chip is removed","param":{"1":"on","on":"Boolean whether the props should be cleaned or not"}},"create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tprint(instance.data.props.burst:check())","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tSF.setPos( propent, pos )","\tSF.setAng( propent, ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},"spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end",""],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","code":["local props_library, props_library_metamethods = SF.Libraries.Register(\"prop\")","","local vunwrap = SF.UnwrapObject","","SF.Props = {}","","SF.Props.personalquota = CreateConVar( \"sf_props_personalquota\", \"-1\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts for a single instance\" )","","SF.Props.burstmax = CreateConVar( \"sf_props_burstmax\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Props.burstrate = CreateConVar( \"sf_props_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","-- Register privileges","SF.Permissions.registerPrivilege( \"prop.create\", \"Create prop\", \"Allows the user to create props\" )","","-- Table with player keys that automatically cleans when player leaves.","local plyCount = SF.EntityTable(\"playerProps\")","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.props = {","\t\tprops = {},","\t\tburst = SF.BurstObject( SF.Props.burstrate:GetFloat(), SF.Props.burstmax:GetFloat() )","\t}","","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tif inst.data.props.clean ~= false then --Return true on nil too","\t\tfor prop, _ in pairs(inst.data.props.props) do","\t\t\tlocal propent = SF.Entities.Unwrap(prop)","\t\t\tif IsValid(propent) then","\t\t\t\tpropent:Remove()","\t\t\tend","\t\tend","\tend","\t","\tinst.data.props.props = nil","end)","","local function propOnDestroy(propent, propdata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not propdata.props then return end","\tlocal prop = SF.Entities.Wrap(propent)","\tif propdata.props[prop] then","\t\tpropdata.props[prop] = nil","\tend","end",""],"fields":[],"name":"prop","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"props_library","tables":[],"server":true}},"type":"file","name":"libs_sv/prop.lua","functions":{"1":"personal_max_reached","2":"props_library.canSpawn","3":"props_library.create","4":"props_library.createSent","5":"props_library.propsLeft","6":"props_library.setPropClean","7":"props_library.spawnRate","props_library.createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\t","\t\tSF.setPos( entity, pos )","\t\tSF.setAng( entity, ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"props_library.spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end",""],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]},"personal_max_reached":{"ret":"True/False depending on if the personal limit has been reached for SF Props","comment":["--- Checks if the users personal limit of props has been exhausted","-- @class function","-- @param i Instance to use, this will relate to the player in question","-- @return True/False depending on if the personal limit has been reached for SF Props"],"code":["local function personal_max_reached( i )","\tif SF.Props.personalquota:GetInt() < 0 then return false end","\treturn plyCount[i.player] >= SF.Props.personalquota:GetInt()","end",""],"class":"function","classForced":true,"name":"personal_max_reached","private":false,"summary":"\nChecks if the users personal limit of props has been exhausted ","description":"\nChecks if the users personal limit of props has been exhausted","param":{"1":"i","i":"Instance to use, this will relate to the player in question"}},"props_library.canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and instance.data.props.burst:check()>1","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"props_library.propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\t","\tif SF.Props.personalquota:GetInt() < 0 then return -1 end","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"props_library.setPropClean":{"comment":["--- Sets whether the chip should remove created props when the chip is removed","-- @param on Boolean whether the props should be cleaned or not"],"code":["function props_library.setPropClean( on )","\tSF.instance.data.props.clean = on","end",""],"class":"function","name":"props_library.setPropClean","summary":"\nSets whether the chip should remove created props when the chip is removed ","private":false,"library":"prop","description":"\nSets whether the chip should remove created props when the chip is removed","param":{"1":"on","on":"Boolean whether the props should be cleaned or not"}},"props_library.create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tprint(instance.data.props.burst:check())","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tSF.setPos( propent, pos )","\tSF.setAng( propent, ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]}},"doc":[{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"createSent","4":"propsLeft","5":"setPropClean","6":"spawnRate","canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and instance.data.props.burst:check()>1","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\t","\t\tSF.setPos( entity, pos )","\t\tSF.setAng( entity, ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\t","\tif SF.Props.personalquota:GetInt() < 0 then return -1 end","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"setPropClean":{"comment":["--- Sets whether the chip should remove created props when the chip is removed","-- @param on Boolean whether the props should be cleaned or not"],"code":["function props_library.setPropClean( on )","\tSF.instance.data.props.clean = on","end",""],"class":"function","name":"props_library.setPropClean","summary":"\nSets whether the chip should remove created props when the chip is removed ","private":false,"library":"prop","description":"\nSets whether the chip should remove created props when the chip is removed","param":{"1":"on","on":"Boolean whether the props should be cleaned or not"}},"create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tprint(instance.data.props.burst:check())","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tSF.setPos( propent, pos )","\tSF.setAng( propent, ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},"spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end",""],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","code":["local props_library, props_library_metamethods = SF.Libraries.Register(\"prop\")","","local vunwrap = SF.UnwrapObject","","SF.Props = {}","","SF.Props.personalquota = CreateConVar( \"sf_props_personalquota\", \"-1\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts for a single instance\" )","","SF.Props.burstmax = CreateConVar( \"sf_props_burstmax\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Props.burstrate = CreateConVar( \"sf_props_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","-- Register privileges","SF.Permissions.registerPrivilege( \"prop.create\", \"Create prop\", \"Allows the user to create props\" )","","-- Table with player keys that automatically cleans when player leaves.","local plyCount = SF.EntityTable(\"playerProps\")","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.props = {","\t\tprops = {},","\t\tburst = SF.BurstObject( SF.Props.burstrate:GetFloat(), SF.Props.burstmax:GetFloat() )","\t}","","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tif inst.data.props.clean ~= false then --Return true on nil too","\t\tfor prop, _ in pairs(inst.data.props.props) do","\t\t\tlocal propent = SF.Entities.Unwrap(prop)","\t\t\tif IsValid(propent) then","\t\t\t\tpropent:Remove()","\t\t\tend","\t\tend","\tend","\t","\tinst.data.props.props = nil","end)","","local function propOnDestroy(propent, propdata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not propdata.props then return end","\tlocal prop = SF.Entities.Wrap(propent)","\tif propdata.props[prop] then","\t\tpropdata.props[prop] = nil","\tend","end",""],"fields":[],"name":"prop","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"props_library","tables":[],"server":true},{"ret":"True/False depending on if the personal limit has been reached for SF Props","comment":["--- Checks if the users personal limit of props has been exhausted","-- @class function","-- @param i Instance to use, this will relate to the player in question","-- @return True/False depending on if the personal limit has been reached for SF Props"],"code":["local function personal_max_reached( i )","\tif SF.Props.personalquota:GetInt() < 0 then return false end","\treturn plyCount[i.player] >= SF.Props.personalquota:GetInt()","end",""],"class":"function","classForced":true,"name":"personal_max_reached","private":false,"summary":"\nChecks if the users personal limit of props has been exhausted ","description":"\nChecks if the users personal limit of props has been exhausted","param":{"1":"i","i":"Instance to use, this will relate to the player in question"}},{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tprint(instance.data.props.burst:check())","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tSF.setPos( propent, pos )","\tSF.setAng( propent, ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not instance.data.props.burst:use(1) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 ) end","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\t","\t\tSF.setPos( entity, pos )","\t\tSF.setAng( entity, ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and instance.data.props.burst:check()>1","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\t","\tif SF.Props.personalquota:GetInt() < 0 then return -1 end","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end",""],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]},{"comment":["--- Sets whether the chip should remove created props when the chip is removed","-- @param on Boolean whether the props should be cleaned or not"],"code":["function props_library.setPropClean( on )","\tSF.instance.data.props.clean = on","end",""],"class":"function","name":"props_library.setPropClean","summary":"\nSets whether the chip should remove created props when the chip is removed ","private":false,"library":"prop","description":"\nSets whether the chip should remove created props when the chip is removed","param":{"1":"on","on":"Boolean whether the props should be cleaned or not"}}],"tables":[],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\"."},"libs_cl/joystick.lua":{"libraries":{"1":"joystick","joystick":{"comment":["--- Joystick library.","-- @client"],"functions":{"1":"getAxis","2":"getButton","3":"getName","4":"getPov","5":"numAxes","6":"numButtons","7":"numJoysticks","8":"numPovs","numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},"getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}},"class":"library","summary":"\nJoystick library.","fields":[],"name":"joystick","client":true,"description":"\nJoystick library.","libtbl":"joystick_library","tables":[],"code":["local joystick_library, _ = SF.Libraries.Register(\"joystick\")","","","if file.Exists(\"lua/bin/gmcl_joystick_win32.dll\", \"GAME\") then","\trequire(\"joystick\")","end","","local next_updates = {}","","local function refresh( enum )","\tenum = math.Clamp( enum, 0, 12 )","\tlocal next_update = next_updates[ enum ] or 0","\tif CurTime()>next_update then","\t\tnext_updates[ enum ] = CurTime() + 0.0303","\t\tjoystick.refresh( enum )","\tend","end",""]}},"type":"file","name":"libs_cl/joystick.lua","functions":{"1":"joystick_library.getAxis","2":"joystick_library.getButton","3":"joystick_library.getName","4":"joystick_library.getPov","5":"joystick_library.numAxes","6":"joystick_library.numButtons","7":"joystick_library.numJoysticks","8":"joystick_library.numPovs","joystick_library.getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"joystick_library.getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"joystick_library.numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"joystick_library.getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}}},"doc":[{"comment":["--- Joystick library.","-- @client"],"functions":{"1":"getAxis","2":"getButton","3":"getName","4":"getPov","5":"numAxes","6":"numButtons","7":"numJoysticks","8":"numPovs","numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},"getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}},"class":"library","summary":"\nJoystick library.","fields":[],"name":"joystick","client":true,"description":"\nJoystick library.","libtbl":"joystick_library","tables":[],"code":["local joystick_library, _ = SF.Libraries.Register(\"joystick\")","","","if file.Exists(\"lua/bin/gmcl_joystick_win32.dll\", \"GAME\") then","\trequire(\"joystick\")","end","","local next_updates = {}","","local function refresh( enum )","\tenum = math.Clamp( enum, 0, 12 )","\tlocal next_update = next_updates[ enum ] or 0","\tif CurTime()>next_update then","\t\tnext_updates[ enum ] = CurTime() + 0.0303","\t\tjoystick.refresh( enum )","\tend","end",""]},{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}],"tables":[],"description":"\nJoystick library.","summary":"\nJoystick library."},"libs_sh/players.lua":{"libraries":[],"type":"file","name":"libs_sh/players.lua","functions":{"1":"player_metamethods:__tostring","2":"player_methods:getActiveWeapon","3":"player_methods:getAimVector","4":"player_methods:getArmor","5":"player_methods:getDeaths","6":"player_methods:getEyeTrace","7":"player_methods:getFOV","8":"player_methods:getFrags","9":"player_methods:getFriendStatus","10":"player_methods:getJumpPower","11":"player_methods:getMaxSpeed","12":"player_methods:getName","13":"player_methods:getPing","14":"player_methods:getRunSpeed","15":"player_methods:getShootPos","16":"player_methods:getSteamID","17":"player_methods:getSteamID64","18":"player_methods:getTeam","19":"player_methods:getTeamName","20":"player_methods:getUniqueID","21":"player_methods:getUserID","22":"player_methods:getViewEntity","23":"player_methods:getWeapon","24":"player_methods:getWeapons","25":"player_methods:inVehicle","26":"player_methods:isAdmin","27":"player_methods:isAlive","28":"player_methods:isBot","29":"player_methods:isConnected","30":"player_methods:isCrouching","31":"player_methods:isFlashlightOn","32":"player_methods:isFrozen","33":"player_methods:isMuted","34":"player_methods:isNPC","35":"player_methods:isNoclipped","36":"player_methods:isPlayer","37":"player_methods:isSuperAdmin","38":"player_methods:isUserGroup","39":"player_methods:keyDown","40":"player_methods:setViewEntity","player_methods:getUniqueID":{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},"player_methods:getShootPos":{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},"player_methods:getTeam":{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},"player_methods:getPing":{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},"player_methods:isAdmin":{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},"player_methods:getArmor":{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},"player_methods:getJumpPower":{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},"player_methods:isFrozen":{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]},"player_methods:isCrouching":{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},"player_methods:isMuted":{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]},"player_methods:getUserID":{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},"player_methods:getFrags":{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},"player_methods:isFlashlightOn":{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},"player_methods:getDeaths":{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},"player_methods:inVehicle":{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},"player_methods:isNPC":{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},"player_methods:getFOV":{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},"player_methods:isConnected":{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},"player_methods:getSteamID":{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},"player_methods:isPlayer":{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},"player_methods:isBot":{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},"player_methods:getEyeTrace":{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, eunwrap( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal data = eunwrap( self ):GetEyeTrace()","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn vwrap( data[k] )","\t\tend","\t})","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},"player_methods:getRunSpeed":{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},"player_methods:getFriendStatus":{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},"player_methods:keyDown":{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = eunwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},"player_methods:isSuperAdmin":{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},"player_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function player_metamethods:__tostring()","\tlocal ent = eunwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"player_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"player_methods:getWeapons":{"ret":"Table of weapons","comment":["--- Returns a table of weapons the player is carrying","-- @shared","-- @return Table of weapons"],"code":["function player_methods:getWeapons()","\tSF.CheckType( self, player_metamethods )","\treturn SF.Sanitize( eunwrap( self ):GetWeapons() )","end",""],"class":"function","summary":"\nReturns a table of weapons the player is carrying ","classlib":"Player","name":"player_methods:getWeapons","server":true,"private":false,"client":true,"description":"\nReturns a table of weapons the player is carrying","param":[]},"player_methods:getName":{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},"player_methods:getActiveWeapon":{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]},"player_methods:setViewEntity":{"comment":["\t--- Sets the view entity of the player. Only works if they are linked to a hud.","\t-- @server","\t-- @param e Entity to set the player's view entity to"],"code":["\tfunction player_methods:setViewEntity ( e )","\t\tlocal pl = eunwrap( self )","\t\tlocal ent = eunwrap( e )","\t\tif not (ent and ent:IsValid()) then SF.throw(\"Invalid Entity\", 2) end","\t\t","\t\tif IsValid(pl.sfhudenabled) and pl.sfhudenabled.link == SF.instance.data.entity then","\t\t\tpl:SetViewEntity( ent )","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the view entity of the player.","name":"player_methods:setViewEntity","classlib":"Player","private":false,"server":true,"description":"\nSets the view entity of the player. Only works if they are linked to a hud.","param":{"1":"e","e":"Entity to set the player's view entity to"}},"player_methods:getTeamName":{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},"player_methods:isNoclipped":{"ret":"true if the player is noclipped","comment":["--- Returns true if the player is noclipped","-- @shared","-- @return true if the player is noclipped"],"code":["function player_methods:isNoclipped()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMoveType() == MOVETYPE_NOCLIP","end",""],"class":"function","summary":"\nReturns true if the player is noclipped ","classlib":"Player","name":"player_methods:isNoclipped","server":true,"private":false,"client":true,"description":"\nReturns true if the player is noclipped","param":[]},"player_methods:getWeapon":{"ret":"weapon","comment":["--- Returns the specified weapon or nil if the player doesn't have it","-- @shared","-- @param wep String weapon class","-- @return weapon"],"code":["function player_methods:getWeapon( wep )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( wep, \"string\" )","\treturn ewrap( eunwrap( self ):GetWeapon( wep ) )","end","","-- Returns the entity that the player is standing on","-- @shared","-- @return Ground entity","function player_methods:getGroundEntity()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetGroundEntity() )","end","","if SERVER then"],"class":"function","summary":"\nReturns the specified weapon or nil if the player doesn't have it ","classlib":"Player","name":"player_methods:getWeapon","server":true,"private":false,"client":true,"description":"\nReturns the specified weapon or nil if the player doesn't have it","param":{"1":"wep","wep":"String weapon class"}},"player_methods:getViewEntity":{"ret":"Player's current view entity","comment":["--- Returns the player's current view entity","-- @shared","-- @return Player's current view entity"],"code":["function player_methods:getViewEntity ()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetViewEntity() )","end",""],"class":"function","summary":"\nReturns the player's current view entity ","classlib":"Player","name":"player_methods:getViewEntity","server":true,"private":false,"client":true,"description":"\nReturns the player's current view entity","param":[]},"player_methods:getAimVector":{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},"player_methods:getSteamID64":{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},"player_methods:isUserGroup":{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},"player_methods:isAlive":{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},"player_methods:getMaxSpeed":{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Player functions.","-------------------------------------------------------------------------------"],"code":["","SF.Players = {}"],"summary":"\n \nPlayer functions.","description":"\n \nPlayer functions. \n","param":[]},{"comment":["--- Player type"],"code":["local player_methods, player_metamethods = SF.Typedef(\"Player\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Players.Methods = player_methods","SF.Players.Metatable = player_metamethods","","","local dsetmeta = debug.setmetatable","","local ewrap, eunwrap, ents_metatable","","SF.Libraries.AddHook(\"postload\", function()","\tewrap = SF.Entities.Wrap","\teunwrap = SF.Entities.Unwrap","\tents_metatable = SF.Entities.Metatable","\t","\tSF.AddObjectWrapper( debug.getregistry().Player, player_metamethods, function( object )","\t\tobject = ewrap( object )","\t\tdsetmeta( object, player_metamethods )","\t\treturn object","\tend )","\tSF.AddObjectUnwrapper( player_metamethods, eunwrap )","end)",""],"typtbl":"player_methods","fields":[],"name":"Player","summary":"\nPlayer type ","description":"\nPlayer type","class":"class","methods":{"1":"getActiveWeapon","2":"getAimVector","3":"getArmor","4":"getDeaths","5":"getEyeTrace","6":"getFOV","7":"getFrags","8":"getFriendStatus","9":"getJumpPower","10":"getMaxSpeed","11":"getName","12":"getPing","13":"getRunSpeed","14":"getShootPos","15":"getSteamID","16":"getSteamID64","17":"getTeam","18":"getTeamName","19":"getUniqueID","20":"getUserID","21":"getViewEntity","22":"getWeapon","23":"getWeapons","24":"inVehicle","25":"isAdmin","26":"isAlive","27":"isBot","28":"isConnected","29":"isCrouching","30":"isFlashlightOn","31":"isFrozen","32":"isMuted","33":"isNPC","34":"isNoclipped","35":"isPlayer","36":"isSuperAdmin","37":"isUserGroup","38":"keyDown","39":"setViewEntity","isUserGroup":{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},"isBot":{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},"setViewEntity":{"comment":["\t--- Sets the view entity of the player. Only works if they are linked to a hud.","\t-- @server","\t-- @param e Entity to set the player's view entity to"],"code":["\tfunction player_methods:setViewEntity ( e )","\t\tlocal pl = eunwrap( self )","\t\tlocal ent = eunwrap( e )","\t\tif not (ent and ent:IsValid()) then SF.throw(\"Invalid Entity\", 2) end","\t\t","\t\tif IsValid(pl.sfhudenabled) and pl.sfhudenabled.link == SF.instance.data.entity then","\t\t\tpl:SetViewEntity( ent )","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the view entity of the player.","name":"player_methods:setViewEntity","classlib":"Player","private":false,"server":true,"description":"\nSets the view entity of the player. Only works if they are linked to a hud.","param":{"1":"e","e":"Entity to set the player's view entity to"}},"isNoclipped":{"ret":"true if the player is noclipped","comment":["--- Returns true if the player is noclipped","-- @shared","-- @return true if the player is noclipped"],"code":["function player_methods:isNoclipped()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMoveType() == MOVETYPE_NOCLIP","end",""],"class":"function","summary":"\nReturns true if the player is noclipped ","classlib":"Player","name":"player_methods:isNoclipped","server":true,"private":false,"client":true,"description":"\nReturns true if the player is noclipped","param":[]},"getJumpPower":{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},"inVehicle":{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},"keyDown":{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = eunwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},"getFOV":{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},"getShootPos":{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},"getTeam":{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},"getViewEntity":{"ret":"Player's current view entity","comment":["--- Returns the player's current view entity","-- @shared","-- @return Player's current view entity"],"code":["function player_methods:getViewEntity ()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetViewEntity() )","end",""],"class":"function","summary":"\nReturns the player's current view entity ","classlib":"Player","name":"player_methods:getViewEntity","server":true,"private":false,"client":true,"description":"\nReturns the player's current view entity","param":[]},"getArmor":{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},"getSteamID":{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},"isConnected":{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},"getUserID":{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},"getMaxSpeed":{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]},"getSteamID64":{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},"getRunSpeed":{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},"getAimVector":{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},"getUniqueID":{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},"getFriendStatus":{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},"getFrags":{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},"isMuted":{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]},"isPlayer":{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},"getPing":{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},"getWeapon":{"ret":"weapon","comment":["--- Returns the specified weapon or nil if the player doesn't have it","-- @shared","-- @param wep String weapon class","-- @return weapon"],"code":["function player_methods:getWeapon( wep )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( wep, \"string\" )","\treturn ewrap( eunwrap( self ):GetWeapon( wep ) )","end","","-- Returns the entity that the player is standing on","-- @shared","-- @return Ground entity","function player_methods:getGroundEntity()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetGroundEntity() )","end","","if SERVER then"],"class":"function","summary":"\nReturns the specified weapon or nil if the player doesn't have it ","classlib":"Player","name":"player_methods:getWeapon","server":true,"private":false,"client":true,"description":"\nReturns the specified weapon or nil if the player doesn't have it","param":{"1":"wep","wep":"String weapon class"}},"getWeapons":{"ret":"Table of weapons","comment":["--- Returns a table of weapons the player is carrying","-- @shared","-- @return Table of weapons"],"code":["function player_methods:getWeapons()","\tSF.CheckType( self, player_metamethods )","\treturn SF.Sanitize( eunwrap( self ):GetWeapons() )","end",""],"class":"function","summary":"\nReturns a table of weapons the player is carrying ","classlib":"Player","name":"player_methods:getWeapons","server":true,"private":false,"client":true,"description":"\nReturns a table of weapons the player is carrying","param":[]},"isAlive":{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},"isFlashlightOn":{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},"getName":{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},"isNPC":{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},"isAdmin":{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},"isSuperAdmin":{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},"getTeamName":{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},"isCrouching":{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},"getEyeTrace":{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, eunwrap( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal data = eunwrap( self ):GetEyeTrace()","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn vwrap( data[k] )","\t\tend","\t})","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},"getDeaths":{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},"isFrozen":{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]},"getActiveWeapon":{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]}}},{"comment":["--- To string","-- @shared"],"code":["function player_metamethods:__tostring()","\tlocal ent = eunwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"player_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},{"ret":"true if the player is noclipped","comment":["--- Returns true if the player is noclipped","-- @shared","-- @return true if the player is noclipped"],"code":["function player_methods:isNoclipped()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMoveType() == MOVETYPE_NOCLIP","end",""],"class":"function","summary":"\nReturns true if the player is noclipped ","classlib":"Player","name":"player_methods:isNoclipped","server":true,"private":false,"client":true,"description":"\nReturns true if the player is noclipped","param":[]},{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]},{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]},{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]},{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, eunwrap( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal data = eunwrap( self ):GetEyeTrace()","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn vwrap( data[k] )","\t\tend","\t})","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},{"ret":"Player's current view entity","comment":["--- Returns the player's current view entity","-- @shared","-- @return Player's current view entity"],"code":["function player_methods:getViewEntity ()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetViewEntity() )","end",""],"class":"function","summary":"\nReturns the player's current view entity ","classlib":"Player","name":"player_methods:getViewEntity","server":true,"private":false,"client":true,"description":"\nReturns the player's current view entity","param":[]},{"ret":"Table of weapons","comment":["--- Returns a table of weapons the player is carrying","-- @shared","-- @return Table of weapons"],"code":["function player_methods:getWeapons()","\tSF.CheckType( self, player_metamethods )","\treturn SF.Sanitize( eunwrap( self ):GetWeapons() )","end",""],"class":"function","summary":"\nReturns a table of weapons the player is carrying ","classlib":"Player","name":"player_methods:getWeapons","server":true,"private":false,"client":true,"description":"\nReturns a table of weapons the player is carrying","param":[]},{"ret":"weapon","comment":["--- Returns the specified weapon or nil if the player doesn't have it","-- @shared","-- @param wep String weapon class","-- @return weapon"],"code":["function player_methods:getWeapon( wep )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( wep, \"string\" )","\treturn ewrap( eunwrap( self ):GetWeapon( wep ) )","end","","-- Returns the entity that the player is standing on","-- @shared","-- @return Ground entity","function player_methods:getGroundEntity()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetGroundEntity() )","end","","if SERVER then"],"class":"function","summary":"\nReturns the specified weapon or nil if the player doesn't have it ","classlib":"Player","name":"player_methods:getWeapon","server":true,"private":false,"client":true,"description":"\nReturns the specified weapon or nil if the player doesn't have it","param":{"1":"wep","wep":"String weapon class"}},{"comment":["\t--- Sets the view entity of the player. Only works if they are linked to a hud.","\t-- @server","\t-- @param e Entity to set the player's view entity to"],"code":["\tfunction player_methods:setViewEntity ( e )","\t\tlocal pl = eunwrap( self )","\t\tlocal ent = eunwrap( e )","\t\tif not (ent and ent:IsValid()) then SF.throw(\"Invalid Entity\", 2) end","\t\t","\t\tif IsValid(pl.sfhudenabled) and pl.sfhudenabled.link == SF.instance.data.entity then","\t\t\tpl:SetViewEntity( ent )","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the view entity of the player.","name":"player_methods:setViewEntity","classlib":"Player","private":false,"server":true,"description":"\nSets the view entity of the player. Only works if they are linked to a hud.","param":{"1":"e","e":"Entity to set the player's view entity to"}},{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = eunwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]}],"tables":[],"description":"\n \nPlayer functions. \n","summary":"\n \nPlayer functions."},"libs_sv/npc.lua":{"libraries":[],"type":"file","name":"libs_sv/npc.lua","functions":{"1":"npc_methods:addEntityRelationship","2":"npc_methods:addRelationship","3":"npc_methods:attackMelee","4":"npc_methods:attackRange","5":"npc_methods:getEnemy","6":"npc_methods:getRelationship","7":"npc_methods:goRun","8":"npc_methods:goWalk","9":"npc_methods:setEnemy","10":"npc_methods:stop","npc_methods:attackMelee":{"comment":["--- Makes the npc do a melee attack"],"code":["function npc_methods:attackMelee()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_MELEE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackMelee","summary":"\nMakes the npc do a melee attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a melee attack","param":[]},"npc_methods:stop":{"comment":["--- Stops the npc"],"code":["function npc_methods:stop()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_NONE )","end",""],"class":"function","name":"npc_methods:stop","summary":"\nStops the npc ","private":false,"classlib":"Npc","description":"\nStops the npc","param":[]},"npc_methods:attackRange":{"comment":["--- Makes the npc do a ranged attack"],"code":["function npc_methods:attackRange()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_RANGE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackRange","summary":"\nMakes the npc do a ranged attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a ranged attack","param":[]},"npc_methods:getEnemy":{"ret":"Entity the npc is fighting","comment":["--- Gets what the npc is fighting","-- @return Entity the npc is fighting"],"code":["function npc_methods:getEnemy()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\treturn vwrap(npc:GetEnemy())","end",""],"class":"function","name":"npc_methods:getEnemy","summary":"\nGets what the npc is fighting ","private":false,"classlib":"Npc","description":"\nGets what the npc is fighting","param":[]},"npc_methods:addRelationship":{"comment":["--- Adds a relationship to the npc","-- @param str The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"],"code":["function npc_methods:addRelationship(str)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddRelationship(str)","end","","local dispositions = {","\terror = D_ER,","\thate = D_HT,","\tfear = D_FR,","\tlike = D_LI,","\tneutral = D_NU,","\t[D_ER] = \"error\",","\t[D_HT] = \"hate\",","\t[D_FR] = \"fear\",","\t[D_LI] = \"like\",","\t[D_NU] = \"neutral\",","}"],"class":"function","name":"npc_methods:addRelationship","summary":"\nAdds a relationship to the npc ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc","param":{"1":"str","str":"The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"}},"npc_methods:goRun":{"comment":["--- Makes the npc run to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goRun(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO_RUN )","end",""],"class":"function","name":"npc_methods:goRun","summary":"\nMakes the npc run to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc run to a destination","param":{"1":"vec","vec":"The position of the destination"}},"npc_methods:setEnemy":{"comment":["--- Tell the npc to fight this","-- @param ent Target entity"],"code":["function npc_methods:setEnemy(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetTarget(target)","end",""],"class":"function","name":"npc_methods:setEnemy","summary":"\nTell the npc to fight this ","private":false,"classlib":"Npc","description":"\nTell the npc to fight this","param":{"1":"ent","ent":"Target entity"}},"npc_methods:getRelationship":{"ret":"string relationship of the npc with the target","comment":["--- Gets the npc's relationship to the target","-- @param ent Target entity","-- @return string relationship of the npc with the target"],"code":["function npc_methods:getRelationship(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\treturn dispositions[npc:Disposition()]","end",""],"class":"function","name":"npc_methods:getRelationship","summary":"\nGets the npc's relationship to the target ","private":false,"classlib":"Npc","description":"\nGets the npc's relationship to the target","param":{"1":"ent","ent":"Target entity"}},"npc_methods:addEntityRelationship":{"comment":["--- Adds a relationship to the npc with an entity","-- @param ent The target entity","-- @param disp String of the relationship. (hate fear like neutral)","-- @param priority number how strong the relationship is. Higher number is stronger"],"code":["function npc_methods:addEntityRelationship(ent, disp, priority)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tlocal relation = dispositions[disp]","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not relation then SF.throw( \"Invalid relationship specified\" ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddEntityRelationship(target, relation, priority)","end",""],"class":"function","name":"npc_methods:addEntityRelationship","summary":"\nAdds a relationship to the npc with an entity ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc with an entity","param":{"1":"ent","2":"disp","3":"priority","priority":"number how strong the relationship is. Higher number is stronger","disp":"String of the relationship. (hate fear like neutral)","ent":"The target entity"}},"npc_methods:goWalk":{"comment":["--- Makes the npc walk to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goWalk(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO )","end",""],"class":"function","name":"npc_methods:goWalk","summary":"\nMakes the npc walk to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc walk to a destination","param":{"1":"vec","vec":"The position of the destination"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Npc functions.","-------------------------------------------------------------------------------"],"code":["","SF.Npcs = {}"],"summary":"\n \nNpc functions.","description":"\n \nNpc functions. \n","param":[]},{"comment":["--- Npc type"],"code":["local npc_methods, npc_metatable = SF.Typedef(\"Npc\", SF.Entities.Metatable)","","SF.Npcs.Methods = npc_methods","SF.Npcs.Metatable = npc_metatable","","local dsetmeta = debug.setmetatable","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","local wrap, unwrap, ents_metatable","","SF.Libraries.AddHook(\"postload\", function()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","\tents_metatable = SF.Entities.Metatable","\t","\tSF.AddObjectWrapper( debug.getregistry().NPC, npc_metatable, function( object )","\t\tobject = wrap( object )","\t\tdsetmeta( object, npc_metatable )","\t\treturn object","\tend )","\tSF.AddObjectUnwrapper( npc_metatable, unwrap )","end)","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"npcs.modify\", \"Modify\", \"Allows the user to modify npcs\" )","end","","-- ------------------------------------------------------------------------- --","function npc_metatable:__tostring()","\tlocal ent = unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end",""],"typtbl":"npc_methods","fields":[],"name":"Npc","summary":"\nNpc type ","description":"\nNpc type","class":"class","methods":{"1":"addEntityRelationship","2":"addRelationship","3":"attackMelee","4":"attackRange","5":"getEnemy","6":"getRelationship","7":"goRun","8":"goWalk","9":"setEnemy","10":"stop","goWalk":{"comment":["--- Makes the npc walk to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goWalk(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO )","end",""],"class":"function","name":"npc_methods:goWalk","summary":"\nMakes the npc walk to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc walk to a destination","param":{"1":"vec","vec":"The position of the destination"}},"addEntityRelationship":{"comment":["--- Adds a relationship to the npc with an entity","-- @param ent The target entity","-- @param disp String of the relationship. (hate fear like neutral)","-- @param priority number how strong the relationship is. Higher number is stronger"],"code":["function npc_methods:addEntityRelationship(ent, disp, priority)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tlocal relation = dispositions[disp]","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not relation then SF.throw( \"Invalid relationship specified\" ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddEntityRelationship(target, relation, priority)","end",""],"class":"function","name":"npc_methods:addEntityRelationship","summary":"\nAdds a relationship to the npc with an entity ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc with an entity","param":{"1":"ent","2":"disp","3":"priority","priority":"number how strong the relationship is. Higher number is stronger","disp":"String of the relationship. (hate fear like neutral)","ent":"The target entity"}},"attackRange":{"comment":["--- Makes the npc do a ranged attack"],"code":["function npc_methods:attackRange()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_RANGE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackRange","summary":"\nMakes the npc do a ranged attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a ranged attack","param":[]},"getRelationship":{"ret":"string relationship of the npc with the target","comment":["--- Gets the npc's relationship to the target","-- @param ent Target entity","-- @return string relationship of the npc with the target"],"code":["function npc_methods:getRelationship(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\treturn dispositions[npc:Disposition()]","end",""],"class":"function","name":"npc_methods:getRelationship","summary":"\nGets the npc's relationship to the target ","private":false,"classlib":"Npc","description":"\nGets the npc's relationship to the target","param":{"1":"ent","ent":"Target entity"}},"stop":{"comment":["--- Stops the npc"],"code":["function npc_methods:stop()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_NONE )","end",""],"class":"function","name":"npc_methods:stop","summary":"\nStops the npc ","private":false,"classlib":"Npc","description":"\nStops the npc","param":[]},"getEnemy":{"ret":"Entity the npc is fighting","comment":["--- Gets what the npc is fighting","-- @return Entity the npc is fighting"],"code":["function npc_methods:getEnemy()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\treturn vwrap(npc:GetEnemy())","end",""],"class":"function","name":"npc_methods:getEnemy","summary":"\nGets what the npc is fighting ","private":false,"classlib":"Npc","description":"\nGets what the npc is fighting","param":[]},"goRun":{"comment":["--- Makes the npc run to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goRun(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO_RUN )","end",""],"class":"function","name":"npc_methods:goRun","summary":"\nMakes the npc run to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc run to a destination","param":{"1":"vec","vec":"The position of the destination"}},"attackMelee":{"comment":["--- Makes the npc do a melee attack"],"code":["function npc_methods:attackMelee()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_MELEE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackMelee","summary":"\nMakes the npc do a melee attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a melee attack","param":[]},"addRelationship":{"comment":["--- Adds a relationship to the npc","-- @param str The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"],"code":["function npc_methods:addRelationship(str)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddRelationship(str)","end","","local dispositions = {","\terror = D_ER,","\thate = D_HT,","\tfear = D_FR,","\tlike = D_LI,","\tneutral = D_NU,","\t[D_ER] = \"error\",","\t[D_HT] = \"hate\",","\t[D_FR] = \"fear\",","\t[D_LI] = \"like\",","\t[D_NU] = \"neutral\",","}"],"class":"function","name":"npc_methods:addRelationship","summary":"\nAdds a relationship to the npc ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc","param":{"1":"str","str":"The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"}},"setEnemy":{"comment":["--- Tell the npc to fight this","-- @param ent Target entity"],"code":["function npc_methods:setEnemy(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetTarget(target)","end",""],"class":"function","name":"npc_methods:setEnemy","summary":"\nTell the npc to fight this ","private":false,"classlib":"Npc","description":"\nTell the npc to fight this","param":{"1":"ent","ent":"Target entity"}}}},{"comment":["--- Adds a relationship to the npc","-- @param str The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"],"code":["function npc_methods:addRelationship(str)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddRelationship(str)","end","","local dispositions = {","\terror = D_ER,","\thate = D_HT,","\tfear = D_FR,","\tlike = D_LI,","\tneutral = D_NU,","\t[D_ER] = \"error\",","\t[D_HT] = \"hate\",","\t[D_FR] = \"fear\",","\t[D_LI] = \"like\",","\t[D_NU] = \"neutral\",","}"],"class":"function","name":"npc_methods:addRelationship","summary":"\nAdds a relationship to the npc ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc","param":{"1":"str","str":"The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"}},{"comment":["--- Adds a relationship to the npc with an entity","-- @param ent The target entity","-- @param disp String of the relationship. (hate fear like neutral)","-- @param priority number how strong the relationship is. Higher number is stronger"],"code":["function npc_methods:addEntityRelationship(ent, disp, priority)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tlocal relation = dispositions[disp]","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not relation then SF.throw( \"Invalid relationship specified\" ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddEntityRelationship(target, relation, priority)","end",""],"class":"function","name":"npc_methods:addEntityRelationship","summary":"\nAdds a relationship to the npc with an entity ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc with an entity","param":{"1":"ent","2":"disp","3":"priority","priority":"number how strong the relationship is. Higher number is stronger","disp":"String of the relationship. (hate fear like neutral)","ent":"The target entity"}},{"ret":"string relationship of the npc with the target","comment":["--- Gets the npc's relationship to the target","-- @param ent Target entity","-- @return string relationship of the npc with the target"],"code":["function npc_methods:getRelationship(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\treturn dispositions[npc:Disposition()]","end",""],"class":"function","name":"npc_methods:getRelationship","summary":"\nGets the npc's relationship to the target ","private":false,"classlib":"Npc","description":"\nGets the npc's relationship to the target","param":{"1":"ent","ent":"Target entity"}},{"comment":["--- Tell the npc to fight this","-- @param ent Target entity"],"code":["function npc_methods:setEnemy(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetTarget(target)","end",""],"class":"function","name":"npc_methods:setEnemy","summary":"\nTell the npc to fight this ","private":false,"classlib":"Npc","description":"\nTell the npc to fight this","param":{"1":"ent","ent":"Target entity"}},{"ret":"Entity the npc is fighting","comment":["--- Gets what the npc is fighting","-- @return Entity the npc is fighting"],"code":["function npc_methods:getEnemy()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\treturn vwrap(npc:GetEnemy())","end",""],"class":"function","name":"npc_methods:getEnemy","summary":"\nGets what the npc is fighting ","private":false,"classlib":"Npc","description":"\nGets what the npc is fighting","param":[]},{"comment":["--- Stops the npc"],"code":["function npc_methods:stop()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_NONE )","end",""],"class":"function","name":"npc_methods:stop","summary":"\nStops the npc ","private":false,"classlib":"Npc","description":"\nStops the npc","param":[]},{"comment":["--- Makes the npc do a melee attack"],"code":["function npc_methods:attackMelee()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_MELEE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackMelee","summary":"\nMakes the npc do a melee attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a melee attack","param":[]},{"comment":["--- Makes the npc do a ranged attack"],"code":["function npc_methods:attackRange()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_RANGE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackRange","summary":"\nMakes the npc do a ranged attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a ranged attack","param":[]},{"comment":["--- Makes the npc walk to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goWalk(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO )","end",""],"class":"function","name":"npc_methods:goWalk","summary":"\nMakes the npc walk to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc walk to a destination","param":{"1":"vec","vec":"The position of the destination"}},{"comment":["--- Makes the npc run to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goRun(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO_RUN )","end",""],"class":"function","name":"npc_methods:goRun","summary":"\nMakes the npc run to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc run to a destination","param":{"1":"vec","vec":"The position of the destination"}}],"tables":[],"description":"\n \nNpc functions. \n","summary":"\n \nNpc functions."},"libs_sh/color.lua":{"libraries":[],"type":"file","name":"libs_sh/color.lua","functions":{"1":"SF.DefaultEnvironment.Color","2":"color_metatable.__add","3":"color_metatable.__concat","4":"color_metatable.__div","5":"color_metatable.__eq","6":"color_metatable.__index","7":"color_metatable.__mul","8":"color_metatable.__newindex","9":"color_metatable.__sub","10":"color_metatable.__tostring","11":"color_methods:hsvToRGB","12":"color_methods:rgbToHSV","color_metatable.__add":{"ret":"Added color.","comment":["--- addition metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Added color."],"code":["function color_metatable.__add ( a, b )","\tSF.CheckType( a, color_metatable )","\tSF.CheckType( b, color_metatable )","","\treturn wrap( { clamp( a[1]+b[1] ), clamp( a[2]+b[2] ), clamp( a[3]+b[3] ), clamp( a[4]+b[4] ) } )","end",""],"class":"function","name":"color_metatable.__add","private":false,"summary":"\naddition metamethod ","description":"\naddition metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},"SF.DefaultEnvironment.Color":{"ret":"New color","comment":["--- Creates a table struct that resembles a Color/","-- @name SF.DefaultEnvironment.Color","-- @class function","-- @param r - Red","-- @param g - Green","-- @param b - Blue","-- @param a - Alpha","-- @return New color"],"code":["SF.DefaultEnvironment.Color = function ( r, g, b, a )","\treturn wrap( { r or 255, g or 255, b or 255, a or 255 } )","end","","-- Lookup table.","-- Index 1->4 have associative rgba for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","-- Think of rgb as a template for members of Color that are expected.","local rgb = { r = 1, g = 2, b = 3, a = 4, h = 1, s = 2, v = 3, l = 3 }",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.Color","private":false,"summary":"\nCreates a table struct that resembles a Color/ ","description":"\nCreates a table struct that resembles a Color/","param":{"1":"r","2":"g","3":"b","4":"a","a":"- Alpha","b":"- Blue","g":"- Green","r":"- Red"}},"color_metatable.__sub":{"ret":"Subtracted color.","comment":["--- subtraction metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Subtracted color."],"code":["function color_metatable.__sub ( a, b )","\tSF.CheckType( a, color_metatable )","\tSF.CheckType( b, color_metatable )","","\treturn wrap( { clamp( a[1]-b[1] ), clamp( a[2]-b[2] ), clamp( a[3]-b[3] ), clamp( a[4]-b[4] ) } )","end",""],"class":"function","name":"color_metatable.__sub","private":false,"summary":"\nsubtraction metamethod ","description":"\nsubtraction metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},"color_metatable.__newindex":{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function color_metatable.__newindex ( t, k, v )","\tif rgb[ k ] then","\t\trawset( t, rgb[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = color_metatable.__methods",""],"private":false,"class":"function","name":"color_metatable.__newindex","param":["t","k","v"]},"color_methods:hsvToRGB":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\tlocal rgb = HSVToColor( self[1], self[2], self[3] )","\treturn wrap( { rgb.r, rgb.g, rgb.b, (rgb.a or 255) } )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]},"color_metatable.__tostring":{"summary":"\n__tostring metamethod ","description":"\n__tostring metamethod","comment":["--- __tostring metamethod"],"code":["function color_metatable.__tostring ( c )","\treturn c[1] .. \" \" .. c[2] .. \" \" .. c[3] .. \" \" .. c[4]","end",""],"private":false,"class":"function","name":"color_metatable.__tostring","param":["c"]},"color_methods:rgbToHSV":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\tlocal h, s, v = ColorToHSV( self )","\treturn wrap( { h, s, v, 255 } )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},"color_metatable.__div":{"ret":"Scaled color.","comment":["--- division metamethod","-- @param rhs Right side of equation","-- @return Scaled color."],"code":["function color_metatable.__div ( a, b )","\tSF.CheckType( a, color_metatable )","\tSF.CheckType( b, \"number\" )","","\treturn wrap( { clamp( a[1]/b ), clamp( a[2]/b ), clamp( a[3]/b ), clamp( a[4]/b ) } )","end",""],"class":"function","name":"color_metatable.__div","private":false,"summary":"\ndivision metamethod ","description":"\ndivision metamethod","param":{"1":"a","2":"b","3":"rhs","rhs":"Right side of equation"}},"color_metatable.__mul":{"ret":"Scaled color.","comment":["--- multiplication metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Scaled color."],"code":["function color_metatable.__mul ( a, b )","\tif dgetmeta( a ) == color_metatable then","\t\tSF.CheckType( b, \"number\" )","","\t\treturn wrap( { clamp( a[1]*b ), clamp( a[2]*b ), clamp( a[3]*b ), clamp( a[4]*b ) } )","\telse","\t\tSF.CheckType( a, \"number\" )","","\t\treturn wrap( { clamp( b[1]*a ), clamp( b[2]*a ), clamp( b[3]*a ), clamp( b[4]*a ) } )","\tend","end",""],"class":"function","name":"color_metatable.__mul","private":false,"summary":"\nmultiplication metamethod ","description":"\nmultiplication metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},"color_metatable.__concat":{"summary":"\n__concat metamethod ","description":"\n__concat metamethod","comment":["--- __concat metamethod"],"code":["function color_metatable.__concat ( ... )","\tlocal t = { ... }","\treturn tostring( t[ 1 ] ) .. tostring( t[ 2 ] )","end",""],"private":false,"class":"function","name":"color_metatable.__concat","param":["..."]},"color_metatable.__eq":{"summary":"\n__eq metamethod ","description":"\n__eq metamethod","comment":["--- __eq metamethod"],"code":["function color_metatable.__eq ( a, b )","\treturn a[1]==b[1] and a[2]==b[2] and a[3]==b[3] and a[4]==b[4]","end","","local math_Clamp = math.Clamp","local clamp = function(v) return math_Clamp( v, 0, 255 ) end",""],"private":false,"class":"function","name":"color_metatable.__eq","param":["a","b"]},"color_metatable.__index":{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function color_metatable.__index ( t, k )","\tif rgb[ k ] then","\t\treturn rawget( t, rgb[ k ] )","\telse","\t\treturn _p[k]","\tend","end",""],"private":false,"class":"function","name":"color_metatable.__index","param":["t","k"]}},"doc":[{"comment":["--- Color type","--@shared"],"code":["local color_methods, color_metatable = SF.Typedef( \"Color\", {} )","","local function wrap( tbl )","\treturn setmetatable( tbl, color_metatable )","end","","local function unwrap( obj )","\treturn Color( (tonumber(obj[1]) or 255), (tonumber(obj[2]) or 255), (tonumber(obj[3]) or 255), (tonumber(obj[4]) or 255) )","end","","local function cwrap( clr )","\treturn wrap( { clr.r, clr.g, clr.b, clr.a } )","end","","SF.AddObjectWrapper( debug.getregistry().Color, color_metatable, cwrap )","SF.AddObjectUnwrapper( color_metatable, unwrap )","","SF.Color.Methods = color_methods","SF.Color.Metatable = color_metatable","SF.Color.Wrap = cwrap","SF.Color.Unwrap = unwrap","","local dgetmeta = debug.getmetatable"],"typtbl":"color_methods","summary":"\nColor type ","fields":[],"name":"Color","server":true,"description":"\nColor type","client":true,"class":"class","methods":{"1":"hsvToRGB","2":"rgbToHSV","rgbToHSV":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\tlocal h, s, v = ColorToHSV( self )","\treturn wrap( { h, s, v, 255 } )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},"hsvToRGB":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\tlocal rgb = HSVToColor( self[1], self[2], self[3] )","\treturn wrap( { rgb.r, rgb.g, rgb.b, (rgb.a or 255) } )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]}}},{"ret":"New color","comment":["--- Creates a table struct that resembles a Color/","-- @name SF.DefaultEnvironment.Color","-- @class function","-- @param r - Red","-- @param g - Green","-- @param b - Blue","-- @param a - Alpha","-- @return New color"],"code":["SF.DefaultEnvironment.Color = function ( r, g, b, a )","\treturn wrap( { r or 255, g or 255, b or 255, a or 255 } )","end","","-- Lookup table.","-- Index 1->4 have associative rgba for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","-- Think of rgb as a template for members of Color that are expected.","local rgb = { r = 1, g = 2, b = 3, a = 4, h = 1, s = 2, v = 3, l = 3 }",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.Color","private":false,"summary":"\nCreates a table struct that resembles a Color/ ","description":"\nCreates a table struct that resembles a Color/","param":{"1":"r","2":"g","3":"b","4":"a","a":"- Alpha","b":"- Blue","g":"- Green","r":"- Red"}},{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function color_metatable.__newindex ( t, k, v )","\tif rgb[ k ] then","\t\trawset( t, rgb[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = color_metatable.__methods",""],"private":false,"class":"function","name":"color_metatable.__newindex","param":["t","k","v"]},{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function color_metatable.__index ( t, k )","\tif rgb[ k ] then","\t\treturn rawget( t, rgb[ k ] )","\telse","\t\treturn _p[k]","\tend","end",""],"private":false,"class":"function","name":"color_metatable.__index","param":["t","k"]},{"summary":"\n__tostring metamethod ","description":"\n__tostring metamethod","comment":["--- __tostring metamethod"],"code":["function color_metatable.__tostring ( c )","\treturn c[1] .. \" \" .. c[2] .. \" \" .. c[3] .. \" \" .. c[4]","end",""],"private":false,"class":"function","name":"color_metatable.__tostring","param":["c"]},{"summary":"\n__concat metamethod ","description":"\n__concat metamethod","comment":["--- __concat metamethod"],"code":["function color_metatable.__concat ( ... )","\tlocal t = { ... }","\treturn tostring( t[ 1 ] ) .. tostring( t[ 2 ] )","end",""],"private":false,"class":"function","name":"color_metatable.__concat","param":["..."]},{"summary":"\n__eq metamethod ","description":"\n__eq metamethod","comment":["--- __eq metamethod"],"code":["function color_metatable.__eq ( a, b )","\treturn a[1]==b[1] and a[2]==b[2] and a[3]==b[3] and a[4]==b[4]","end","","local math_Clamp = math.Clamp","local clamp = function(v) return math_Clamp( v, 0, 255 ) end",""],"private":false,"class":"function","name":"color_metatable.__eq","param":["a","b"]},{"ret":"Added color.","comment":["--- addition metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Added color."],"code":["function color_metatable.__add ( a, b )","\tSF.CheckType( a, color_metatable )","\tSF.CheckType( b, color_metatable )","","\treturn wrap( { clamp( a[1]+b[1] ), clamp( a[2]+b[2] ), clamp( a[3]+b[3] ), clamp( a[4]+b[4] ) } )","end",""],"class":"function","name":"color_metatable.__add","private":false,"summary":"\naddition metamethod ","description":"\naddition metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},{"ret":"Subtracted color.","comment":["--- subtraction metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Subtracted color."],"code":["function color_metatable.__sub ( a, b )","\tSF.CheckType( a, color_metatable )","\tSF.CheckType( b, color_metatable )","","\treturn wrap( { clamp( a[1]-b[1] ), clamp( a[2]-b[2] ), clamp( a[3]-b[3] ), clamp( a[4]-b[4] ) } )","end",""],"class":"function","name":"color_metatable.__sub","private":false,"summary":"\nsubtraction metamethod ","description":"\nsubtraction metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},{"ret":"Scaled color.","comment":["--- multiplication metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Scaled color."],"code":["function color_metatable.__mul ( a, b )","\tif dgetmeta( a ) == color_metatable then","\t\tSF.CheckType( b, \"number\" )","","\t\treturn wrap( { clamp( a[1]*b ), clamp( a[2]*b ), clamp( a[3]*b ), clamp( a[4]*b ) } )","\telse","\t\tSF.CheckType( a, \"number\" )","","\t\treturn wrap( { clamp( b[1]*a ), clamp( b[2]*a ), clamp( b[3]*a ), clamp( b[4]*a ) } )","\tend","end",""],"class":"function","name":"color_metatable.__mul","private":false,"summary":"\nmultiplication metamethod ","description":"\nmultiplication metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},{"ret":"Scaled color.","comment":["--- division metamethod","-- @param rhs Right side of equation","-- @return Scaled color."],"code":["function color_metatable.__div ( a, b )","\tSF.CheckType( a, color_metatable )","\tSF.CheckType( b, \"number\" )","","\treturn wrap( { clamp( a[1]/b ), clamp( a[2]/b ), clamp( a[3]/b ), clamp( a[4]/b ) } )","end",""],"class":"function","name":"color_metatable.__div","private":false,"summary":"\ndivision metamethod ","description":"\ndivision metamethod","param":{"1":"a","2":"b","3":"rhs","rhs":"Right side of equation"}},{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\tlocal h, s, v = ColorToHSV( self )","\treturn wrap( { h, s, v, 255 } )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\tlocal rgb = HSVToColor( self[1], self[2], self[3] )","\treturn wrap( { rgb.r, rgb.g, rgb.b, (rgb.a or 255) } )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]}],"tables":[],"description":"\nColor type","summary":"\nColor type "},"libs_sh/weapons.lua":{"libraries":[],"type":"file","name":"libs_sh/weapons.lua","functions":{"1":"weapon_metamethods:__tostring","2":"weapon_methods:clip1","3":"weapon_methods:clip2","4":"weapon_methods:getActivity","5":"weapon_methods:getHoldType","6":"weapon_methods:getNextPrimaryFire","7":"weapon_methods:getNextSecondaryFire","8":"weapon_methods:getPrimaryAmmoType","9":"weapon_methods:getPrintName","10":"weapon_methods:getSecondaryAmmoType","11":"weapon_methods:isCarriedByLocalPlayer","12":"weapon_methods:isWeaponVisible","13":"weapon_methods:lastShootTime","weapon_methods:getActivity":{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},"weapon_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function weapon_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"weapon_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"weapon_methods:getPrimaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},"weapon_methods:isCarriedByLocalPlayer":{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]},"weapon_methods:getNextPrimaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},"weapon_methods:isWeaponVisible":{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]},"weapon_methods:getHoldType":{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},"weapon_methods:getPrintName":{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},"weapon_methods:lastShootTime":{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},"weapon_methods:clip2":{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},"weapon_methods:getSecondaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},"weapon_methods:getNextSecondaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},"weapon_methods:clip1":{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Weapon functions.","-------------------------------------------------------------------------------"],"code":["","SF.Weapons = {}"],"summary":"\n \nWeapon functions.","description":"\n \nWeapon functions. \n","param":[]},{"comment":["--- Weapon type"],"code":["local weapon_methods, weapon_metamethods = SF.Typedef(\"Weapon\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Weapons.Methods = weapon_methods","SF.Weapons.Metatable = weapon_metamethods",""],"typtbl":"weapon_methods","fields":[],"name":"Weapon","summary":"\nWeapon type ","description":"\nWeapon type","class":"class","methods":{"1":"clip1","2":"clip2","3":"getActivity","4":"getHoldType","5":"getNextPrimaryFire","6":"getNextSecondaryFire","7":"getPrimaryAmmoType","8":"getPrintName","9":"getSecondaryAmmoType","10":"isCarriedByLocalPlayer","11":"isWeaponVisible","12":"lastShootTime","lastShootTime":{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},"getNextPrimaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},"clip2":{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},"isCarriedByLocalPlayer":{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]},"getSecondaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},"clip1":{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]},"getActivity":{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},"getPrintName":{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},"getPrimaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},"getNextSecondaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},"getHoldType":{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},"isWeaponVisible":{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]}}},{"comment":["--- Custom wrapper/unwrapper is necessary for weapon objects","-- wrapper"],"code":["local dsetmeta = debug.setmetatable","local function wrap( object )","\tobject = SF.Entities.Wrap( object )","\tdsetmeta( object, weapon_metamethods )","\treturn object","end","","SF.AddObjectWrapper( debug.getregistry().Weapon, weapon_metamethods, wrap )","SF.AddObjectUnwrapper( weapon_metamethods, SF.Entities.Unwrap )",""],"summary":"\nCustom wrapper/unwrapper is necessary for weapon objects \nwrapper ","description":"\nCustom wrapper/unwrapper is necessary for weapon objects \nwrapper","param":[]},{"comment":["--- To string","-- @shared"],"code":["function weapon_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"weapon_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]},{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]},{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]}],"tables":[],"description":"\n \nWeapon functions. \n","summary":"\n \nWeapon functions."},"libs_sh/vectors.lua":{"libraries":[],"type":"file","name":"libs_sh/vectors.lua","functions":{"1":"vec_metamethods.__add","2":"vec_metamethods.__div","3":"vec_metamethods.__eq","4":"vec_metamethods.__index","5":"vec_metamethods.__mul","6":"vec_metamethods.__newindex","7":"vec_metamethods.__sub","8":"vec_metamethods.__tostring","9":"vec_metamethods.__unm","10":"vec_methods.add","11":"vec_methods.cross","12":"vec_methods.div","13":"vec_methods.dot","14":"vec_methods.getAngle","15":"vec_methods.getAngleEx","16":"vec_methods.getDistance","17":"vec_methods.getDistanceSqr","18":"vec_methods.getLength","19":"vec_methods.getLength2D","20":"vec_methods.getLength2DSqr","21":"vec_methods.getLengthSqr","22":"vec_methods.getNormalized","23":"vec_methods.isEqualTol","24":"vec_methods.isZero","25":"vec_methods.mul","26":"vec_methods.normalize","27":"vec_methods.rotate","28":"vec_methods.rotateAroundAxis","29":"vec_methods.set","30":"vec_methods.setZero","31":"vec_methods.sub","32":"vec_methods.toScreen","33":"vec_methods.vdiv","34":"vec_methods.vmul","35":"vec_methods.withinAABox","vec_metamethods.__add":{"ret":"Resultant vector after addition operation.","comment":["--- add metamethod","-- @param v Vector to add","-- @return Resultant vector after addition operation."],"code":["function vec_metamethods.__add ( a, b )","\tSF.CheckType( a, vec_metamethods )","\tSF.CheckType( b, vec_metamethods )","","\treturn wrap( { a[1]+b[1], a[2]+b[2], a[3]+b[3] } )","end",""],"class":"function","name":"vec_metamethods.__add","private":false,"summary":"\nadd metamethod ","description":"\nadd metamethod","param":{"1":"a","2":"b","3":"v","v":"Vector to add"}},"vec_methods.getDistance":{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistance ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn math_sqrt( (v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2 )","end",""],"class":"function","name":"vec_methods.getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"a","2":"v","v":"Second Vector"}},"vec_methods.toScreen":{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods.toScreen ( a )","\treturn unwrap( a ):ToScreen()","end",""],"class":"function","name":"vec_methods.toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":["a"]},"vec_metamethods.__unm":{"ret":"negated vector.","comment":["--- unary minus metamethod","-- @return negated vector."],"code":["function vec_metamethods.__unm ( a )","\tSF.CheckType( a, vec_metamethods )","\treturn wrap( { -a[1], -a[2], -a[3] } )","end",""],"class":"function","name":"vec_metamethods.__unm","private":false,"summary":"\nunary minus metamethod ","description":"\nunary minus metamethod","param":["a"]},"vec_methods.rotate":{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods.rotate ( a, b )","\tSF.CheckType( b, SF.Types[ \"Angle\" ] )","","\tlocal vec = unwrap( a )","\tvec:Rotate( SF.UnwrapObject( b ) )","","\ta[1] = vec.x","\ta[2] = vec.y","\ta[3] = vec.z","end",""],"class":"function","name":"vec_methods.rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","2":"b","a":"Angle to rotate by."}},"vec_methods.vdiv":{"comment":["--- Divide self by a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to divide by"],"code":["function vec_methods.vdiv ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] / v[1]","\ta[2] = a[2] / v[2]","\ta[3] = a[3] / v[3]","end",""],"class":"function","name":"vec_methods.vdiv","summary":"\nDivide self by a Vector.","private":false,"classlib":"Vector","description":"\nDivide self by a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to divide by"}},"vec_metamethods.__eq":{"ret":"bool if both sides are equal.","comment":["--- equivalence metamethod","-- @return bool if both sides are equal."],"code":["function vec_metamethods.__eq ( a, b )","\treturn a[1]==b[1] and a[2]==b[2] and a[3]==b[3]","end",""],"class":"function","name":"vec_metamethods.__eq","private":false,"summary":"\nequivalence metamethod ","description":"\nequivalence metamethod","param":["a","b"]},"vec_methods.getDistanceSqr":{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistanceSqr ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ((v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2)","end",""],"class":"function","name":"vec_methods.getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"a","2":"v","v":"Second Vector"}},"vec_metamethods.__newindex":{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function vec_metamethods.__newindex ( t, k, v )","\tif xyz[ k ] then","\t\trawset( t, xyz[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = vec_metamethods.__methods",""],"private":false,"class":"function","name":"vec_metamethods.__newindex","param":["t","k","v"]},"vec_methods.set":{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods.set ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = v[1]","\ta[2] = v[2]","\ta[3] = v[3]","end",""],"class":"function","name":"vec_methods.set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector"}},"vec_methods.dot":{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.dot ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ( a[1]*v[1] + a[2]*v[2] + a[3]*v[3] )","end",""],"class":"function","name":"vec_methods.dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"a","2":"v","v":"Second Vector"}},"vec_methods.getAngle":{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods.getAngle ( a )","\treturn SF.WrapObject( unwrap( a ):Angle() )","end",""],"class":"function","name":"vec_methods.getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":["a"]},"vec_methods.setZero":{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end",""],"class":"function","name":"vec_methods.setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":["a"]},"vec_methods.vmul":{"comment":["--- Multiply self with a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to multiply with"],"code":["function vec_methods.vmul ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] * v[1]","\ta[2] = a[2] * v[2]","\ta[3] = a[3] * v[3]","end",""],"class":"function","name":"vec_methods.vmul","summary":"\nMultiply self with a Vector.","private":false,"classlib":"Vector","description":"\nMultiply self with a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to multiply with"}},"vec_metamethods.__index":{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function vec_metamethods.__index ( t, k )","\tif xyz[ k ] then","\t\treturn rawget( t, xyz[ k ] )","\telse","\t\treturn _p[k]","\tend","end","","local table_concat = table.concat",""],"private":false,"class":"function","name":"vec_metamethods.__index","param":["t","k"]},"vec_methods.cross":{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods.cross ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn wrap( { a[2]*v[3] - a[3]*v[2], a[3]*v[1] - a[1]*v[3], a[1]*v[2] - a[2]*v[1] } )","end","","local math_sqrt = math.sqrt",""],"class":"function","name":"vec_methods.cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},"vec_methods.div":{"ret":"nil","comment":["--- \"Scalar Division\" of the vector. Self-Modifies.","-- @param n Scalar to divide by.","-- @return nil"],"code":["function vec_methods.div ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] / n","\ta[2] = a[2] / n","\ta[3] = a[3] / n","end",""],"class":"function","name":"vec_methods.div","summary":"\n\"Scalar Division\" of the vector.","private":false,"classlib":"Vector","description":"\n\"Scalar Division\" of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to divide by."}},"vec_methods.add":{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods.add ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] + v[1]","\ta[2] = a[2] + v[2]","\ta[3] = a[3] + v[3]","end",""],"class":"function","name":"vec_methods.add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"a","2":"v","v":"Vector to add"}},"vec_methods.withinAABox":{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods.withinAABox ( a, v1, v2 )","\tSF.CheckType( v1, vec_metamethods )","\tSF.CheckType( v2, vec_metamethods )","","\tif a[1] < v1[1] or a[1] > v2[1] then return false end","\tif a[2] < v1[2] or a[2] > v2[2] then return false end","\tif a[3] < v1[3] or a[3] > v2[3] then return false end","","\treturn true","end"],"class":"function","name":"vec_methods.withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"a","2":"v1","3":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}},"vec_methods.isEqualTol":{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods.isEqualTol ( a, v, t )","\tSF.CheckType( v, vec_metamethods )","\tSF.CheckType( t, \"number\" )","","\treturn unwrap( a ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods.isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"a","2":"v","3":"t","t":"Tolerance number.","v":"Second Vector"}},"vec_methods.getLength2D":{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods.getLength2D ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":["a"]},"vec_metamethods.__tostring":{"ret":"string representing the vector.","comment":["--- tostring metamethod","-- @return string representing the vector."],"code":["function vec_metamethods.__tostring ( a )","\treturn table_concat( a, ' ', 1, 3 )","end",""],"class":"function","name":"vec_metamethods.__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":["a"]},"vec_methods.sub":{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods.sub ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] - v[1]","\ta[2] = a[2] - v[2]","\ta[3] = a[3] - v[3]","end",""],"class":"function","name":"vec_methods.sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector."}},"vec_methods.rotateAroundAxis":{"ret":"Rotated vector","comment":["--- Return rotated vector by an axis","-- @param axis Axis the rotate around","-- @param degrees Angle to rotate by in degrees or nil if radians.","-- @param radians Angle to rotate by in radians or nil if degrees.","-- @return Rotated vector"],"code":["function vec_methods.rotateAroundAxis( a, axis, degrees, radians )","\tSF.CheckType( axis, vec_metamethods )","","\tif degrees then","\t\tSF.CheckType( degrees, \"number\" )","\t\tradians = math.rad(degrees)","\telse","\t\tSF.CheckType( radians, \"number\" )","\tend","","\tlocal ca, sa = math.cos(radians), math.sin(radians)","\tlocal x,y,z,x2,y2,z2 = axis[1], axis[2], axis[3], a[1], a[2], a[3]","\tlocal length = (x*x+y*y+z*z)^0.5","\tx,y,z = x/length, y/length, z/length","","\treturn wrap( { (ca + (x^2)*(1-ca)) * x2 + (x*y*(1-ca) - z*sa) * y2 + (x*z*(1-ca) + y*sa) * z2,","\t\t\t(y*x*(1-ca) + z*sa) * x2 + (ca + (y^2)*(1-ca)) * y2 + (y*z*(1-ca) - x*sa) * z2,","\t\t\t(z*x*(1-ca) - y*sa) * x2 + (z*y*(1-ca) + x*sa) * y2 + (ca + (z^2)*(1-ca)) * z2 } )","end",""],"class":"function","name":"vec_methods.rotateAroundAxis","summary":"\nReturn rotated vector by an axis ","private":false,"classlib":"Vector","description":"\nReturn rotated vector by an axis","param":{"1":"a","2":"axis","3":"degrees","4":"radians","radians":"Angle to rotate by in radians or nil if degrees.","degrees":"Angle to rotate by in degrees or nil if radians.","axis":"Axis the rotate around"}},"vec_metamethods.__div":{"ret":"Scaled vector.","comment":["--- division metamethod","-- @param n Scalar to divide the Vector by","-- @return Scaled vector."],"code":["function vec_metamethods.__div ( a, n )","\tSF.CheckType( a, vec_metamethods )","\tSF.CheckType( n, \"number\" )","","\treturn wrap( { a[1]/n, a[2]/n, a[3]/n } )","end",""],"class":"function","name":"vec_metamethods.__div","private":false,"summary":"\ndivision metamethod ","description":"\ndivision metamethod","param":{"1":"a","2":"n","n":"Scalar to divide the Vector by"}},"vec_methods.getNormalized":{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods.getNormalized ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\treturn wrap( { a[1] / len, a[2] / len, a[3] / len } )","end",""],"class":"function","name":"vec_methods.getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":["a"]},"vec_metamethods.__mul":{"ret":"Scaled vector.","comment":["--- multiplication metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Scaled vector."],"code":["function vec_metamethods.__mul ( a, b )","\tif dgetmeta( a ) == vec_metamethods then","\t\tif dgetmeta( b ) == vec_metamethods then","\t\t\treturn wrap( { a[1]*b[1], a[2]*b[2], a[3]*b[3] } )","\t\tend","","\t\tSF.CheckType( b, \"number\" )","\t\treturn wrap( { a[1]*b, a[2]*b, a[3]*b } )","\telse","\t\tSF.CheckType( a, \"number\" )","\t\treturn wrap( { b[1]*a, b[2]*a, b[3]*a } )","\tend","end",""],"class":"function","name":"vec_metamethods.__mul","private":false,"summary":"\nmultiplication metamethod ","description":"\nmultiplication metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},"vec_metamethods.__sub":{"ret":"Resultant vector after subtraction operation.","comment":["--- sub metamethod","-- @param v Vector to subtract","-- @return Resultant vector after subtraction operation."],"code":["function vec_metamethods.__sub ( a, b )","\tSF.CheckType( a, vec_metamethods )","\tSF.CheckType( b, vec_metamethods )","","\treturn wrap( { a[1]-b[1], a[2]-b[2], a[3]-b[3] } )","end",""],"class":"function","name":"vec_metamethods.__sub","private":false,"summary":"\nsub metamethod ","description":"\nsub metamethod","param":{"1":"a","2":"b","3":"v","v":"Vector to subtract"}},"vec_methods.isZero":{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"vec_methods.isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":["a"]},"vec_methods.getAngleEx":{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods.getAngleEx ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn SF.WrapObject( unwrap( a ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods.getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},"vec_methods.mul":{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods.mul ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] * n","\ta[2] = a[2] * n","\ta[3] = a[3] * n","end",""],"class":"function","name":"vec_methods.mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to multiply with."}},"vec_methods.normalize":{"ret":"nil","comment":["--- Normalise the vector, same direction, length 1. Self-Modifies.","-- @return nil"],"code":["function vec_methods.normalize ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\ta[1] = a[1] / len","\ta[2] = a[2] / len","\ta[3] = a[3] / len","end",""],"class":"function","name":"vec_methods.normalize","summary":"\nNormalise the vector, same direction, length 1.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 1. Self-Modifies.","param":["a"]},"vec_methods.getLength2DSqr":{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods.getLength2DSqr ( a )","\treturn ( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":["a"]},"vec_methods.getLengthSqr":{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods.getLengthSqr ( a )","\treturn ( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":["a"]},"vec_methods.getLength":{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods.getLength ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":["a"]}},"doc":[{"comment":["--- Vector type","-- @shared"],"code":["local vec_methods, vec_metamethods = SF.Typedef( \"Vector\" )","","local function wrap( tbl )","\treturn setmetatable( tbl, vec_metamethods )","end","","local function unwrap( obj )","\treturn Vector( obj[1], obj[2], obj[3] )","end","","local function vwrap( vec )","\treturn wrap( { vec.x, vec.y, vec.z } )","end","","SF.AddObjectWrapper( debug.getregistry().Vector, vec_metamethods, vwrap )","SF.AddObjectUnwrapper( vec_metamethods, unwrap )","","SF.DefaultEnvironment.Vector = function ( x, y, z )","\treturn wrap( { x or 0, y or 0, z or 0 } )","end","","SF.Vectors.Wrap = vwrap","SF.Vectors.Unwrap = unwrap","SF.Vectors.Methods = vec_methods","SF.Vectors.Metatable = vec_metamethods","","local dgetmeta = debug.getmetatable","","-- Lookup table.","-- Index 1->3 have associative xyz for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","local xyz = { x = 1, y = 2, z = 3 }",""],"typtbl":"vec_methods","summary":"\nVector type ","fields":[],"name":"Vector","server":true,"description":"\nVector type","client":true,"class":"class","methods":{"1":"add","2":"cross","3":"div","4":"dot","5":"getAngle","6":"getAngleEx","7":"getDistance","8":"getDistanceSqr","9":"getLength","10":"getLength2D","11":"getLength2DSqr","12":"getLengthSqr","13":"getNormalized","14":"isEqualTol","15":"isZero","16":"mul","17":"normalize","18":"rotate","19":"rotateAroundAxis","20":"set","21":"setZero","22":"sub","23":"toScreen","24":"vdiv","25":"vmul","26":"withinAABox","isEqualTol":{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods.isEqualTol ( a, v, t )","\tSF.CheckType( v, vec_metamethods )","\tSF.CheckType( t, \"number\" )","","\treturn unwrap( a ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods.isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"a","2":"v","3":"t","t":"Tolerance number.","v":"Second Vector"}},"getAngle":{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods.getAngle ( a )","\treturn SF.WrapObject( unwrap( a ):Angle() )","end",""],"class":"function","name":"vec_methods.getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":["a"]},"getLength2D":{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods.getLength2D ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":["a"]},"getLength":{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods.getLength ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":["a"]},"normalize":{"ret":"nil","comment":["--- Normalise the vector, same direction, length 1. Self-Modifies.","-- @return nil"],"code":["function vec_methods.normalize ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\ta[1] = a[1] / len","\ta[2] = a[2] / len","\ta[3] = a[3] / len","end",""],"class":"function","name":"vec_methods.normalize","summary":"\nNormalise the vector, same direction, length 1.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 1. Self-Modifies.","param":["a"]},"dot":{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.dot ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ( a[1]*v[1] + a[2]*v[2] + a[3]*v[3] )","end",""],"class":"function","name":"vec_methods.dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"a","2":"v","v":"Second Vector"}},"getDistance":{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistance ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn math_sqrt( (v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2 )","end",""],"class":"function","name":"vec_methods.getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"a","2":"v","v":"Second Vector"}},"setZero":{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end",""],"class":"function","name":"vec_methods.setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":["a"]},"getLength2DSqr":{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods.getLength2DSqr ( a )","\treturn ( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":["a"]},"rotateAroundAxis":{"ret":"Rotated vector","comment":["--- Return rotated vector by an axis","-- @param axis Axis the rotate around","-- @param degrees Angle to rotate by in degrees or nil if radians.","-- @param radians Angle to rotate by in radians or nil if degrees.","-- @return Rotated vector"],"code":["function vec_methods.rotateAroundAxis( a, axis, degrees, radians )","\tSF.CheckType( axis, vec_metamethods )","","\tif degrees then","\t\tSF.CheckType( degrees, \"number\" )","\t\tradians = math.rad(degrees)","\telse","\t\tSF.CheckType( radians, \"number\" )","\tend","","\tlocal ca, sa = math.cos(radians), math.sin(radians)","\tlocal x,y,z,x2,y2,z2 = axis[1], axis[2], axis[3], a[1], a[2], a[3]","\tlocal length = (x*x+y*y+z*z)^0.5","\tx,y,z = x/length, y/length, z/length","","\treturn wrap( { (ca + (x^2)*(1-ca)) * x2 + (x*y*(1-ca) - z*sa) * y2 + (x*z*(1-ca) + y*sa) * z2,","\t\t\t(y*x*(1-ca) + z*sa) * x2 + (ca + (y^2)*(1-ca)) * y2 + (y*z*(1-ca) - x*sa) * z2,","\t\t\t(z*x*(1-ca) - y*sa) * x2 + (z*y*(1-ca) + x*sa) * y2 + (ca + (z^2)*(1-ca)) * z2 } )","end",""],"class":"function","name":"vec_methods.rotateAroundAxis","summary":"\nReturn rotated vector by an axis ","private":false,"classlib":"Vector","description":"\nReturn rotated vector by an axis","param":{"1":"a","2":"axis","3":"degrees","4":"radians","radians":"Angle to rotate by in radians or nil if degrees.","degrees":"Angle to rotate by in degrees or nil if radians.","axis":"Axis the rotate around"}},"sub":{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods.sub ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] - v[1]","\ta[2] = a[2] - v[2]","\ta[3] = a[3] - v[3]","end",""],"class":"function","name":"vec_methods.sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector."}},"withinAABox":{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods.withinAABox ( a, v1, v2 )","\tSF.CheckType( v1, vec_metamethods )","\tSF.CheckType( v2, vec_metamethods )","","\tif a[1] < v1[1] or a[1] > v2[1] then return false end","\tif a[2] < v1[2] or a[2] > v2[2] then return false end","\tif a[3] < v1[3] or a[3] > v2[3] then return false end","","\treturn true","end"],"class":"function","name":"vec_methods.withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"a","2":"v1","3":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}},"toScreen":{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods.toScreen ( a )","\treturn unwrap( a ):ToScreen()","end",""],"class":"function","name":"vec_methods.toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":["a"]},"set":{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods.set ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = v[1]","\ta[2] = v[2]","\ta[3] = v[3]","end",""],"class":"function","name":"vec_methods.set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector"}},"isZero":{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"vec_methods.isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":["a"]},"getNormalized":{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods.getNormalized ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\treturn wrap( { a[1] / len, a[2] / len, a[3] / len } )","end",""],"class":"function","name":"vec_methods.getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":["a"]},"mul":{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods.mul ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] * n","\ta[2] = a[2] * n","\ta[3] = a[3] * n","end",""],"class":"function","name":"vec_methods.mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to multiply with."}},"vdiv":{"comment":["--- Divide self by a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to divide by"],"code":["function vec_methods.vdiv ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] / v[1]","\ta[2] = a[2] / v[2]","\ta[3] = a[3] / v[3]","end",""],"class":"function","name":"vec_methods.vdiv","summary":"\nDivide self by a Vector.","private":false,"classlib":"Vector","description":"\nDivide self by a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to divide by"}},"div":{"ret":"nil","comment":["--- \"Scalar Division\" of the vector. Self-Modifies.","-- @param n Scalar to divide by.","-- @return nil"],"code":["function vec_methods.div ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] / n","\ta[2] = a[2] / n","\ta[3] = a[3] / n","end",""],"class":"function","name":"vec_methods.div","summary":"\n\"Scalar Division\" of the vector.","private":false,"classlib":"Vector","description":"\n\"Scalar Division\" of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to divide by."}},"getLengthSqr":{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods.getLengthSqr ( a )","\treturn ( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":["a"]},"vmul":{"comment":["--- Multiply self with a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to multiply with"],"code":["function vec_methods.vmul ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] * v[1]","\ta[2] = a[2] * v[2]","\ta[3] = a[3] * v[3]","end",""],"class":"function","name":"vec_methods.vmul","summary":"\nMultiply self with a Vector.","private":false,"classlib":"Vector","description":"\nMultiply self with a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to multiply with"}},"cross":{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods.cross ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn wrap( { a[2]*v[3] - a[3]*v[2], a[3]*v[1] - a[1]*v[3], a[1]*v[2] - a[2]*v[1] } )","end","","local math_sqrt = math.sqrt",""],"class":"function","name":"vec_methods.cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},"getAngleEx":{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods.getAngleEx ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn SF.WrapObject( unwrap( a ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods.getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},"rotate":{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods.rotate ( a, b )","\tSF.CheckType( b, SF.Types[ \"Angle\" ] )","","\tlocal vec = unwrap( a )","\tvec:Rotate( SF.UnwrapObject( b ) )","","\ta[1] = vec.x","\ta[2] = vec.y","\ta[3] = vec.z","end",""],"class":"function","name":"vec_methods.rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","2":"b","a":"Angle to rotate by."}},"getDistanceSqr":{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistanceSqr ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ((v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2)","end",""],"class":"function","name":"vec_methods.getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"a","2":"v","v":"Second Vector"}},"add":{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods.add ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] + v[1]","\ta[2] = a[2] + v[2]","\ta[3] = a[3] + v[3]","end",""],"class":"function","name":"vec_methods.add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"a","2":"v","v":"Vector to add"}}}},{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function vec_metamethods.__newindex ( t, k, v )","\tif xyz[ k ] then","\t\trawset( t, xyz[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = vec_metamethods.__methods",""],"private":false,"class":"function","name":"vec_metamethods.__newindex","param":["t","k","v"]},{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function vec_metamethods.__index ( t, k )","\tif xyz[ k ] then","\t\treturn rawget( t, xyz[ k ] )","\telse","\t\treturn _p[k]","\tend","end","","local table_concat = table.concat",""],"private":false,"class":"function","name":"vec_metamethods.__index","param":["t","k"]},{"ret":"string representing the vector.","comment":["--- tostring metamethod","-- @return string representing the vector."],"code":["function vec_metamethods.__tostring ( a )","\treturn table_concat( a, ' ', 1, 3 )","end",""],"class":"function","name":"vec_metamethods.__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":["a"]},{"ret":"Scaled vector.","comment":["--- multiplication metamethod","-- @param lhs Left side of equation","-- @param rhs Right side of equation","-- @return Scaled vector."],"code":["function vec_metamethods.__mul ( a, b )","\tif dgetmeta( a ) == vec_metamethods then","\t\tif dgetmeta( b ) == vec_metamethods then","\t\t\treturn wrap( { a[1]*b[1], a[2]*b[2], a[3]*b[3] } )","\t\tend","","\t\tSF.CheckType( b, \"number\" )","\t\treturn wrap( { a[1]*b, a[2]*b, a[3]*b } )","\telse","\t\tSF.CheckType( a, \"number\" )","\t\treturn wrap( { b[1]*a, b[2]*a, b[3]*a } )","\tend","end",""],"class":"function","name":"vec_metamethods.__mul","private":false,"summary":"\nmultiplication metamethod ","description":"\nmultiplication metamethod","param":{"1":"a","2":"b","3":"lhs","4":"rhs","rhs":"Right side of equation","lhs":"Left side of equation"}},{"ret":"Scaled vector.","comment":["--- division metamethod","-- @param n Scalar to divide the Vector by","-- @return Scaled vector."],"code":["function vec_metamethods.__div ( a, n )","\tSF.CheckType( a, vec_metamethods )","\tSF.CheckType( n, \"number\" )","","\treturn wrap( { a[1]/n, a[2]/n, a[3]/n } )","end",""],"class":"function","name":"vec_metamethods.__div","private":false,"summary":"\ndivision metamethod ","description":"\ndivision metamethod","param":{"1":"a","2":"n","n":"Scalar to divide the Vector by"}},{"ret":"Resultant vector after addition operation.","comment":["--- add metamethod","-- @param v Vector to add","-- @return Resultant vector after addition operation."],"code":["function vec_metamethods.__add ( a, b )","\tSF.CheckType( a, vec_metamethods )","\tSF.CheckType( b, vec_metamethods )","","\treturn wrap( { a[1]+b[1], a[2]+b[2], a[3]+b[3] } )","end",""],"class":"function","name":"vec_metamethods.__add","private":false,"summary":"\nadd metamethod ","description":"\nadd metamethod","param":{"1":"a","2":"b","3":"v","v":"Vector to add"}},{"ret":"Resultant vector after subtraction operation.","comment":["--- sub metamethod","-- @param v Vector to subtract","-- @return Resultant vector after subtraction operation."],"code":["function vec_metamethods.__sub ( a, b )","\tSF.CheckType( a, vec_metamethods )","\tSF.CheckType( b, vec_metamethods )","","\treturn wrap( { a[1]-b[1], a[2]-b[2], a[3]-b[3] } )","end",""],"class":"function","name":"vec_metamethods.__sub","private":false,"summary":"\nsub metamethod ","description":"\nsub metamethod","param":{"1":"a","2":"b","3":"v","v":"Vector to subtract"}},{"ret":"negated vector.","comment":["--- unary minus metamethod","-- @return negated vector."],"code":["function vec_metamethods.__unm ( a )","\tSF.CheckType( a, vec_metamethods )","\treturn wrap( { -a[1], -a[2], -a[3] } )","end",""],"class":"function","name":"vec_metamethods.__unm","private":false,"summary":"\nunary minus metamethod ","description":"\nunary minus metamethod","param":["a"]},{"ret":"bool if both sides are equal.","comment":["--- equivalence metamethod","-- @return bool if both sides are equal."],"code":["function vec_metamethods.__eq ( a, b )","\treturn a[1]==b[1] and a[2]==b[2] and a[3]==b[3]","end",""],"class":"function","name":"vec_metamethods.__eq","private":false,"summary":"\nequivalence metamethod ","description":"\nequivalence metamethod","param":["a","b"]},{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods.add ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] + v[1]","\ta[2] = a[2] + v[2]","\ta[3] = a[3] + v[3]","end",""],"class":"function","name":"vec_methods.add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"a","2":"v","v":"Vector to add"}},{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods.getAngle ( a )","\treturn SF.WrapObject( unwrap( a ):Angle() )","end",""],"class":"function","name":"vec_methods.getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":["a"]},{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods.getAngleEx ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn SF.WrapObject( unwrap( a ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods.getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods.cross ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn wrap( { a[2]*v[3] - a[3]*v[2], a[3]*v[1] - a[1]*v[3], a[1]*v[2] - a[2]*v[1] } )","end","","local math_sqrt = math.sqrt",""],"class":"function","name":"vec_methods.cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistance ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn math_sqrt( (v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2 )","end",""],"class":"function","name":"vec_methods.getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"a","2":"v","v":"Second Vector"}},{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistanceSqr ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ((v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2)","end",""],"class":"function","name":"vec_methods.getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"a","2":"v","v":"Second Vector"}},{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.dot ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ( a[1]*v[1] + a[2]*v[2] + a[3]*v[3] )","end",""],"class":"function","name":"vec_methods.dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"a","2":"v","v":"Second Vector"}},{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods.getNormalized ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\treturn wrap( { a[1] / len, a[2] / len, a[3] / len } )","end",""],"class":"function","name":"vec_methods.getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":["a"]},{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods.isEqualTol ( a, v, t )","\tSF.CheckType( v, vec_metamethods )","\tSF.CheckType( t, \"number\" )","","\treturn unwrap( a ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods.isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"a","2":"v","3":"t","t":"Tolerance number.","v":"Second Vector"}},{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"vec_methods.isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":["a"]},{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods.getLength ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":["a"]},{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods.getLengthSqr ( a )","\treturn ( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":["a"]},{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods.getLength2D ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":["a"]},{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods.getLength2DSqr ( a )","\treturn ( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":["a"]},{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods.mul ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] * n","\ta[2] = a[2] * n","\ta[3] = a[3] * n","end",""],"class":"function","name":"vec_methods.mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to multiply with."}},{"ret":"nil","comment":["--- \"Scalar Division\" of the vector. Self-Modifies.","-- @param n Scalar to divide by.","-- @return nil"],"code":["function vec_methods.div ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] / n","\ta[2] = a[2] / n","\ta[3] = a[3] / n","end",""],"class":"function","name":"vec_methods.div","summary":"\n\"Scalar Division\" of the vector.","private":false,"classlib":"Vector","description":"\n\"Scalar Division\" of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to divide by."}},{"comment":["--- Multiply self with a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to multiply with"],"code":["function vec_methods.vmul ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] * v[1]","\ta[2] = a[2] * v[2]","\ta[3] = a[3] * v[3]","end",""],"class":"function","name":"vec_methods.vmul","summary":"\nMultiply self with a Vector.","private":false,"classlib":"Vector","description":"\nMultiply self with a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to multiply with"}},{"comment":["--- Divide self by a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to divide by"],"code":["function vec_methods.vdiv ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] / v[1]","\ta[2] = a[2] / v[2]","\ta[3] = a[3] / v[3]","end",""],"class":"function","name":"vec_methods.vdiv","summary":"\nDivide self by a Vector.","private":false,"classlib":"Vector","description":"\nDivide self by a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to divide by"}},{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end",""],"class":"function","name":"vec_methods.setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":["a"]},{"ret":"nil","comment":["--- Normalise the vector, same direction, length 1. Self-Modifies.","-- @return nil"],"code":["function vec_methods.normalize ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\ta[1] = a[1] / len","\ta[2] = a[2] / len","\ta[3] = a[3] / len","end",""],"class":"function","name":"vec_methods.normalize","summary":"\nNormalise the vector, same direction, length 1.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 1. Self-Modifies.","param":["a"]},{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods.rotate ( a, b )","\tSF.CheckType( b, SF.Types[ \"Angle\" ] )","","\tlocal vec = unwrap( a )","\tvec:Rotate( SF.UnwrapObject( b ) )","","\ta[1] = vec.x","\ta[2] = vec.y","\ta[3] = vec.z","end",""],"class":"function","name":"vec_methods.rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","2":"b","a":"Angle to rotate by."}},{"ret":"Rotated vector","comment":["--- Return rotated vector by an axis","-- @param axis Axis the rotate around","-- @param degrees Angle to rotate by in degrees or nil if radians.","-- @param radians Angle to rotate by in radians or nil if degrees.","-- @return Rotated vector"],"code":["function vec_methods.rotateAroundAxis( a, axis, degrees, radians )","\tSF.CheckType( axis, vec_metamethods )","","\tif degrees then","\t\tSF.CheckType( degrees, \"number\" )","\t\tradians = math.rad(degrees)","\telse","\t\tSF.CheckType( radians, \"number\" )","\tend","","\tlocal ca, sa = math.cos(radians), math.sin(radians)","\tlocal x,y,z,x2,y2,z2 = axis[1], axis[2], axis[3], a[1], a[2], a[3]","\tlocal length = (x*x+y*y+z*z)^0.5","\tx,y,z = x/length, y/length, z/length","","\treturn wrap( { (ca + (x^2)*(1-ca)) * x2 + (x*y*(1-ca) - z*sa) * y2 + (x*z*(1-ca) + y*sa) * z2,","\t\t\t(y*x*(1-ca) + z*sa) * x2 + (ca + (y^2)*(1-ca)) * y2 + (y*z*(1-ca) - x*sa) * z2,","\t\t\t(z*x*(1-ca) - y*sa) * x2 + (z*y*(1-ca) + x*sa) * y2 + (ca + (z^2)*(1-ca)) * z2 } )","end",""],"class":"function","name":"vec_methods.rotateAroundAxis","summary":"\nReturn rotated vector by an axis ","private":false,"classlib":"Vector","description":"\nReturn rotated vector by an axis","param":{"1":"a","2":"axis","3":"degrees","4":"radians","radians":"Angle to rotate by in radians or nil if degrees.","degrees":"Angle to rotate by in degrees or nil if radians.","axis":"Axis the rotate around"}},{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods.set ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = v[1]","\ta[2] = v[2]","\ta[3] = v[3]","end",""],"class":"function","name":"vec_methods.set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector"}},{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods.sub ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] - v[1]","\ta[2] = a[2] - v[2]","\ta[3] = a[3] - v[3]","end",""],"class":"function","name":"vec_methods.sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector."}},{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods.toScreen ( a )","\treturn unwrap( a ):ToScreen()","end",""],"class":"function","name":"vec_methods.toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":["a"]},{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods.withinAABox ( a, v1, v2 )","\tSF.CheckType( v1, vec_metamethods )","\tSF.CheckType( v2, vec_metamethods )","","\tif a[1] < v1[1] or a[1] > v2[1] then return false end","\tif a[2] < v1[2] or a[2] > v2[2] then return false end","\tif a[3] < v1[3] or a[3] > v2[3] then return false end","","\treturn true","end"],"class":"function","name":"vec_methods.withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"a","2":"v1","3":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}}],"tables":[],"description":"\nVector type","summary":"\nVector type "},"editor.lua":{"libraries":[],"type":"file","name":"editor.lua","functions":{"1":"SF.Editor.BuildIncludesTable","SF.Editor.BuildIncludesTable":{"ret":["True if ok, false if a file was missing","A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"comment":["\t--- (Client) Builds a table for the compiler to use","\t-- @param maincode The source code for the main chunk","\t-- @param codename The name of the main chunk","\t-- @return True if ok, false if a file was missing","\t-- @return A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"code":["\tfunction SF.Editor.BuildIncludesTable ( maincode, codename )","\t\tif not SF.Editor.initialized then SF.Editor.init() return false, \"Loading Editor\" end","\t\tlocal tbl = {}","\t\tmaincode = maincode or SF.Editor.getCode()","\t\tcodename = codename or SF.Editor.getOpenFile() or \"main\"","\t\ttbl.mainfile = codename","\t\ttbl.files = {}","\t\ttbl.filecount = 0","\t\ttbl.includes = {}","","\t\tlocal loaded = {}","\t\tlocal ppdata = {}","","\t\tlocal function recursiveLoad ( path )","\t\t\tif loaded[ path ] then return end","\t\t\tloaded[ path ] = true","\t\t\t","\t\t\tlocal code","\t\t\tif path == codename and maincode then","\t\t\t\tcode = maincode","\t\t\telse","\t\t\t\tcode = file.Read( \"starfall/\"..path, \"DATA\" )","\t\t\tend","\t\t\tif not code then","\t\t\t\tprint( \"Bad include: \" .. path )","\t\t\t\treturn","\t\t\tend","\t\t\t","\t\t\ttbl.files[ path ] = code","\t\t\tSF.Preprocessor.ParseDirectives( path, code, {}, ppdata )","\t\t\t","\t\t\tif ppdata.includes and ppdata.includes[ path ] then","\t\t\t\tlocal inc = ppdata.includes[ path ]","\t\t\t\tif not tbl.includes[ path ] then","\t\t\t\t\ttbl.includes[ path ] = inc","\t\t\t\t\ttbl.filecount = tbl.filecount + 1","\t\t\t\telse","\t\t\t\t\tassert( tbl.includes[ path ] == inc )","\t\t\t\tend","\t\t\t\t","\t\t\t\tfor i = 1, #inc do","\t\t\t\t\trecursiveLoad( inc[i] )","\t\t\t\tend","\t\t\tend","\t\tend","\t\tlocal ok, msg = pcall( recursiveLoad, codename )","","\t\tlocal function findCycle ( file, visited, recStack )","\t\t\tif not visited[ file ] then","\t\t\t\t--Mark the current file as visited and part of recursion stack","\t\t\t\tvisited[ file ] = true","\t\t\t\trecStack[ file ] = true","","\t\t\t\t--Recurse for all the files included in this file","\t\t\t\tfor k, v in pairs( ppdata.includes[ file ] or {} ) do","\t\t\t\t\tif recStack[ v ] then","\t\t\t\t\t\treturn true, file","\t\t\t\t\telseif not visited[ v ] then","\t\t\t\t\t\tlocal cyclic, cyclicFile = findCycle( v, visited, recStack )","\t\t\t\t\t\tif cyclic then return true, cyclicFile end","\t\t\t\t\tend","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\t--Remove this file from the recursion stack","\t\t\trecStack[ file ] = false","\t\t\treturn false, nil","\t\tend","","\t\tlocal isCyclic = false","\t\tlocal cyclicFile = nil","\t\tfor k, v in pairs( ppdata.includes or {} ) do","\t\t\tlocal cyclic, file = findCycle( k, {}, {} )","\t\t\tif cyclic then","\t\t\t\tisCyclic = true","\t\t\t\tcyclicFile = file","\t\t\t\tbreak","\t\t\tend","\t\tend","\t\t","\t\tif isCyclic then","\t\t\treturn false, \"Loop in includes from: \" .. cyclicFile","\t\tend","","\t\tif ok then","\t\t\treturn true, tbl","\t\telseif msg:sub( 1, 13 ) == \"Bad include: \" then","\t\t\treturn false, msg","\t\telse","\t\t\terror( msg, 0 )","\t\tend","\tend","","\t-- CLIENT ANIMATION","","\tlocal busy_players = { }","\thook.Add( \"EntityRemoved\", \"starfall_busy_animation\", function ( ply )","\t\tbusy_players[ ply ] = nil","\tend )","","\tlocal emitter = ParticleEmitter( vector_origin )","","\tnet.Receive( \"starfall_editor_status\", function ( len )","\t\tlocal ply = net.ReadEntity()","\t\tlocal status = net.ReadBit() ~= 0 -- net.ReadBit returns 0 or 1, despite net.WriteBit taking a boolean","\t\tif not ply:IsValid() or ply == LocalPlayer() then return end","","\t\tbusy_players[ ply ] = status or nil","\tend )","","\tlocal rolldelta = math.rad( 80 )","\ttimer.Create( \"starfall_editor_status\", 1 / 3, 0, function ()","\t\trolldelta = -rolldelta","\t\tfor ply, _ in pairs( busy_players ) do","\t\t\tlocal BoneIndx = ply:LookupBone( \"ValveBiped.Bip01_Head1\" ) or ply:LookupBone( \"ValveBiped.HC_Head_Bone\" ) or 0","\t\t\tlocal BonePos, BoneAng = ply:GetBonePosition( BoneIndx )","\t\t\tlocal particle = emitter:Add( \"radon/starfall2\", BonePos + Vector( math.random( -10, 10 ), math.random( -10, 10 ), 60 + math.random( 0, 10 ) ) )","\t\t\tif particle then","\t\t\t\tparticle:SetColor( math.random( 30, 50 ), math.random( 40, 150 ), math.random( 180, 220 ) )","\t\t\t\tparticle:SetVelocity( Vector( 0, 0, -40 ) )","","\t\t\t\tparticle:SetDieTime( 1.5 )","\t\t\t\tparticle:SetLifeTime( 0 )","","\t\t\t\tparticle:SetStartSize( 10 )","\t\t\t\tparticle:SetEndSize( 5 )","","\t\t\t\tparticle:SetStartAlpha( 255 )","\t\t\t\tparticle:SetEndAlpha( 0 )","","\t\t\t\tparticle:SetRollDelta( rolldelta )","\t\t\tend","\t\tend","\tend )","","elseif SERVER then","","\tutil.AddNetworkString( \"starfall_editor_status\" )","","\tlocal function getFiles ( dir, dir2 )","\t\tlocal files = {}","\t\tlocal dir2 = dir2 or \"\"","\t\tlocal f, directories = file.Find( dir .. \"/\" .. dir2 .. \"/*\", \"GAME\" )","\t\tfor k, v in pairs( f ) do","\t\t\tfiles[ #files + 1 ] = dir2 .. \"/\" .. v","\t\tend","\t\tfor k, v in pairs( directories ) do","\t\t\ttable.Add( files, getFiles( dir, dir2 .. \"/\" .. v ) )","\t\tend","\t\treturn files","\tend","","\tfor k, v in pairs( getFiles( addon_path, \"materials/radon\" ) ) do","\t\tresource.AddFile( v )","\tend","","\tlocal starfall_event = {}","","\tconcommand.Add( \"starfall_event\", function ( ply, command, args )","\t\tlocal handler = starfall_event[ args[ 1 ] ]","\t\tif not handler then return end","\t\treturn handler( ply, args )","\tend )","","\tfunction starfall_event.editor_open ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( true )","\t\tnet.Broadcast()","\tend","","\tfunction starfall_event.editor_close ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( false )","\t\tnet.Broadcast()","\tend","end"],"class":"function","name":"SF.Editor.BuildIncludesTable","private":false,"summary":"\n(Client) Builds a table for the compiler to use ","description":"\n(Client) Builds a table for the compiler to use","param":{"1":"maincode","2":"codename","codename":"The name of the main chunk","maincode":"The source code for the main chunk"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","--\tSF Editor","--\tOriginally created by Jazzelhawk","--\t","--\tTo do:","--\tFind new icons","-------------------------------------------------------------------------------"],"code":["","SF.Editor = {}","","local addon_path = nil","","do","\tlocal tbl = debug.getinfo( 1 )","\tlocal file = tbl.short_src","\taddon_path = string.TrimRight( string.match( file, \".-/.-/\" ), \"/\" )","end","","if CLIENT then","","\tinclude( \"sfderma.lua\" )","","\t-- Colors","\tSF.Editor.colors = {}","\tSF.Editor.colors.dark \t\t= Color( 36, 41, 53 )","\tSF.Editor.colors.meddark \t= Color( 48, 57, 92 )","\tSF.Editor.colors.med \t\t= Color( 78, 122, 199 )","\tSF.Editor.colors.medlight \t= Color( 127, 178, 240 )","\tSF.Editor.colors.light \t\t= Color( 173, 213, 247 )","","\t-- Icons","\tSF.Editor.icons = {}","\tSF.Editor.icons.arrowr \t\t= Material( \"radon/arrow_right.png\", \"noclamp smooth\" )","\tSF.Editor.icons.arrowl \t\t= Material( \"radon/arrow_left.png\", \"noclamp smooth\" )","","\tlocal defaultCode = [[--@name ","--@author ","--@shared ","","--[[","\tStarfall Scripting Environment","","\tGithub: https://github.com/thegrb93/StarfallEx","\tReference Page: http://thegrb93.github.io/Starfall/","\tDevelopment Thread: http://www.wiremod.com/forum/developers-showcase/22739-starfall-processor.html","","\tDefault Keyboard shortcuts: https://github.com/ajaxorg/ace/wiki/Default-Keyboard-Shortcuts","]]..\"]]\"","","\tlocal invalid_filename_chars = {","\t\t[\"*\"] = \"\",","\t\t[\"?\"] = \"\",","\t\t[\">\"] = \"\",","\t\t[\"<\"] = \"\",","\t\t[\"|\"] = \"\",","\t\t[\"\\\\\"] = \"\",","\t\t['\"'] = \"\",","\t}","","\tCreateClientConVar( \"sf_editor_width\", 1100, true, false )","\tCreateClientConVar( \"sf_editor_height\", 760, true, false )","\tCreateClientConVar( \"sf_editor_posx\", ScrW() / 2 - 1100 / 2, true, false )","\tCreateClientConVar( \"sf_editor_posy\", ScrH() / 2 - 760 / 2, true, false )","","\tCreateClientConVar( \"sf_fileviewer_width\", 263, true, false )","\tCreateClientConVar( \"sf_fileviewer_height\", 760, true, false )","\tCreateClientConVar( \"sf_fileviewer_posx\", ScrW() / 2 - 1100 / 2 - 263, true, false )","\tCreateClientConVar( \"sf_fileviewer_posy\", ScrH() / 2 - 760 / 2, true, false )","\tCreateClientConVar( \"sf_fileviewer_locked\", 1, true, false )","","\tCreateClientConVar( \"sf_modelviewer_width\", 930, true, false )","\tCreateClientConVar( \"sf_modelviewer_height\", 615, true, false )","\tCreateClientConVar( \"sf_modelviewer_posx\", ScrW() / 2 - 930 / 2, true, false )","\tCreateClientConVar( \"sf_modelviewer_posy\", ScrH() / 2 - 615 / 2, true, false )","","\tCreateClientConVar( \"sf_editor_wordwrap\", 1, true, false )","\tCreateClientConVar( \"sf_editor_widgets\", 1, true, false )","\tCreateClientConVar( \"sf_editor_linenumbers\", 1, true, false )","\tCreateClientConVar( \"sf_editor_gutter\", 1, true, false )","\tCreateClientConVar( \"sf_editor_invisiblecharacters\", 0, true, false )","\tCreateClientConVar( \"sf_editor_indentguides\", 1, true, false )","\tCreateClientConVar( \"sf_editor_activeline\", 1, true, false )","\tCreateClientConVar( \"sf_editor_autocompletion\", 1, true, false )","\tCreateClientConVar( \"sf_editor_liveautocompletion\", 0, true, false )","\tCreateClientConVar( \"sf_editor_fixkeys\", system.IsLinux() and 1 or 0, true, false ) --maybe osx too? need someone to check","\tCreateClientConVar( \"sf_editor_fixconsolebug\", 0, true, false )","\tCreateClientConVar( \"sf_editor_disablelinefolding\", 0, true, false )","\tCreateClientConVar( \"sf_editor_keybindings\", \"ace\", true, false )","\tCreateClientConVar( \"sf_editor_fontsize\", 13, true, false )","","\tlocal editorUrl = \"http://thegrb93.github.io/StarfallEx/starfall/editor.html\"","","\tfunction SF.Editor.init ()","","\t\tif not file.Exists( \"starfall\", \"DATA\" ) then","\t\t\tfile.CreateDir( \"starfall\" )","\t\tend","\t\tif SF.Editor.editor then return end","","\t\tSF.Editor.editor = SF.Editor.createEditor()","\t\tSF.Editor.fileViewer = SF.Editor.createFileViewer()","\t\tSF.Editor.settingsWindow = SF.Editor.createSettingsWindow()","\t\tSF.Editor.modelViewer = SF.Editor.createModelViewer()","","\t\tSF.Editor.runJS = function ( ... ) ","\t\t\tSF.Editor.editor.components.htmlPanel:QueueJavascript( ... )","\t\tend","\t\t","\t\tSF.Editor.updateSettings ()","\tend","","\tfunction SF.Editor.open ()","\t\tif not SF.Editor.initialized then","\t\t\tSF.Editor.init ()","\t\tend","\t\t","\t\tSF.Editor.editor:open()","","\t\tif CanRunConsoleCommand() then","\t\t\tRunConsoleCommand( \"starfall_event\", \"editor_open\" )","\t\tend","\tend","","\tfunction SF.Editor.close ()","\t\tSF.Editor.editor:close()","","\t\tif CanRunConsoleCommand() then","\t\t\tRunConsoleCommand( \"starfall_event\", \"editor_close\" )","\t\tend","\tend","","\tfunction SF.Editor.updateCode () -- Incase anyone needs to force update the code","\t\tSF.Editor.runJS( \"console.log(\\\"RUNLUA:SF.Editor.getActiveTab().code = \\\\\\\"\\\" + addslashes(editor.getValue()) + \\\"\\\\\\\"\\\")\" )","\tend","","\tfunction SF.Editor.getCode ()","\t\tif SF.Editor.getActiveTab() then","\t\t\treturn SF.Editor.getActiveTab().code","\t\tend","\t\treturn \"\"","\tend","","\tfunction SF.Editor.getOpenFile ()","\t\treturn SF.Editor.getActiveTab().filename","\tend","","\tfunction SF.Editor.getTabHolder ()","\t\treturn SF.Editor.editor.components[ \"tabHolder\" ]","\tend","","\tfunction SF.Editor.getActiveTab ()","\t\treturn SF.Editor.getTabHolder():getActiveTab()","\tend","","\tfunction SF.Editor.selectTab ( tab )","\t\tlocal tabHolder = SF.Editor.getTabHolder()","\t\tif type( tab ) == \"number\" then","\t\t\ttab = math.min( tab, #tabHolder.tabs )","\t\t\ttab = tabHolder.tabs[ tab ]  ","\t\tend","\t\tif tab == nil then","\t\t\tSF.Editor.selectTab( 1 )","\t\t\treturn","\t\tend","","\t\ttabHolder:selectTab( tab )","","\t\tSF.Editor.runJS( \"selectEditSession(\"..tabHolder:getTabIndex( tab )..\")\" )","\tend","","\tfunction SF.Editor.addTab ( filename, code )","","\t\tlocal name = filename or \"generic\"","","\t\tif code then","\t\t\tlocal ppdata = {}","\t\t\tSF.Preprocessor.ParseDirectives( \"file\", code, {}, ppdata )","\t\t\tif ppdata.scriptnames and ppdata.scriptnames.file ~= \"\" then ","\t\t\t\tname = ppdata.scriptnames.file","\t\t\tend","\t\tend","","\t\tcode = code or defaultCode","","\t\t-- Settings to pass to editor when creating a new session","\t\tlocal settings = util.TableToJSON({","\t\t\twrap = GetConVarNumber( \"sf_editor_wordwrap\" )","\t\t}):JavascriptSafe()","","\t\tSF.Editor.runJS( \"newEditSession(\\\"\" .. string.JavascriptSafe( code or defaultCode ) .. \"\\\", JSON.parse(\\\"\" .. settings .. \"\\\"))\" )","","\t\tlocal tab = SF.Editor.getTabHolder():addTab( name )","\t\ttab.code = code","\t\ttab.name = name","\t\ttab.filename = filename","","\t\tfunction tab:DoClick ()","\t\t\tSF.Editor.selectTab( self )","\t\tend","","\t\tSF.Editor.selectTab( tab )","\tend","","\tfunction SF.Editor.removeTab ( tab )","\t\tlocal tabHolder = SF.Editor.getTabHolder()","\t\tif type( tab ) == \"number\" then","\t\t\ttab = tabHolder.tabs[ tab ]  ","\t\tend","\t\tif tab == nil then return end","","\t\ttabHolder:removeTab( tab )","\tend","","\tfunction SF.Editor.saveTab ( tab )","\t\tif not tab.filename then SF.Editor.saveTabAs( tab ) return end","\t\tlocal saveFile = \"starfall/\" .. tab.filename","\t\tfile.Write( saveFile, tab.code )","\t\tSF.Editor.updateTabName( tab )","\t\tSF.AddNotify( LocalPlayer(), \"Starfall code saved as \" .. saveFile .. \".\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\tend","","\tfunction SF.Editor.saveTabAs ( tab )","","\t\tSF.Editor.updateTabName( tab )","","\t\tlocal saveName = \"\"","\t\tif tab.filename then","\t\t\tsaveName = string.StripExtension( tab.filename )","\t\telse","\t\t\tsaveName = tab.name or \"generic\"","\t\tend","","\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"Save File\",","\t\t\t\t\"\",","\t\t\t\tsaveName,","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal saveFile = \"starfall/\" .. text .. \".txt\"","\t\t\t\t\tfile.Write( saveFile, tab.code )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"Starfall code saved as \" .. saveFile .. \".\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tSF.Editor.fileViewer.components[ \"browser\" ].tree:reloadTree()","\t\t\t\t\ttab.filename = text .. \".txt\"","\t\t\t\t\tSF.Editor.updateTabName( tab )","\t\t\t\tend","\t\t\t)","\tend","","\tfunction SF.Editor.doValidation ( forceShow )","","\t\tlocal function valid ()","\t\t\tlocal code = SF.Editor.getActiveTab().code","\t\t\tif code and code == \"\" then SF.Editor.runJS( \"editor.session.clearAnnotations(); clearErrorLines()\" ) return end","","\t\t\tlocal err = CompileString( code, \"Validation\", false )","","\t\t\tif type( err ) ~= \"string\" then ","\t\t\t\tif forceShow then SF.AddNotify( LocalPlayer(), \"Validation successful\", NOTIFY_GENERIC, 3, NOTIFYSOUND_DRIP3 ) end","\t\t\t\tSF.Editor.runJS( \"editor.session.clearAnnotations(); clearErrorLines()\" )","\t\t\t\treturn ","\t\t\tend","","\t\t\tlocal row = tonumber( err:match( \"%d+\" ) ) - 1","\t\t\tlocal message = err:match( \": .+$\" ):sub( 3 )","","\t\t\tSF.Editor.runJS( string.format( \"editor.session.setAnnotations([{row: %d, text: \\\"%s\\\", type: \\\"error\\\"}])\", row, message:JavascriptSafe() ) )","\t\t\tSF.Editor.runJS( [[","\t\t\t\tclearErrorLines();","","\t\t\t\tvar Range = ace.require(\"ace/range\").Range;","\t\t\t\tvar range = new Range(]] .. row .. [[, 1, ]] .. row .. [[, Infinity);","","\t\t\t\teditor.session.addMarker(range, \"ace_error\", \"screenLine\");","","\t\t\t]] )","\t\t\t","\t\t\tif not forceShow then return end","","\t\t\tSF.Editor.runJS( \"editor.session.unfold({row: \" .. row .. \", column: 0})\" )","\t\t\tSF.Editor.runJS( \"editor.scrollToLine( \" .. row .. \", true )\" )","","","\t\tend","\t\tif forceShow then valid() return end","\t\tif not timer.Exists( \"validationTimer\" ) or ( timer.Exists( \"validationTimer\") and not timer.Adjust( \"validationTimer\", 0.5, 1, valid ) ) then","\t\t\ttimer.Remove( \"validationTimer\" )","\t\t\ttimer.Create( \"validationTimer\", 0.5, 1, valid )","\t\tend","","\tend","","\tlocal function createLibraryMap ()","","\t\tlocal map = {}","","\t\tfor lib, tbl in pairs( SF.Types ) do","\t\t\tif ( lib == \"Environment\" or lib:find( \"Library: \" ) ) and type( tbl.__index ) == \"table\" then","\t\t\t\tlib = lib:Replace( \"Library: \", \"\" )","\t\t\t\tmap[ lib ] = {}","\t\t\t\tfor name, val in pairs( tbl.__index ) do","\t\t\t\t\ttable.insert( map[ lib ], name )","\t\t\t\tend","\t\t\tend","\t\tend","","\t\tmap.Angle = {}","\t\tfor name, val in pairs( SF.Angles.Methods ) do","\t\t\ttable.insert( map.Angle, name )","\t\tend","\t\tmap.Color = {}","\t\tfor name, val in pairs( SF.Color.Methods ) do","\t\t\ttable.insert( map.Color, name )","\t\tend","\t\tmap.Entity = {}","\t\tfor name, val in pairs( SF.Entities.Methods ) do","\t\t\ttable.insert( map.Entity, name )","\t\tend","\t\tmap.Player = {}","\t\tfor name, val in pairs( SF.Players.Methods ) do","\t\t\ttable.insert( map.Player, name )","\t\tend","\t\tmap.Sound = {}","\t\tfor name, val in pairs( SF.Sounds.Methods ) do","\t\t\ttable.insert( map.Sound, name )","\t\tend","\t\tmap.VMatrix = {}","\t\tfor name, val in pairs( SF.VMatrix.Methods ) do","\t\t\ttable.insert( map.VMatrix, name )","\t\tend","\t\tmap.Vector = {}","\t\tfor name, val in pairs( SF.Vectors.Methods ) do","\t\t\ttable.insert( map.Vector, name )","\t\tend","","\t\treturn map","\tend","","\tfunction SF.Editor.refreshTab ( tab )","","\t\tlocal tabHolder = SF.Editor.getTabHolder()","\t\tif type( tab ) == \"number\" then","\t\t\ttab = tabHolder.tabs[ tab ]  ","\t\tend","\t\tif tab == nil then return end","","\t\tSF.Editor.updateTabName( tab )","","\t\tlocal fileName = tab.filename","\t\tlocal tabIndex = tabHolder:getTabIndex( tab )","","\t\tif not fileName or not file.Exists( \"starfall/\" .. fileName, \"DATA\" ) then ","\t\t\tSF.AddNotify( LocalPlayer(), \"Unable to refresh tab as file doesn't exist\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\t\t\treturn ","\t\tend","","\t\tlocal fileData = file.Read( \"starfall/\" .. fileName, \"DATA\" )","","\t\tSF.Editor.runJS( \"editSessions[ \" .. tabIndex .. \" - 1 ].setValue( \\\"\" .. fileData:JavascriptSafe() .. \"\\\" )\" )","","\t\tSF.Editor.updateTabName( tab )","","\t\tSF.AddNotify( LocalPlayer(), \"Refreshed tab: \" .. fileName, NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\tend","","\tfunction SF.Editor.updateTabName ( tab )","\t\tlocal ppdata = {}","\t\tSF.Preprocessor.ParseDirectives( \"tab\", tab.code, {}, ppdata )","\t\tif ppdata.scriptnames and ppdata.scriptnames.tab ~= \"\" then ","\t\t\ttab.name = ppdata.scriptnames.tab","\t\telse","\t\t\ttab.name = tab.filename or \"generic\"","\t\tend","\t\ttab:SetText( tab.name )","\tend","","\tfunction SF.Editor.createEditor ()","\t\tlocal editor = vgui.Create( \"StarfallFrame\" )","\t\teditor:DockPadding( 0, 0, 0, 0 )","\t\teditor:SetTitle( \"Starfall Code Editor\" )","\t\teditor:Center()","","\t\tfunction editor:OnKeyCodePressed ( keyCode )","\t\t\tif keyCode == KEY_S and ( input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) ) and not input.IsKeyDown( KEY_LALT ) then","\t\t\t\tSF.Editor.saveTab( SF.Editor.getActiveTab() )","\t\t\telseif keyCode == KEY_Q and ( input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) ) and not input.IsKeyDown( KEY_LALT ) then","\t\t\t\tSF.Editor.close()","\t\t\tend","\t\tend","","\t\tlocal buttonHolder = editor.components[ \"buttonHolder\" ]","","\t\tbuttonHolder:getButton( \"Close\" ).DoClick = function ( self )","\t\t\tSF.Editor.close()","\t\tend","","\t\tbuttonHolder:removeButton( \"Lock\" )","","\t\tlocal buttonSaveExit = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSaveExit:SetText( \"Save and Exit\" )","\t\tfunction buttonSaveExit:DoClick ()","\t\t\tSF.Editor.saveTab( SF.Editor.getActiveTab() )","\t\t\tSF.Editor.close()","\t\tend","\t\tbuttonHolder:addButton( \"SaveExit\", buttonSaveExit )","","\t\tlocal buttonSettings = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSettings:SetText( \"Settings\" )","\t\tfunction buttonSettings:DoClick ()","\t\t\tif SF.Editor.settingsWindow:IsVisible() then","\t\t\t\tSF.Editor.settingsWindow:close()","\t\t\telse","\t\t\t\tSF.Editor.settingsWindow:open()","\t\t\tend","\t\tend","\t\tbuttonHolder:addButton( \"Settings\", buttonSettings )","","\t\tlocal buttonHelper = vgui.Create( \"StarfallButton\", buttonHolder )\t","\t\tbuttonHelper:SetText( \"SF Helper\" )","\t\tfunction buttonHelper:DoClick ()","\t\t\tif SF.Helper.Frame and SF.Helper.Frame:IsVisible() then","\t\t\t\tSF.Helper.Frame:close()","\t\t\telse","\t\t\t\tSF.Helper.show()","\t\t\tend","\t\tend","\t\tbuttonHolder:addButton( \"Helper\", buttonHelper )","","\t\tlocal buttonModels = vgui.Create( \"StarfallButton\", buttonHolder )\t","\t\tbuttonModels:SetText( \"Model Viewer\" )","\t\tfunction buttonModels:DoClick ()","\t\t\tif SF.Editor.modelViewer:IsVisible() then","\t\t\t\tSF.Editor.modelViewer:close()","\t\t\telse","\t\t\t\tSF.Editor.modelViewer:open()","\t\t\tend","\t\tend","\t\tbuttonHolder:addButton( \"Model Viewer\", buttonModels )","","\t\tlocal buttonFiles = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonFiles:SetText( \"Files\" )","\t\tfunction buttonFiles:DoClick ()","\t\t\tif SF.Editor.fileViewer:IsVisible() then","\t\t\t\tSF.Editor.fileViewer:close()","\t\t\telse","\t\t\t\tSF.Editor.fileViewer:open()","\t\t\tend","\t\tend","\t\tbuttonHolder:addButton( \"Files\", buttonFiles )","","\t\tlocal buttonSaveAs = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSaveAs:SetText( \"Save As\" )","\t\tfunction buttonSaveAs:DoClick ()","\t\t\tSF.Editor.saveTabAs( SF.Editor.getActiveTab() )","\t\tend","\t\tbuttonHolder:addButton( \"SaveAs\", buttonSaveAs )","","\t\tlocal buttonSave = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSave:SetText( \"Save\" )","\t\tfunction buttonSave:DoClick ()","\t\t\tSF.Editor.saveTab( SF.Editor.getActiveTab() )","\t\tend","\t\tbuttonHolder:addButton( \"Save\", buttonSave )","","\t\tlocal buttonNewFile = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonNewFile:SetText( \"New tab\" )","\t\tfunction buttonNewFile:DoClick ()","\t\t\tSF.Editor.addTab()","\t\tend","\t\tbuttonHolder:addButton( \"NewFile\", buttonNewFile )","","\t\tlocal buttonCloseTab = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonCloseTab:SetText( \"Close tab\" )","\t\tfunction buttonCloseTab:DoClick ()","\t\t\tSF.Editor.removeTab( SF.Editor.getActiveTab() )","\t\tend","\t\tbuttonHolder:addButton( \"CloseTab\", buttonCloseTab )","","\t\tlocal html = vgui.Create( \"DHTML\", editor )","\t\thtml:Dock( FILL )","\t\thtml:DockMargin( 5, 59, 5, 5 )","\t\thtml:SetKeyboardInputEnabled( true )","\t\thtml:SetMouseInputEnabled( true )","\t\thtml:SetAllowLua( true )","\t\thtml:OpenURL( editorUrl )","\t\thtml:AddFunction( \"console\", \"copyCode\", function( code )","\t\t\tSF.Editor.getActiveTab().code = code","\t\t\tSF.Editor.doValidation()","\t\tend)","\t\t\t","\t\tlocal function FinishedLoadingEditor()","\t\t\tlocal map = createLibraryMap()","\t\t\thtml:QueueJavascript( \"libraryMap = JSON.parse(\\\"\" .. util.TableToJSON( map ):JavascriptSafe() .. \"\\\")\" )","","\t\t\tlocal libs = {}","\t\t\tlocal functions = {}","\t\t\ttable.ForEach( map, function ( lib, vals )","\t\t\t\tif lib == \"Environment\" or lib:GetChar( 1 ):upper() ~= lib:GetChar( 1 ) then","\t\t\t\t\ttable.insert( libs, lib )","\t\t\t\tend","\t\t\t\ttable.ForEach( vals, function ( key, val )","\t\t\t\t\ttable.insert( functions, val )","\t\t\t\tend )","\t\t\tend )","","\t\t\thtml:QueueJavascript( \"createStarfallMode(\\\"\" .. table.concat( libs, \"|\" ) .. \"\\\", \\\"\" .. table.concat( table.Add( table.Copy( functions ), libs ), \"|\" ) .. \"\\\")\" )","","\t\t\tfunction html:OnKeyCodePressed ( key, notfirst )","","\t\t\t\tlocal function repeatKey ()","\t\t\t\t\ttimer.Create( \"repeatKey\"..key, not notfirst and 0.5 or 0.02, 1, function () self:OnKeyCodePressed( key, true ) end )","\t\t\t\tend","","\t\t\t\tif GetConVarNumber( \"sf_editor_fixkeys\" ) == 0 then return end","\t\t\t\tif ( input.IsKeyDown( KEY_LSHIFT ) or input.IsKeyDown( KEY_RSHIFT ) ) and ","\t\t\t\t\t( input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) ) and","\t\t\t\t\tnot input.IsKeyDown( KEY_LALT ) then","\t\t\t\t\tif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.modifyNumber(1)\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.modifyNumber(-1)\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectWordLeft()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectWordRight()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\tend","\t\t\t\telseif input.IsKeyDown( KEY_LSHIFT ) or input.IsKeyDown( KEY_RSHIFT ) then","\t\t\t\t\tif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectLeft()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectRight()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectUp()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectDown()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_HOME and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectLineStart()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_END and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectLineEnd()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\tend","\t\t\t\telseif input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) and not input.IsKeyDown( KEY_LALT )  then","\t\t\t\t\tif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateWordLeft()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateWordRight()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_BACKSPACE and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.removeWordLeft()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_DELETE and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.removeWordRight()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_SPACE and input.IsKeyDown( key ) then","\t\t\t\t\t\tSF.Editor.doValidation( true )","\t\t\t\t\telseif key == KEY_C and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"console.log(\\\"RUNLUA:SetClipboardText(\\\\\\\"\\\"+ addslashes(editor.getSelectedText()) +\\\"\\\\\\\")\\\")\" )","\t\t\t\t\tend","\t\t\t\telseif input.IsKeyDown( KEY_LALT ) or input.IsKeyDown( KEY_RALT ) then","\t\t\t\t\tif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.moveLinesUp()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.moveLinesDown()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\tend","\t\t\t\telse","\t\t\t\t\tif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateLeft(1)\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateRight(1)\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateUp(1)\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateDown(1)\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_HOME and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateLineStart()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_END and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateLineEnd()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_PAGEUP and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateFileStart()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_PAGEDOWN and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.navigateFileEnd()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_BACKSPACE and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.remove('left')\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_DELETE and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.remove('right')\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_ENTER and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.splitLine(); editor.navigateDown(1); editor.navigateLineStart()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_INSERT and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.toggleOverwrite()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\telseif key == KEY_TAB and input.IsKeyDown( key ) then","\t\t\t\t\t\tself:QueueJavascript( \"editor.indent()\" )","\t\t\t\t\t\trepeatKey()","\t\t\t\t\tend","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\tSF.Editor.updateSettings( true )","","\t\t\tlocal tabs = util.JSONToTable( file.Read( \"sf_tabs.txt\" ) or \"\" )","\t\t\tif tabs ~= nil and #tabs ~= 0 then","\t\t\t\tfor k, v in pairs( tabs ) do","\t\t\t\t\tif type( v ) ~= \"number\" then","\t\t\t\t\t\tSF.Editor.addTab( v.filename, v.code )","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\tSF.Editor.selectTab( tabs.selectedTab or 1 )","\t\t\telse","\t\t\t\tSF.Editor.addTab()","\t\t\tend","\t\t\t","\t\t\tSF.Editor.initialized = true","\t\tend","\t\t","\t\tlocal readyTime","\t\thook.Add(\"Think\",\"SF_LoadingEditor\",function()","\t\t\tif not html:IsLoading() then","\t\t\t\tif not readyTime then readyTime = CurTime()+0.1 end","\t\t\t\tif CurTime() > readyTime then","\t\t\t\t\thook.Remove(\"Think\",\"SF_LoadingEditor\")","\t\t\t\t\tFinishedLoadingEditor()","\t\t\t\tend","\t\t\tend","\t\tend)","\t\t","\t\teditor:AddComponent( \"htmlPanel\", html )","","\t\tfunction editor:OnOpen ()","\t\t\thtml:Call( \"editor.focus()\" )","\t\t\thtml:RequestFocus()","\t\tend","","\t\tlocal tabHolder = vgui.Create( \"StarfallTabHolder\", editor )","\t\ttabHolder:SetPos( 5, 30 )","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"\", \"SPACER\" }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"Save\", function ()","\t\t\tif not tabHolder.targetTab then return end","\t\t\tSF.Editor.saveTab( tabHolder.targetTab )","\t\t\ttabHolder.targetTab = nil","\t\tend }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"Save As\", function ()","\t\t\tif not tabHolder.targetTab then return end","\t\t\tSF.Editor.saveTabAs( tabHolder.targetTab )","\t\t\ttabHolder.targetTab = nil","\t\tend }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"\", \"SPACER\" }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"Refresh\", function ()","\t\t\tif not tabHolder.targetTab then return end","\t\t\t","\t\t\tSF.Editor.refreshTab( tabHolder.targetTab )","","\t\t\ttabHolder.targetTab = nil","\t\tend }","","\t\tfunction tabHolder:OnRemoveTab ( tabIndex )","\t\t\tSF.Editor.runJS( \"removeEditSession(\"..tabIndex..\")\" )","","\t\t\tif #self.tabs == 0 then","\t\t\t\tSF.Editor.addTab()","\t\t\tend","\t\t\tSF.Editor.selectTab( tabIndex )","\t\tend","\t\teditor:AddComponent( \"tabHolder\", tabHolder )","\t\t","\t\tfunction editor:OnClose ()","\t\t\tlocal tabs = {}","\t\t\tfor k, v in pairs( tabHolder.tabs ) do","\t\t\t\ttabs[ k ] = {}","\t\t\t\ttabs[ k ].filename = v.filename","\t\t\t\ttabs[ k ].code = v.code","\t\t\tend","\t\t\ttabs.selectedTab = SF.Editor.getTabHolder():getTabIndex( SF.Editor.getActiveTab() )","\t\t\tfile.Write( \"sf_tabs.txt\", util.TableToJSON( tabs ) )","","\t\t\tSF.Editor.saveSettings()","","\t\t\tlocal activeWep = LocalPlayer():GetActiveWeapon()","\t\t\tif IsValid( activeWep ) and activeWep:GetClass() == \"gmod_tool\" and activeWep.Mode == \"starfall_processor\" then","\t\t\t\tlocal model = nil","\t\t\t\tlocal ppdata = {}","\t\t\t\tSF.Preprocessor.ParseDirectives( \"file\", SF.Editor.getCode(), {}, ppdata )","\t\t\t\tif ppdata.models and ppdata.models.file ~= \"\" then","\t\t\t\t\tmodel = ppdata.models.file ","\t\t\t\tend","","\t\t\t\tRunConsoleCommand(\"starfall_processor_ScriptModel\", model or \"\")","\t\t\tend ","\t\tend","","\t\treturn editor","\tend","","\tfunction SF.Editor.createFileViewer ()","\t\tlocal fileViewer = vgui.Create( \"StarfallFrame\" )","\t\tfileViewer:SetSize( 200, 600 )","\t\tfileViewer:SetTitle( \"Starfall File Viewer\" )","\t\tfileViewer:Center()","","\t\tlocal browser = vgui.Create( \"StarfallFileBrowser\", fileViewer )","","\t\tlocal searchBox, tree = browser:getComponents()","\t\ttree:setup( \"starfall\" )","\t\tfunction tree:OnNodeSelected ( node )","\t\t\tif not node:GetFileName() or string.GetExtensionFromFilename( node:GetFileName() ) ~= \"txt\" then return end","\t\t\tlocal fileName = string.gsub( node:GetFileName(), \"starfall/\", \"\", 1 )","\t\t\tlocal code = file.Read( node:GetFileName(), \"DATA\" )","","\t\t\tfor k, v in pairs( SF.Editor.getTabHolder().tabs ) do","\t\t\t\tif v.filename == fileName and v.code == code then","\t\t\t\t\tSF.Editor.selectTab( v )","\t\t\t\t\treturn","\t\t\t\tend","\t\t\tend","","\t\t\tSF.Editor.addTab( fileName, code )","\t\tend","","\t\tfileViewer:AddComponent( \"browser\", browser )","","\t\tlocal buttonHolder = fileViewer.components[ \"buttonHolder\" ]","","\t\tlocal buttonLock = buttonHolder:getButton( \"Lock\" )","\t\tbuttonLock._DoClick = buttonLock.DoClick","\t\tbuttonLock.DoClick = function ( self )","\t\t\tself:_DoClick()","\t\t\tSF.Editor.saveSettings()","\t\tend","","\t\tlocal buttonRefresh = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonRefresh:SetText( \"Refresh\" )","\t\tbuttonRefresh:SetHoverColor( Color( 7, 70, 0 ) )","\t\tbuttonRefresh:SetColor( Color( 26, 104, 17 ) )","\t\tbuttonRefresh:SetLabelColor( Color( 103, 155, 153 ) )","\t\tfunction buttonRefresh:DoClick ()","\t\t\ttree:reloadTree()","\t\t\tsearchBox:SetValue( \"Search...\" )","\t\tend","\t\tbuttonHolder:addButton( \"Refresh\", buttonRefresh )","","\t\tfunction fileViewer:OnOpen ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Files\" ).active = true","\t\tend","","\t\tfunction fileViewer:OnClose ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Files\" ).active = false","\t\t\tSF.Editor.saveSettings()","\t\tend","","\t\treturn fileViewer","\tend","","\tfunction SF.Editor.createSettingsWindow ()","\t\tlocal frame = vgui.Create( \"StarfallFrame\" )","\t\tframe:SetSize( 200, 400 )","\t\tframe:SetTitle( \"Starfall Settings\" )","\t\tframe:Center()","","\t\tlocal panel = vgui.Create( \"StarfallPanel\", frame )","\t\tpanel:Dock( FILL )","\t\tpanel:DockMargin( 0, 5, 0, 0 )","\t\tframe:AddComponent( \"panel\", panel )","","\t\tlocal scrollPanel = vgui.Create( \"DScrollPanel\", panel )","\t\tscrollPanel:Dock( FILL )","\t\tscrollPanel:SetPaintBackgroundEnabled( false )","","\t\tlocal form = vgui.Create( \"DForm\", scrollPanel )\t","\t\tform:Dock( FILL )","\t\tform:DockPadding( 0, 10, 0, 10 )","\t\tform.Header:SetVisible( false )","\t\tform.Paint = function () end","","\t\tlocal function setDoClick ( panel )","\t\t\tfunction panel:OnChange ()","\t\t\t\tSF.Editor.saveSettings()","\t\t\t\ttimer.Simple( 0.1, function () SF.Editor.updateSettings( true ) end )","\t\t\tend","","\t\t\treturn panel","\t\tend","\t\tlocal function setWang( wang, label )","\t\t\tfunction wang:OnValueChanged()","\t\t\t\tSF.Editor.saveSettings()","\t\t\t\ttimer.Simple( 0.1, function () SF.Editor.updateSettings( true ) end )","\t\t\tend","\t\t\twang:GetParent():DockPadding( 10, 1, 10, 1 )","\t\t\twang:Dock( RIGHT )","","\t\t\treturn wang, label","\t\tend","\t\t","\t\tsetWang( form:NumberWang( \"Font size\", \"sf_editor_fontsize\", 5, 40 ) )","\t\tlocal combobox, label = form:ComboBox( \"Keybinding\", \"sf_editor_keybindings\" )","\t\tcombobox:AddChoice( \"ace\" )","\t\tcombobox:AddChoice( \"vim\" )","\t\tcombobox:AddChoice( \"emacs\" )","\t\t","\t\tsetDoClick( form:CheckBox( \"Enable word wrap\", \"sf_editor_wordwrap\" ) )","\t\tsetDoClick( form:CheckBox( \"Show fold widgets\", \"sf_editor_widgets\" ) )","\t\tsetDoClick( form:CheckBox( \"Show line numbers\", \"sf_editor_linenumbers\" ) )","\t\tsetDoClick( form:CheckBox( \"Show gutter\", \"sf_editor_gutter\" ) )","\t\tsetDoClick( form:CheckBox( \"Show invisible characters\", \"sf_editor_invisiblecharacters\" ) )","\t\tsetDoClick( form:CheckBox( \"Show indenting guides\", \"sf_editor_indentguides\" ) )","\t\tsetDoClick( form:CheckBox( \"Highlight active line\", \"sf_editor_activeline\" ) )","\t\tsetDoClick( form:CheckBox( \"Auto completion\", \"sf_editor_autocompletion\" ) )","\t\tsetDoClick( form:CheckBox( \"Live Auto completion\", \"sf_editor_liveautocompletion\" ) )","\t\tsetDoClick( form:CheckBox( \"Fix keys not working on Linux\", \"sf_editor_fixkeys\" ) ):SetTooltip( \"Some keys don't work with the editor on Linux\\nEg. Enter, Tab, Backspace, Arrow keys etc...\" )","\t\tsetDoClick( form:CheckBox( \"Fix console bug\", \"sf_editor_fixconsolebug\" ) ):SetTooltip( \"Fix console opening when pressing ' or @ (UK Keyboad layout)\" )","\t\tsetDoClick( form:CheckBox( \"Disable line folding keybinds\", \"sf_editor_disablelinefolding\" ) )","","\t\tfunction frame:OnOpen ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Settings\" ).active = true","\t\tend","","\t\tfunction frame:OnClose ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Settings\" ).active = false","\t\tend","","\t\treturn frame","\tend","","\tfunction SF.Editor.createModelViewer ()","\t\tlocal frame = vgui.Create( \"StarfallFrame\" )","\t\tframe:SetTitle( \"Model Viewer - Click an icon to insert model filename into editor\" )","\t\tframe:SetVisible( false )","\t\tframe:Center()","","\t\tfunction frame:OnOpen ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Model Viewer\" ).active = true","\t\tend","","\t\tfunction frame:OnClose ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Model Viewer\" ).active = false","\t\t\tSF.Editor.saveSettings()","\t\tend","","\t\tlocal sidebarPanel = vgui.Create( \"StarfallPanel\", frame )","\t\tsidebarPanel:Dock( LEFT )","\t\tsidebarPanel:SetSize( 190, 10 )","\t\tsidebarPanel:DockMargin( 0, 0, 4, 0 )","\t\tsidebarPanel.Paint = function () end","","\t\tframe.ContentNavBar = vgui.Create( \"ContentSidebar\", sidebarPanel )","\t\tframe.ContentNavBar:Dock( FILL )","\t\tframe.ContentNavBar:DockMargin( 0, 0, 0, 0 )","\t\tframe.ContentNavBar.Tree:SetBackgroundColor( Color( 240, 240, 240 ) )","\t\tframe.ContentNavBar.Tree.OnNodeSelected = function ( self, node ) ","\t\t\tif not IsValid( node.propPanel ) then return end","","\t\t\tif IsValid( frame.PropPanel.selected ) then","\t\t\t\tframe.PropPanel.selected:SetVisible( false )","\t\t\t\tframe.PropPanel.selected = nil","\t\t\tend","","\t\t\tframe.PropPanel.selected = node.propPanel","","\t\t\tframe.PropPanel.selected:Dock( FILL )","\t\t\tframe.PropPanel.selected:SetVisible( true )","\t\t\tframe.PropPanel:InvalidateParent()","\t\t\t","\t\t\tframe.HorizontalDivider:SetRight( frame.PropPanel.selected )","\t\tend","","\t\tframe.PropPanel = vgui.Create( \"StarfallPanel\", frame )","\t\tframe.PropPanel:Dock( FILL )","\t\tfunction frame.PropPanel:Paint ( w, h )","\t\t\tdraw.RoundedBox( 0, 0, 0, w, h, Color( 240, 240, 240 ) )","\t\tend","","\t\tframe.HorizontalDivider = vgui.Create( \"DHorizontalDivider\", frame )","\t\tframe.HorizontalDivider:Dock( FILL )","\t\tframe.HorizontalDivider:SetLeftWidth( 175 )","\t\tframe.HorizontalDivider:SetLeftMin( 175 )","\t\tframe.HorizontalDivider:SetRightMin( 450 )","\t\t","\t\tframe.HorizontalDivider:SetLeft( sidebarPanel )","\t\tframe.HorizontalDivider:SetRight( frame.PropPanel )","","\t\tlocal root = frame.ContentNavBar.Tree:AddNode( \"Your Spawnlists\" )","\t\troot:SetExpanded( true )","\t\troot.info = {}","\t\troot.info.id = 0","","\t\tlocal function hasGame ( name )","\t\t\tfor k, v in pairs( engine.GetGames() ) do","\t\t\t\tif v.folder == name and v.mounted then","\t\t\t\t\treturn true","\t\t\t\tend","\t\t\tend","\t\t\treturn false","\t\tend","","\t\tlocal function addModel ( container, obj )","","\t\t\tlocal icon = vgui.Create( \"SpawnIcon\", container )","\t\t\t","\t\t\tif ( obj.body ) then","\t\t\t\tobj.body = string.Trim( tostring(obj.body), \"B\" )","\t\t\tend","\t\t\t","\t\t\tif ( obj.wide ) then","\t\t\t\ticon:SetWide( obj.wide )","\t\t\tend","\t\t\t","\t\t\tif ( obj.tall ) then","\t\t\t\ticon:SetTall( obj.tall )","\t\t\tend","\t\t\t","\t\t\ticon:InvalidateLayout( true )","\t\t\t","\t\t\ticon:SetModel( obj.model, obj.skin or 0, obj.body )","\t\t\t","\t\t\ticon:SetTooltip( string.Replace( string.GetFileFromFilename( obj.model ), \".mdl\", \"\" ) )","","\t\t\ticon.DoClick = function ( icon ) ","\t\t\t\tSF.Editor.runJS( \"editor.insert(\\\"\" .. string.gsub( obj.model, \"\\\\\", \"/\" ):JavascriptSafe() .. \"\\\")\" ) ","\t\t\t\tSF.AddNotify( LocalPlayer(), \"\\\"\" .. string.gsub( obj.model, \"\\\\\", \"/\" ) .. \"\\\" inserted into editor.\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP1 )","\t\t\t\tframe:close()","\t\t\tend","\t\t\ticon.OpenMenu = function ( icon )","","\t\t\t\tlocal menu = DermaMenu()","\t\t\t\tlocal submenu = menu:AddSubMenu( \"Re-Render\", function () icon:RebuildSpawnIcon() end )","\t\t\t\t\tsubmenu:AddOption( \"This Icon\", function () icon:RebuildSpawnIcon() end )","\t\t\t\t\tsubmenu:AddOption( \"All Icons\", function () container:RebuildAll() end )","\t\t\t","\t\t\t\tlocal ChangeIconSize = function ( w, h )","\t\t\t\t\t","\t\t\t\t\ticon:SetSize( w, h )","\t\t\t\t\ticon:InvalidateLayout( true )","\t\t\t\t\tcontainer:OnModified()","\t\t\t\t\tcontainer:Layout()","\t\t\t\t\ticon:SetModel( obj.model, obj.skin or 0, obj.body )","\t\t\t\t","\t\t\t\tend","","\t\t\t\tlocal submenu = menu:AddSubMenu( \"Resize\", function () end )","\t\t\t\t\tsubmenu:AddOption( \"64 x 64 (default)\", function () ChangeIconSize( 64, 64 ) end )","\t\t\t\t\tsubmenu:AddOption( \"64 x 128\", function () ChangeIconSize( 64, 128 ) end )","\t\t\t\t\tsubmenu:AddOption( \"64 x 256\", function () ChangeIconSize( 64, 256 ) end )","\t\t\t\t\tsubmenu:AddOption( \"64 x 512\", function () ChangeIconSize( 64, 512 ) end )","\t\t\t\t\tsubmenu:AddSpacer()","\t\t\t\t\tsubmenu:AddOption( \"128 x 64\", function () ChangeIconSize( 128, 64 ) end )","\t\t\t\t\tsubmenu:AddOption( \"128 x 128\", function () ChangeIconSize( 128, 128 ) end )","\t\t\t\t\tsubmenu:AddOption( \"128 x 256\", function () ChangeIconSize( 128, 256 ) end )","\t\t\t\t\tsubmenu:AddOption( \"128 x 512\", function () ChangeIconSize( 128, 512 ) end )","\t\t\t\t\tsubmenu:AddSpacer()","\t\t\t\t\tsubmenu:AddOption( \"256 x 64\", function () ChangeIconSize( 256, 64 ) end )","\t\t\t\t\tsubmenu:AddOption( \"256 x 128\", function () ChangeIconSize( 256, 128 ) end )","\t\t\t\t\tsubmenu:AddOption( \"256 x 256\", function () ChangeIconSize( 256, 256 ) end )","\t\t\t\t\tsubmenu:AddOption( \"256 x 512\", function () ChangeIconSize( 256, 512 ) end )","\t\t\t\t\tsubmenu:AddSpacer()","\t\t\t\t\tsubmenu:AddOption( \"512 x 64\", function () ChangeIconSize( 512, 64 ) end )","\t\t\t\t\tsubmenu:AddOption( \"512 x 128\", function () ChangeIconSize( 512, 128 ) end )","\t\t\t\t\tsubmenu:AddOption( \"512 x 256\", function () ChangeIconSize( 512, 256 ) end )","\t\t\t\t\tsubmenu:AddOption( \"512 x 512\", function () ChangeIconSize( 512, 512 ) end )","","\t\t\t\tmenu:AddSpacer()","\t\t\t\tmenu:AddOption( \"Delete\", function () icon:Remove() end )","\t\t\t\tmenu:Open()","\t\t\t\t","\t\t\tend","","\t\t\ticon:InvalidateLayout( true )","\t\t\t","\t\t\tif ( IsValid( container ) ) then","\t\t\t\tcontainer:Add( icon )","\t\t\tend","","\t\t\treturn icon","","\t\tend","","\t\tlocal function addBrowseContent ( viewPanel, node, name, icon, path, pathid )","\t\t\tlocal models = node:AddFolder( name, path .. \"models\", pathid, false )","\t\t\tmodels:SetIcon( icon )","","\t\t\tmodels.OnNodeSelected = function ( self, node )","","\t\t\t\tif viewPanel and viewPanel.currentNode and viewPanel.currentNode == node then return end","","\t\t\t\tviewPanel:Clear( true )","\t\t\t\tviewPanel.currentNode = node","\t\t\t\t","\t\t\t\tlocal path = node:GetFolder()","\t\t\t\tlocal searchString = path .. \"/*.mdl\"","","\t\t\t\tlocal Models = file.Find( searchString, node:GetPathID() )","\t\t\t\tfor k, v in pairs( Models ) do","\t\t\t\t\tif not IsUselessModel( v ) then","\t\t\t\t\t\taddModel( viewPanel, { model = path .. \"/\" .. v } )","\t\t\t\t\tend","\t\t\t\tend","","\t\t\t\tnode.propPanel = viewPanel","\t\t\t\tframe.ContentNavBar.Tree:OnNodeSelected( node )","","\t\t\t\tviewPanel.currentNode = node","","\t\t\tend","\t\tend","","\t\tlocal function addAddonContent ( panel, folder, path )","\t\t\tlocal files, folders = file.Find( folder .. \"*\", path )","","\t\t\tfor k, v in pairs( files ) do","\t\t\t\tif string.EndsWith( v, \".mdl\" ) then","\t\t\t\t\taddModel( panel, { model = folder .. v } )","\t\t\t\tend","\t\t\tend","","\t\t\tfor k, v in pairs( folders ) do","\t\t\t\taddAddonContent( panel, folder .. v .. \"/\", path )","\t\t\tend","\t\tend","","\t\tlocal function fillNavBar ( propTable, parentNode )","\t\t\tfor k, v in SortedPairs( propTable ) do","\t\t\t\tif v.parentid == parentNode.info.id and ( v.needsapp ~= \"\" and hasGame( v.needsapp ) or v.needsapp == \"\" ) then","\t\t\t\t\tlocal node = parentNode:AddNode( v.name, v.icon )","\t\t\t\t\tnode:SetExpanded( true )","\t\t\t\t\tnode.info = v","","\t\t\t\t\tnode.propPanel = vgui.Create( \"ContentContainer\", frame.PropPanel )","\t\t\t\t\tnode.propPanel:DockMargin( 5, 0, 0, 0 )","\t\t\t\t\tnode.propPanel:SetVisible( false )","","\t\t\t\t\tfor i, object in SortedPairs( node.info.contents ) do","\t\t\t\t\t\tif object.type == \"model\" then","\t\t\t\t\t\t\taddModel( node.propPanel, object )","\t\t\t\t\t\telseif object.type == \"header\" then","\t\t\t\t\t\t\tif not object.text or type( object.text ) ~= \"string\" then return end","","\t\t\t\t\t\t\tlocal label = vgui.Create( \"ContentHeader\", node.propPanel )","\t\t\t\t\t\t\tlabel:SetText( object.text )","\t\t\t\t\t\t\t","\t\t\t\t\t\t\tnode.propPanel:Add( label )","\t\t\t\t\t\tend","\t\t\t\t\tend","","\t\t\t\t\tfillNavBar( propTable, node )","\t\t\t\tend","\t\t\tend","\t\tend","","\t\tif table.Count( spawnmenu.GetPropTable() ) == 0 then","\t\t\thook.Call( \"PopulatePropMenu\", GAMEMODE )","\t\tend","","\t\tfillNavBar( spawnmenu.GetPropTable(), root )","\t\tframe.OldSpawnlists = frame.ContentNavBar.Tree:AddNode( \"#spawnmenu.category.browse\", \"icon16/cog.png\" )","\t\tframe.OldSpawnlists:SetExpanded( true )","","\t\t-- Games","\t\tlocal gamesNode = frame.OldSpawnlists:AddNode( \"#spawnmenu.category.games\", \"icon16/folder_database.png\" )","","\t\tlocal viewPanel = vgui.Create( \"ContentContainer\", frame.PropPanel )","\t\tviewPanel:DockMargin( 5, 0, 0, 0 )","\t\tviewPanel:SetVisible( false )","","\t\tlocal games = engine.GetGames()","\t\ttable.insert( games, {","\t\t\ttitle = \"All\",","\t\t\tfolder = \"GAME\",","\t\t\ticon = \"all\",","\t\t\tmounted = true","\t\t} )","\t\ttable.insert( games, {","\t\t\ttitle = \"Garry's Mod\",","\t\t\tfolder = \"garrysmod\",","\t\t\tmounted = true","\t\t} )","\t\t","\t\tfor _, game in SortedPairsByMemberValue( games, \"title\" ) do","\t\t\t","\t\t\tif game.mounted then","\t\t\t\taddBrowseContent( viewPanel, gamesNode, game.title, \"games/16/\" .. ( game.icon or game.folder ) .. \".png\", \"\", game.folder )","\t\t\tend","\t\tend","","\t\t-- Addons","\t\tlocal addonsNode = frame.OldSpawnlists:AddNode( \"#spawnmenu.category.addons\", \"icon16/folder_database.png\" )","","\t\tlocal viewPanel = vgui.Create( \"ContentContainer\", frame.PropPanel )","\t\tviewPanel:DockMargin( 5, 0, 0, 0 )","\t\tviewPanel:SetVisible( false )","","\t\tfunction addonsNode:OnNodeSelected ( node )","\t\t\tif node == addonsNode then return end","\t\t\tviewPanel:Clear( true )","\t\t\taddAddonContent( viewPanel, \"models/\", node.addon.title )","\t\t\tnode.propPanel = viewPanel","\t\t\tframe.ContentNavBar.Tree:OnNodeSelected( node )","\t\tend","\t\tfor _, addon in SortedPairsByMemberValue( engine.GetAddons(), \"title\" ) do","\t\t\tif addon.downloaded and addon.mounted and addon.models > 0 then","\t\t\t\tlocal node = addonsNode:AddNode( addon.title .. \" (\"..addon.models..\")\", \"icon16/bricks.png\" )","\t\t\t\tnode.addon = addon","\t\t\tend","\t\tend","","\t\t-- Search box","\t\tlocal viewPanel = vgui.Create( \"ContentContainer\", frame.PropPanel )","\t\tviewPanel:DockMargin( 5, 0, 0, 0 )","\t\tviewPanel:SetVisible( false )","","\t\tframe.searchBox = vgui.Create( \"DTextEntry\", sidebarPanel )","\t\tframe.searchBox:Dock( TOP )","\t\tframe.searchBox:SetValue( \"Search...\" )","\t\tframe.searchBox:SetTooltip( \"Press enter to search\" )","\t\tframe.searchBox.propPanel = viewPanel","","\t\tframe.searchBox._OnGetFocus = frame.searchBox.OnGetFocus","\t\tfunction frame.searchBox:OnGetFocus ()","\t\t\tif self:GetValue() == \"Search...\" then","\t\t\t\tself:SetValue( \"\" )","\t\t\tend","\t\t\tframe.searchBox:_OnGetFocus()","\t\tend","","\t\tframe.searchBox._OnLoseFocus = frame.searchBox.OnLoseFocus","\t\tfunction frame.searchBox:OnLoseFocus ()","\t\t\tif self:GetValue() == \"\" then","\t\t\t\tself:SetText( \"Search...\" )","\t\t\tend","\t\t\tframe.searchBox:_OnLoseFocus()","\t\tend","","\t\tfunction frame.searchBox:updateHeader ()","\t\t\tself.header:SetText( frame.searchBox.results .. \" Results for \\\"\" .. self.search .. \"\\\"\" )","\t\tend","","\t\tlocal searchTime = nil","","\t\tfunction frame.searchBox:getAllModels ( time, folder, extension, path )","\t\t\tif searchTime and time ~= searchTime then return end","\t\t\tif self.results and self.results >= 256 then return end","\t\t\tself.load = self.load + 1","\t\t\tlocal files, folders = file.Find( folder .. \"/*\", path )","","\t\t\tfor k, v in pairs( files ) do","\t\t\t\tlocal file = folder .. v","\t\t\t\tif v:EndsWith( extension ) and file:find( self.search:PatternSafe() ) and not IsUselessModel( file ) then","\t\t\t\t\taddModel( self.propPanel, { model = file } )","\t\t\t\t\tself.results = self.results + 1","\t\t\t\t\tself:updateHeader()","\t\t\t\tend","\t\t\t\tif self.results >= 256 then break end","\t\t\tend","","\t\t\tfor k, v in pairs( folders ) do","\t\t\t\ttimer.Simple( k * 0.02, function()","\t\t\t\t\tif searchTime and time ~= searchTime then return end","\t\t\t\t\tif self.results >= 256 then return end","\t\t\t\t\tself:getAllModels( time, folder .. v .. \"/\", extension, path )","\t\t\t\tend )","\t\t\tend","\t\t\ttimer.Simple( 1, function () ","\t\t\t\tif searchTime and time ~= searchTime then return end","\t\t\t\tself.load = self.load - 1 ","\t\t\tend )","\t\tend","","\t\tfunction frame.searchBox:OnEnter ()","\t\t\tif self:GetValue() == \"\" then return end","","\t\t\tself.propPanel:Clear()","","\t\t\tself.results = 0","\t\t\tself.load = 1","\t\t\tself.search = self:GetText()","","\t\t\tself.header = vgui.Create( \"ContentHeader\", self.propPanel )","\t\t\tself.loading = vgui.Create( \"ContentHeader\", self.propPanel )","\t\t\tself:updateHeader()","\t\t\tself.propPanel:Add( self.header )","\t\t\tself.propPanel:Add( self.loading )","","\t\t\tsearchTime = CurTime()","\t\t\tself:getAllModels( searchTime, \"models/\", \".mdl\", \"GAME\" )","\t\t\tself.load = self.load - 1","","\t\t\tframe.ContentNavBar.Tree:OnNodeSelected( self )","\t\tend","\t\thook.Add( \"Think\", \"sf_header_update\", function ()","\t\t\tif frame.searchBox.loading and frame.searchBox.propPanel:IsVisible() then","\t\t\t\tframe.searchBox.loading:SetText( \"Loading\" .. string.rep( \".\", math.floor( CurTime() ) % 4 ) )","\t\t\tend","\t\t\tif frame.searchBox.load and frame.searchBox.load <= 0 then","\t\t\t\tframe.searchBox.loading:Remove()","\t\t\t\tframe.searchBox.loading = nil","\t\t\t\tframe.searchBox.load = nil","\t\t\tend","\t\tend )","","\t\treturn frame","\tend","","\tfunction SF.Editor.saveSettings ()","\t\tlocal frame = SF.Editor.editor","\t\tRunConsoleCommand( \"sf_editor_width\", frame:GetWide() )","\t\tRunConsoleCommand( \"sf_editor_height\", frame:GetTall() )","\t\tlocal x, y = frame:GetPos()","\t\tRunConsoleCommand( \"sf_editor_posx\", x )","\t\tRunConsoleCommand( \"sf_editor_posy\", y )","","\t\tlocal frame = SF.Editor.fileViewer","\t\tRunConsoleCommand( \"sf_fileviewer_width\", frame:GetWide() )","\t\tRunConsoleCommand( \"sf_fileviewer_height\", frame:GetTall() )","\t\tlocal x, y = frame:GetPos()","\t\tRunConsoleCommand( \"sf_fileviewer_posx\", x )","\t\tRunConsoleCommand( \"sf_fileviewer_posy\", y )","\t\tRunConsoleCommand( \"sf_fileviewer_locked\", frame.locked and 1 or 0 )","","\t\tlocal frame = SF.Editor.modelViewer","\t\tRunConsoleCommand( \"sf_modelviewer_width\", frame:GetWide() )","\t\tRunConsoleCommand( \"sf_modelviewer_height\", frame:GetTall() )","\t\tlocal x, y = frame:GetPos()","\t\tRunConsoleCommand( \"sf_modelviewer_posx\", x )","\t\tRunConsoleCommand( \"sf_modelviewer_posy\", y )","\tend","","\tfunction SF.Editor.updateSettings ( ace )","\t\tlocal frame = SF.Editor.editor","\t\tframe:SetWide( GetConVarNumber( \"sf_editor_width\" ) )","\t\tframe:SetTall( GetConVarNumber( \"sf_editor_height\" ) )","\t\tframe:SetPos( GetConVarNumber( \"sf_editor_posx\" ), GetConVarNumber( \"sf_editor_posy\" ) )","","\t\tlocal frame = SF.Editor.fileViewer","\t\tframe:SetWide( GetConVarNumber( \"sf_fileviewer_width\" ) )","\t\tframe:SetTall( GetConVarNumber( \"sf_fileviewer_height\" ) )","\t\tframe:SetPos( GetConVarNumber( \"sf_fileviewer_posx\" ), GetConVarNumber( \"sf_fileviewer_posy\" ) )","\t\tframe:lock( SF.Editor.editor )","\t\tframe.locked = tobool(GetConVarNumber( \"sf_fileviewer_locked\" ))","","\t\tlocal buttonLock = frame.components[ \"buttonHolder\" ]:getButton( \"Lock\" )","\t\tbuttonLock.active = frame.locked","\t\tbuttonLock:SetText( frame.locked and \"Locked\" or \"Unlocked\" )","","\t\tlocal frame = SF.Editor.modelViewer","\t\tframe:SetWide( GetConVarNumber( \"sf_modelviewer_width\" ) )","\t\tframe:SetTall( GetConVarNumber( \"sf_modelviewer_height\" ) )","\t\tframe:SetPos( GetConVarNumber( \"sf_modelviewer_posx\" ), GetConVarNumber( \"sf_modelviewer_posy\" ) )","","\t\tif ace then","\t\t\tlocal js = SF.Editor.runJS","\t\t\tjs( [[","\t\t\t\teditSessions.forEach( function( session ) {","\t\t\t\t\tsession.setUseWrapMode( ]] .. GetConVarNumber( \"sf_editor_wordwrap\" ) .. [[ )","\t\t\t\t} )","\t\t\t]] )","\t\t\tjs( \"editor.setOption(\\\"showFoldWidgets\\\", \" .. GetConVarNumber( \"sf_editor_widgets\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"showLineNumbers\\\", \" .. GetConVarNumber( \"sf_editor_linenumbers\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"showGutter\\\", \" .. GetConVarNumber( \"sf_editor_gutter\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"showInvisibles\\\", \" .. GetConVarNumber( \"sf_editor_invisiblecharacters\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"displayIndentGuides\\\", \" .. GetConVarNumber( \"sf_editor_indentguides\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"highlightActiveLine\\\", \" .. GetConVarNumber( \"sf_editor_activeline\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"highlightGutterLine\\\", \" .. GetConVarNumber( \"sf_editor_activeline\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"enableLiveAutocompletion\\\", \" .. GetConVarNumber( \"sf_editor_liveautocompletion\" ) .. \");\" )","\t\t\tjs( \"editor.setOption(\\\"enableBasicAutocompletion\\\", \" .. GetConVarNumber( \"sf_editor_autocompletion\" ) .. \");\" )","\t\t\tjs( \"setFoldKeybinds( \" .. GetConVarNumber( \"sf_editor_disablelinefolding\" ) .. \");\" )","\t\t\tjs( \"editor.setKeyboardHandler(\\\"ace/keyboard/\" .. GetConVarString( \"sf_editor_keybindings\") .. \"\\\");\" )","\t\t\tjs( \"editor.setFontSize(\" .. GetConVarNumber( \"sf_editor_fontsize\" ) .. \");\" )","\t\tend","\tend",""],"summary":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n ","description":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n","param":[]},{"ret":["True if ok, false if a file was missing","A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"comment":["\t--- (Client) Builds a table for the compiler to use","\t-- @param maincode The source code for the main chunk","\t-- @param codename The name of the main chunk","\t-- @return True if ok, false if a file was missing","\t-- @return A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"code":["\tfunction SF.Editor.BuildIncludesTable ( maincode, codename )","\t\tif not SF.Editor.initialized then SF.Editor.init() return false, \"Loading Editor\" end","\t\tlocal tbl = {}","\t\tmaincode = maincode or SF.Editor.getCode()","\t\tcodename = codename or SF.Editor.getOpenFile() or \"main\"","\t\ttbl.mainfile = codename","\t\ttbl.files = {}","\t\ttbl.filecount = 0","\t\ttbl.includes = {}","","\t\tlocal loaded = {}","\t\tlocal ppdata = {}","","\t\tlocal function recursiveLoad ( path )","\t\t\tif loaded[ path ] then return end","\t\t\tloaded[ path ] = true","\t\t\t","\t\t\tlocal code","\t\t\tif path == codename and maincode then","\t\t\t\tcode = maincode","\t\t\telse","\t\t\t\tcode = file.Read( \"starfall/\"..path, \"DATA\" )","\t\t\tend","\t\t\tif not code then","\t\t\t\tprint( \"Bad include: \" .. path )","\t\t\t\treturn","\t\t\tend","\t\t\t","\t\t\ttbl.files[ path ] = code","\t\t\tSF.Preprocessor.ParseDirectives( path, code, {}, ppdata )","\t\t\t","\t\t\tif ppdata.includes and ppdata.includes[ path ] then","\t\t\t\tlocal inc = ppdata.includes[ path ]","\t\t\t\tif not tbl.includes[ path ] then","\t\t\t\t\ttbl.includes[ path ] = inc","\t\t\t\t\ttbl.filecount = tbl.filecount + 1","\t\t\t\telse","\t\t\t\t\tassert( tbl.includes[ path ] == inc )","\t\t\t\tend","\t\t\t\t","\t\t\t\tfor i = 1, #inc do","\t\t\t\t\trecursiveLoad( inc[i] )","\t\t\t\tend","\t\t\tend","\t\tend","\t\tlocal ok, msg = pcall( recursiveLoad, codename )","","\t\tlocal function findCycle ( file, visited, recStack )","\t\t\tif not visited[ file ] then","\t\t\t\t--Mark the current file as visited and part of recursion stack","\t\t\t\tvisited[ file ] = true","\t\t\t\trecStack[ file ] = true","","\t\t\t\t--Recurse for all the files included in this file","\t\t\t\tfor k, v in pairs( ppdata.includes[ file ] or {} ) do","\t\t\t\t\tif recStack[ v ] then","\t\t\t\t\t\treturn true, file","\t\t\t\t\telseif not visited[ v ] then","\t\t\t\t\t\tlocal cyclic, cyclicFile = findCycle( v, visited, recStack )","\t\t\t\t\t\tif cyclic then return true, cyclicFile end","\t\t\t\t\tend","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\t--Remove this file from the recursion stack","\t\t\trecStack[ file ] = false","\t\t\treturn false, nil","\t\tend","","\t\tlocal isCyclic = false","\t\tlocal cyclicFile = nil","\t\tfor k, v in pairs( ppdata.includes or {} ) do","\t\t\tlocal cyclic, file = findCycle( k, {}, {} )","\t\t\tif cyclic then","\t\t\t\tisCyclic = true","\t\t\t\tcyclicFile = file","\t\t\t\tbreak","\t\t\tend","\t\tend","\t\t","\t\tif isCyclic then","\t\t\treturn false, \"Loop in includes from: \" .. cyclicFile","\t\tend","","\t\tif ok then","\t\t\treturn true, tbl","\t\telseif msg:sub( 1, 13 ) == \"Bad include: \" then","\t\t\treturn false, msg","\t\telse","\t\t\terror( msg, 0 )","\t\tend","\tend","","\t-- CLIENT ANIMATION","","\tlocal busy_players = { }","\thook.Add( \"EntityRemoved\", \"starfall_busy_animation\", function ( ply )","\t\tbusy_players[ ply ] = nil","\tend )","","\tlocal emitter = ParticleEmitter( vector_origin )","","\tnet.Receive( \"starfall_editor_status\", function ( len )","\t\tlocal ply = net.ReadEntity()","\t\tlocal status = net.ReadBit() ~= 0 -- net.ReadBit returns 0 or 1, despite net.WriteBit taking a boolean","\t\tif not ply:IsValid() or ply == LocalPlayer() then return end","","\t\tbusy_players[ ply ] = status or nil","\tend )","","\tlocal rolldelta = math.rad( 80 )","\ttimer.Create( \"starfall_editor_status\", 1 / 3, 0, function ()","\t\trolldelta = -rolldelta","\t\tfor ply, _ in pairs( busy_players ) do","\t\t\tlocal BoneIndx = ply:LookupBone( \"ValveBiped.Bip01_Head1\" ) or ply:LookupBone( \"ValveBiped.HC_Head_Bone\" ) or 0","\t\t\tlocal BonePos, BoneAng = ply:GetBonePosition( BoneIndx )","\t\t\tlocal particle = emitter:Add( \"radon/starfall2\", BonePos + Vector( math.random( -10, 10 ), math.random( -10, 10 ), 60 + math.random( 0, 10 ) ) )","\t\t\tif particle then","\t\t\t\tparticle:SetColor( math.random( 30, 50 ), math.random( 40, 150 ), math.random( 180, 220 ) )","\t\t\t\tparticle:SetVelocity( Vector( 0, 0, -40 ) )","","\t\t\t\tparticle:SetDieTime( 1.5 )","\t\t\t\tparticle:SetLifeTime( 0 )","","\t\t\t\tparticle:SetStartSize( 10 )","\t\t\t\tparticle:SetEndSize( 5 )","","\t\t\t\tparticle:SetStartAlpha( 255 )","\t\t\t\tparticle:SetEndAlpha( 0 )","","\t\t\t\tparticle:SetRollDelta( rolldelta )","\t\t\tend","\t\tend","\tend )","","elseif SERVER then","","\tutil.AddNetworkString( \"starfall_editor_status\" )","","\tlocal function getFiles ( dir, dir2 )","\t\tlocal files = {}","\t\tlocal dir2 = dir2 or \"\"","\t\tlocal f, directories = file.Find( dir .. \"/\" .. dir2 .. \"/*\", \"GAME\" )","\t\tfor k, v in pairs( f ) do","\t\t\tfiles[ #files + 1 ] = dir2 .. \"/\" .. v","\t\tend","\t\tfor k, v in pairs( directories ) do","\t\t\ttable.Add( files, getFiles( dir, dir2 .. \"/\" .. v ) )","\t\tend","\t\treturn files","\tend","","\tfor k, v in pairs( getFiles( addon_path, \"materials/radon\" ) ) do","\t\tresource.AddFile( v )","\tend","","\tlocal starfall_event = {}","","\tconcommand.Add( \"starfall_event\", function ( ply, command, args )","\t\tlocal handler = starfall_event[ args[ 1 ] ]","\t\tif not handler then return end","\t\treturn handler( ply, args )","\tend )","","\tfunction starfall_event.editor_open ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( true )","\t\tnet.Broadcast()","\tend","","\tfunction starfall_event.editor_close ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( false )","\t\tnet.Broadcast()","\tend","end"],"class":"function","name":"SF.Editor.BuildIncludesTable","private":false,"summary":"\n(Client) Builds a table for the compiler to use ","description":"\n(Client) Builds a table for the compiler to use","param":{"1":"maincode","2":"codename","codename":"The name of the main chunk","maincode":"The source code for the main chunk"}}],"tables":[],"description":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n","summary":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n "},"libs_sh/von.lua":{"libraries":{"1":"von","von":{"comment":["--- vON Library","-- @shared"],"functions":{"1":"deserialize","2":"serialize","serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable({},_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}},"deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable({},_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}}},"class":"library","summary":"\nvON Library ","code":["local von, _ = SF.Libraries.Register(\"von\")","","local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable","local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next","","","","--[[    This section contains localized functions which (de)serialize","        variables according to the types found.                          ]]","","","","--\tThis is kept away from the table for speed.","function d_findVariable(s, i, len, lastType, jobstate)","\tlocal i, c, typeRead, val = i or 1","","\t--\tKeep looping through the string.","\twhile true do","\t\t--\tStop at the end. Throw an error. This function MUST NOT meet the end!","\t\tif i > len then","\t\t\tSF.throw( \"vON: Reached end of string, cannot form proper variable.\", 3 )","\t\tend","","\t\t--\tCache the character. Nobody wants to look for the same character ten times.","\t\tc = sub(s, i, i)","","\t\t--\tIf it just read a type definition, then a variable HAS to come after it.","\t\tif typeRead then","\t\t\t--\tAttempt to deserialize a variable of the freshly read type.","\t\t\tval, i = _deserialize[lastType](s, i, len, false, jobstate)","\t\t\t--\tReturn the value read, the index of the last processed character, and the type of the last read variable.","\t\t\treturn val, i, lastType","","\t\t--\t@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.","\t\telseif c == \"@\" then","\t\t\treturn nil, i, lastType","","\t\t--\t$ means a table reference will follow - a number basically.","\t\telseif c == \"$\" then","\t\t\tlastType = \"table_reference\"","\t\t\ttypeRead = true","","\t\t--\tn means a number will follow. Base 10... :C","\t\telseif c == \"n\" then","\t\t\tlastType = \"number\"","\t\t\ttypeRead = true","","\t\t--\tb means boolean flags.","\t\telseif c == \"b\" then","\t\t\tlastType = \"boolean\"","\t\t\ttypeRead = true","","\t\t--\t' means the start of a string.","\t\telseif c == \"'\" then","\t\t\tlastType = \"string\"","\t\t\ttypeRead = true","","\t\t--\t\" means the start of a string prior to version 1.2.0.","\t\telseif c == \"\\\"\" then","\t\t\tlastType = \"oldstring\"","\t\t\ttypeRead = true","","\t\t--\t{ means the start of a table!","\t\telseif c == \"{\" then","\t\t\tlastType = \"table\"","\t\t\ttypeRead = true","","","--[[    Garry's Mod types go here    ]]","","\t\t--\te means an entity ID will follow.","\t\telseif c == \"e\" then","\t\t\tlastType = \"Entity\"","\t\t\ttypeRead = true","--[[","\t\t--\tc means a vehicle ID will follow.","\t\telseif c == \"c\" then","\t\t\tlastType = \"Vehicle\"","\t\t\ttypeRead = true","","\t\t--\tw means a weapon entity ID will follow.","\t\telseif c == \"w\" then","\t\t\tlastType = \"Weapon\"","\t\t\ttypeRead = true","","\t\t--\tx means a NPC ID will follow.","\t\telseif c == \"x\" then","\t\t\tlastType = \"NPC\"","\t\t\ttypeRead = true","--]]","\t\t--\tp means a player ID will follow.","\t\t--\tKept for backwards compatibility.","\t\telseif c == \"p\" then","\t\t\tlastType = \"Entity\"","\t\t\ttypeRead = true","","\t\t--\tv means a vector will follow. 3 numbers.","\t\telseif c == \"v\" then","\t\t\tlastType = \"Vector\"","\t\t\ttypeRead = true","","\t\t--\ta means an Euler angle will follow. 3 numbers.","\t\telseif c == \"a\" then","\t\t\tlastType = \"Angle\"","\t\t\ttypeRead = true","","--[[    Garry's Mod types end here    ]]","","","\t\t--\tIf no type has been found, attempt to deserialize the last type read.","\t\telseif lastType then","\t\t\tval, i = _deserialize[lastType](s, i, len, false, jobstate)","\t\t\treturn val, i, lastType","","\t\t--\tThis will occur if the very first character in the vON code is wrong.","\t\telse","\t\t\tSF.throw( \"vON: Malformed data... Can't find a proper type definition. Char#\" .. i .. \":\" .. c, 3 )","\t\tend","","\t\t--\tMove the pointer one step forward.","\t\ti = i + 1","\tend","end","","--\tThis is kept away from the table for speed.","--\tYeah, ton of parameters.","function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)","\t","\tlocal unwrap = SF.UnwrapObject( data )","\tif unwrap then data = unwrap end","","\tlocal tp = type(data)","","\tif jobstate[1] and jobstate[2][data] then","\t\ttp = \"table_reference\"","\tend","","\t--\tBasically, if the type changes.","\tif lastType ~= tp then","\t\t--\tRemember the new type. Caching the type is useless.","\t\tlastType = tp","","\t\tif _serialize[lastType] then","\t\t\t--\tReturn the serialized data and the (new) last type.","\t\t\t--\tThe second argument, which is true now, means that the data type was just changed.","\t\t\treturn _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType","\t\telse","\t\t\tSF.throw(\"vON: No serializer defined for type \\\"\" .. lastType .. \"\\\"!\", 3)","\t\tend","\tend","","\t--\tOtherwise, simply serialize the data.","\treturn _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType","end","","","","--[[    This section contains the tables with the functions necessary","        for decoding basic Lua data types.                               ]]","","","","_deserialize = {","--\tWell, tables are very loose...","--\tThe first table doesn't have to begin and end with { and }.","\t[\"table\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\tif sub(s, i, i) == \"#\" then","\t\t\tlocal e = find(s, \"#\", i + 2, true)","","\t\t\tif e then","\t\t\t\tlocal id = tonumber(sub(s, i + 1, e - 1))","","\t\t\t\tif id then","\t\t\t\t\tif jobstate[1][id] and not jobstate[2] then","\t\t\t\t\t\tSF.throw(\"vON: There already is a table of reference #\" .. id .. \"! Missing an option maybe?\", 3)","\t\t\t\t\tend","","\t\t\t\t\tjobstate[1][id] = ret","","\t\t\t\t\ti = e + 1","\t\t\t\telse","\t\t\t\t\tSF.throw(\"vON: Malformed table! Reference ID starting at char #\" .. i .. \" doesn't contain a number!\", 3)","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: Malformed table! Cannot find end of reference ID start at char #\" .. i .. \"!\", 3)","\t\t\tend","\t\tend","","\t\t--\tKeep looping.","\t\twhile true do","\t\t\t--\tUntil it meets the end.","\t\t\tif i > len then","\t\t\t\t--\tYeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.","\t\t\t\tif unnecessaryEnd then","\t\t\t\t\treturn ret, i","","\t\t\t\t--\tOtherwise, the data has to be damaged.","\t\t\t\telse","\t\t\t\t\tSF.throw( \"vON: Reached end of string, incomplete table definition.\", 2 )","\t\t\t\tend","\t\t\tend","","\t\t\t--\tCache the character.","\t\t\tc = sub(s, i, i)","\t\t\t--print(i, \"table char:\", c, tostring(unnecessaryEnd))","","\t\t\t--\tIf it's the end of a table definition, return.","\t\t\tif c == \"}\" then","\t\t\t\treturn ret, i","","\t\t\t--\tIf it's the component separator, switch to key:value pairs.","\t\t\telseif c == \"~\" then","\t\t\t\tnumeric = false","","\t\t\telseif c == \";\" then","\t\t\t\t--\tLol, nothing!","\t\t\t\t--\tRemenant from numbers, for faster parsing.","","\t\t\t--\tOK, now, if it's on the numeric component, simply add everything encountered.","\t\t\telseif numeric then","\t\t\t\t--\tFind a variable and it's value","\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\t--\tAdd it to the table.","\t\t\t\tret[ind] = val","","\t\t\t\tind = ind + 1","","\t\t\t--\tOtherwise, if it's the key:value component...","\t\t\telse","\t\t\t\t--\tIf a value is expected...","\t\t\t\tif expectValue then","\t\t\t\t\t--\tRead it.","\t\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\t\t--\tAdd it?","\t\t\t\t\tret[key] = val","\t\t\t\t\t--\tClean up.","\t\t\t\t\texpectValue, key = false, nil","","\t\t\t\t--\tIf it's the separator...","\t\t\t\telseif c == \":\" then","\t\t\t\t\t--\tExpect a value next.","\t\t\t\t\texpectValue = true","","\t\t\t\t--\tBut, if there's a key read already...","\t\t\t\telseif key then","\t\t\t\t\t--\tThen this is malformed.","\t\t\t\t\tSF.throw( \"vON: Malformed table... Two keys declared successively? Char#\" .. i .. \":\" .. c, 2 )","","\t\t\t\t--\tOtherwise the key will be read.","\t\t\t\telse","\t\t\t\t\t--\tI love multi-return and multi-assignement.","\t\t\t\t\tkey, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\tend","\t\t\tend","","\t\t\ti = i + 1","\t\tend","","\t\treturn nil, i","\tend,","","--\tJust a number which points to a table.","\t[\"table_reference\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\tlocal n = tonumber(sub(s, i, a - 1))","","\t\t\tif n then","\t\t\t\treturn jobstate[1][n] or SF.throw(\"vON: Table reference does not point to a (yet) known table!\", 3), a - 1","\t\t\telse","\t\t\t\tSF.throw(\"vON: Table reference definition does not contain a valid number!\", 3)","\t\t\tend","\t\tend","","\t\t--\tUsing %D breaks identification of negative numbers. :(","","\t\tSF.throw(\"vON: Number definition started... Found no end.\", 3)","\tend,","","","--\tNumbers are weakly defined.","--\tThe declaration is not very explicit. It'll do it's best to parse the number.","--\tHas various endings: \\n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.","\t[\"number\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\treturn tonumber(sub(s, i, a - 1)) or SF.throw(\"vON: Number definition does not contain a valid number!\", 3), a - 1","\t\tend","","\t\tSF.throw( \"vON: Number definition started... Found no end.\", 3 )","\tend,","","","--\tA boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.","--\tAny other attempt at boolean declaration will result in a failure.","\t[\"boolean\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal c = sub(s,i,i)","\t\t--\tOnly one character is needed.","","\t\t--\tIf it's 1, then it's true","\t\tif c == \"1\" then","\t\t\treturn true, i","","\t\t--\tIf it's 0, then it's false.","\t\telseif c == \"0\" then","\t\t\treturn false, i","\t\tend","","\t\t--\tAny other supposely \"boolean\" is just a sign of malformed data.","\t\tSF.throw( \"vON: Invalid value on boolean type... Char#\" .. i .. \": \" .. c, 3 )","\tend,","","","--\tStrings prior to 1.2.0","\t[\"oldstring\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 2), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: Old string definition started... Found no end.\", 3)","\t\t\tend","\t\tend","\tend,","","--\tStrings after 1.2.0","\t[\"string\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 1), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: String definition started... Found no end.\", 3)","\t\t\tend","\t\tend","\tend,","}","","","","_serialize = {","--\tUh. Nothing to comment.","--\tTon of parameters.","--\tMakes stuff faster than simply passing it around in locals.","--\ttable.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.","\t[\"table\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--print(string.format(\"data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s\", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))","","\t\tlocal result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals, locals and locals.","\t\t","\t\t--\tFirst thing to be done is separate the numeric and key:value components of the given table in two tables.","\t\t--\tpairs(data) is slower than next, data as far as my tests tell me.","\t\tfor k, v in next, data do","\t\t\t--\tSkip the numeric keyz.","\t\t\tif type(k) ~= \"number\" or k < 1 or k > len or (k % 1 ~= 0) then\t--\tk % 1 == 0 is, as proven by personal benchmarks,","\t\t\t\tkeyvals[#keyvals + 1] = k\t\t\t\t\t\t\t\t\t--\tthe quickest way to check if a number is an integer.","\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--\tk % 1 ~= 0 is the fastest way to check if a number","\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--\tis NOT an integer. > is proven slower.","","\t\tkeyvalsLen = #keyvals","","\t\t--\tMain chunk - no initial character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"{\"","\t\tend","","\t\tif jobstate[1] and jobstate[1][data] then","\t\t\tif jobstate[2][data] then","\t\t\t\tSF.throw(\"vON: Table #\" .. jobstate[1][data] .. \" written twice..?\", 2)","\t\t\tend","","\t\t\tresult[#result + 1] = \"#\"","\t\t\tresult[#result + 1] = jobstate[1][data]","\t\t\tresult[#result + 1] = \"#\"","","\t\t\tjobstate[2][data] = true","\t\tend","","\t\t--\tAdd numeric values.","\t\tif len > 0 then","\t\t\tfor i = 1, len do","\t\t\t\tval, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tIf there are key:value pairs.","\t\tif keyvalsLen > 0 then","\t\t\t--\tInsert delimiter.","\t\t\tresult[#result + 1] = \"~\"","","\t\t\t--\tInsert key:value pairs.","\t\t\tfor _i = 1, keyvalsLen do","\t\t\t\tkeyvalsProgress = keyvalsProgress + 1","","\t\t\t\tval, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)","","\t\t\t\tresult[#result + 1] = val..\":\"","","\t\t\t\tval, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)","\t\t\t\t","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tMain chunk needs no ending character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"}\"","\t\tend","","\t\treturn concat(result)","\tend,","","--\tNumber which points to table.","\t[\"table_reference\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\tdata = jobstate[1][data]","","\t\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"$\"..data","\t\t\telse","\t\t\t\treturn \"$\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn data","\t\telse","\t\t\treturn data..\";\"","\t\tend","\tend,","","","--\tNormal concatenations is a lot faster with small strings than table.concat","--\tAlso, not so branched-ish.","\t[\"number\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"n\"..data","\t\t\telse","\t\t\t\treturn \"n\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn data","\t\telse","\t\t\treturn data..\";\"","\t\tend","\tend,","","","--\tI hope gsub is fast enough.","\t[\"string\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\tif sub(data, #data, #data) == \"\\\\\" then\t--\tHah, old strings fix this best.","\t\t\treturn \"\\\"\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"v\\\"\"","\t\tend","","\t\treturn \"'\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"\\\"\"","\tend,","","","--\tFastest.","\t[\"boolean\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--\tPrefix if we must.","\t\tif mustInitiate then","\t\t\tif data then","\t\t\t\treturn \"b1\"","\t\t\telse","\t\t\t\treturn \"b0\"","\t\t\tend","\t\tend","","\t\tif data then","\t\t\treturn \"1\"","\t\telse","\t\t\treturn \"0\"","\t\tend","\tend,","","","--\tFastest.","\t[\"nil\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\treturn \"@\"","\tend,","}","","","","--[[    This section handles additions necessary for Garry's Mod.    ]]","","","","if gmod then\t--\tLuckily, a specific table named after the game is present in Garry's Mod.","\tlocal Entity = Entity","","","","\tlocal extra_deserialize = {","--\tEntities are stored simply by the ID. They're meant to be transfered, not stored anyway.","--\tExactly like a number definition, except it begins with \"e\".","\t\t[\"Entity\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\treturn SF.WrapObject(Entity(tonumber(sub(s, i, a - 1)))), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Entity ID definition started... Found no end.\", 3)","\t\tend,","","","--\tA pair of 3 numbers separated by a comma (,).","\t\t[\"Vector\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a, x, y, z = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\tx = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\ty = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\tz = tonumber(sub(s, i, a - 1))","\t\t\tend","","\t\t\tif x and y and z then","\t\t\t\treturn SF.Vectors.Wrap(Vector(x, y, z)), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Vector definition started... Found no end.\",3)","\t\tend,","","","--\tA pair of 3 numbers separated by a comma (,).","\t\t[\"Angle\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a, p, y, r = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\tp = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\ty = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\tr = tonumber(sub(s, i, a - 1))","\t\t\tend","","\t\t\tif p and y and r then","\t\t\t\treturn SF.Angles.Wrap(Angle(p, y, r)), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Angle definition started... Found no end.\",3)","\t\tend,","\t}","","\tlocal extra_serialize = {","--\tSame as numbers, except they start with \"e\" instead of \"n\".","\t\t[\"Entity\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tdata = data:EntIndex()","","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"e\"..data","\t\t\t\telse","\t\t\t\t\treturn \"e\"..data..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data","\t\t\telse","\t\t\t\treturn data..\";\"","\t\t\tend","\t\tend,","","","--\t3 numbers separated by a comma.","\t\t[\"Vector\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"v\"..data.x..\",\"..data.y..\",\"..data.z","\t\t\t\telse","\t\t\t\t\treturn \"v\"..data.x..\",\"..data.y..\",\"..data.z..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data.x..\",\"..data.y..\",\"..data.z","\t\t\telse","\t\t\t\treturn data.x..\",\"..data.y..\",\"..data.z..\";\"","\t\t\tend","\t\tend,","","","--\t3 numbers separated by a comma.","\t\t[\"Angle\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"a\"..data.p..\",\"..data.y..\",\"..data.r","\t\t\t\telse","\t\t\t\t\treturn \"a\"..data.p..\",\"..data.y..\",\"..data.r..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data.p..\",\"..data.y..\",\"..data.r","\t\t\telse","\t\t\t\treturn data.p..\",\"..data.y..\",\"..data.r..\";\"","\t\t\tend","\t\tend,","\t}","","\tfor k, v in pairs(extra_serialize) do","\t\t_serialize[k] = v","\tend","","\tfor k, v in pairs(extra_deserialize) do","\t\t_deserialize[k] = v","\tend","","\tlocal extraEntityTypes = { \"Vehicle\", \"Weapon\", \"NPC\", \"Player\", \"NextBot\" }","","\tfor i = 1, #extraEntityTypes do","\t\t_serialize[extraEntityTypes[i]] = _serialize.Entity","\tend","end","","","","--[[    This section exposes the functions of the library.    ]]","","","","local function checkTableForRecursion(tab, checked, assoc)","\tlocal id = checked.ID","","\tif not checked[tab] and not assoc[tab] then","\t\tassoc[tab] = id","\t\tchecked.ID = id + 1","\telse","\t\tchecked[tab] = true","\tend","","\tfor k, v in pairs(tab) do","\t\tif type(k) == \"table\" and not checked[k] then","\t\t\tcheckTableForRecursion(k, checked, assoc)","\t\tend","\t\t","\t\tif type(v) == \"table\" and not checked[v] then","\t\t\tcheckTableForRecursion(v, checked, assoc)","\t\tend","\tend","end","","","","local _s_table = _serialize.table","local _d_table = _deserialize.table","","_d_meta = {","\t__call = function(self, str, allowIdRewriting)","\t\tif type(str) == \"string\" then","\t\t\treturn _d_table(str, nil, #str, true, {{}, allowIdRewriting})","\t\tend","\t\tSF.throw( \"vON: You must deserialize a string, not a \" .. type( str ), 2 )","\tend,","\t__newindex = function() end,","\t__metatable = false","}","_s_meta = {","\t__call = function(self, data, checkRecursion)","\t\tif type(data) == \"table\" then","\t\t\tif checkRecursion then","\t\t\t\tlocal assoc, checked = {}, {ID = 1}","","\t\t\t\tcheckTableForRecursion(data, checked, assoc)","","\t\t\t\treturn _s_table(data, nil, nil, nil, nil, true, {assoc, {}})","\t\t\tend","","\t\t\treturn _s_table(data, nil, nil, nil, nil, true, {false})","\t\tend","\t\tSF.throw( \"vON: You must serialize a table, not a \" .. type( data ), 2 )","\tend,","\t__newindex = function() end,","\t__metatable = false","}",""],"fields":[],"name":"von","client":true,"description":"\nvON Library","libtbl":"von","tables":[],"server":true}},"type":"file","name":"libs_sh/von.lua","functions":{"1":"von.deserialize","2":"von.serialize","von.deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable({},_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}},"von.serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable({},_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}}},"doc":[{"comment":["-----------------------------------------------------------------------------------------------------------------------------"],"code":["\t","\tThanks to the following people for their contribution:","\t\t-\tDivran\t\t\t\t\t\tSuggested improvements for making the code quicker.","\t\t\t\t\t\t\t\t\t\tSuggested an excellent new way of deserializing strings.","\t\t\t\t\t\t\t\t\t\tLead me to finding an extreme flaw in string parsing.","\t\t-\tpennerlord\t\t\t\t\tProvided some performance tests to help me improve the code.","\t\t-\tChessnut\t\t\t\t\tReported bug with handling of nil values when deserializing array components.","","\t\t-\tPeople who contributed on the GitHub repository by reporting bugs, posting fixes, etc.",""],"summary":"\n ","description":"\n","param":[]},{"comment":["-----------------------------------------------------------------------------------------------------------------------------"],"code":["\t","\tThe vanilla types supported in this release of vON are:","\t\t-\ttable","\t\t-\tnumber","\t\t-\tboolean","\t\t-\tstring","\t\t-\tnil","","\tThe Garry's Mod-specific types supported in this release are:","\t\t-\tVector","\t\t-\tAngle","\t\t+\tEntities:","\t\t\t-\tEntity","\t\t\t-\tVehicle","\t\t\t-\tWeapon","\t\t\t-\tNPC","\t\t\t-\tPlayer","\t\t\t-\tNextBot","","\tThese are the types one would normally serialize.",""],"summary":"\n ","description":"\n","param":[]},{"comment":["-----------------------------------------------------------------------------------------------------------------------------"],"code":["\t","\tNew in this version:","\t\t-\tFixed addition of extra entity types. I messed up really badly.","--]]",""],"summary":"\n ","description":"\n","param":[]},{"comment":["--- vON Library","-- @shared"],"functions":{"1":"deserialize","2":"serialize","serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable({},_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}},"deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable({},_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}}},"class":"library","summary":"\nvON Library ","code":["local von, _ = SF.Libraries.Register(\"von\")","","local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable","local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next","","","","--[[    This section contains localized functions which (de)serialize","        variables according to the types found.                          ]]","","","","--\tThis is kept away from the table for speed.","function d_findVariable(s, i, len, lastType, jobstate)","\tlocal i, c, typeRead, val = i or 1","","\t--\tKeep looping through the string.","\twhile true do","\t\t--\tStop at the end. Throw an error. This function MUST NOT meet the end!","\t\tif i > len then","\t\t\tSF.throw( \"vON: Reached end of string, cannot form proper variable.\", 3 )","\t\tend","","\t\t--\tCache the character. Nobody wants to look for the same character ten times.","\t\tc = sub(s, i, i)","","\t\t--\tIf it just read a type definition, then a variable HAS to come after it.","\t\tif typeRead then","\t\t\t--\tAttempt to deserialize a variable of the freshly read type.","\t\t\tval, i = _deserialize[lastType](s, i, len, false, jobstate)","\t\t\t--\tReturn the value read, the index of the last processed character, and the type of the last read variable.","\t\t\treturn val, i, lastType","","\t\t--\t@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.","\t\telseif c == \"@\" then","\t\t\treturn nil, i, lastType","","\t\t--\t$ means a table reference will follow - a number basically.","\t\telseif c == \"$\" then","\t\t\tlastType = \"table_reference\"","\t\t\ttypeRead = true","","\t\t--\tn means a number will follow. Base 10... :C","\t\telseif c == \"n\" then","\t\t\tlastType = \"number\"","\t\t\ttypeRead = true","","\t\t--\tb means boolean flags.","\t\telseif c == \"b\" then","\t\t\tlastType = \"boolean\"","\t\t\ttypeRead = true","","\t\t--\t' means the start of a string.","\t\telseif c == \"'\" then","\t\t\tlastType = \"string\"","\t\t\ttypeRead = true","","\t\t--\t\" means the start of a string prior to version 1.2.0.","\t\telseif c == \"\\\"\" then","\t\t\tlastType = \"oldstring\"","\t\t\ttypeRead = true","","\t\t--\t{ means the start of a table!","\t\telseif c == \"{\" then","\t\t\tlastType = \"table\"","\t\t\ttypeRead = true","","","--[[    Garry's Mod types go here    ]]","","\t\t--\te means an entity ID will follow.","\t\telseif c == \"e\" then","\t\t\tlastType = \"Entity\"","\t\t\ttypeRead = true","--[[","\t\t--\tc means a vehicle ID will follow.","\t\telseif c == \"c\" then","\t\t\tlastType = \"Vehicle\"","\t\t\ttypeRead = true","","\t\t--\tw means a weapon entity ID will follow.","\t\telseif c == \"w\" then","\t\t\tlastType = \"Weapon\"","\t\t\ttypeRead = true","","\t\t--\tx means a NPC ID will follow.","\t\telseif c == \"x\" then","\t\t\tlastType = \"NPC\"","\t\t\ttypeRead = true","--]]","\t\t--\tp means a player ID will follow.","\t\t--\tKept for backwards compatibility.","\t\telseif c == \"p\" then","\t\t\tlastType = \"Entity\"","\t\t\ttypeRead = true","","\t\t--\tv means a vector will follow. 3 numbers.","\t\telseif c == \"v\" then","\t\t\tlastType = \"Vector\"","\t\t\ttypeRead = true","","\t\t--\ta means an Euler angle will follow. 3 numbers.","\t\telseif c == \"a\" then","\t\t\tlastType = \"Angle\"","\t\t\ttypeRead = true","","--[[    Garry's Mod types end here    ]]","","","\t\t--\tIf no type has been found, attempt to deserialize the last type read.","\t\telseif lastType then","\t\t\tval, i = _deserialize[lastType](s, i, len, false, jobstate)","\t\t\treturn val, i, lastType","","\t\t--\tThis will occur if the very first character in the vON code is wrong.","\t\telse","\t\t\tSF.throw( \"vON: Malformed data... Can't find a proper type definition. Char#\" .. i .. \":\" .. c, 3 )","\t\tend","","\t\t--\tMove the pointer one step forward.","\t\ti = i + 1","\tend","end","","--\tThis is kept away from the table for speed.","--\tYeah, ton of parameters.","function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)","\t","\tlocal unwrap = SF.UnwrapObject( data )","\tif unwrap then data = unwrap end","","\tlocal tp = type(data)","","\tif jobstate[1] and jobstate[2][data] then","\t\ttp = \"table_reference\"","\tend","","\t--\tBasically, if the type changes.","\tif lastType ~= tp then","\t\t--\tRemember the new type. Caching the type is useless.","\t\tlastType = tp","","\t\tif _serialize[lastType] then","\t\t\t--\tReturn the serialized data and the (new) last type.","\t\t\t--\tThe second argument, which is true now, means that the data type was just changed.","\t\t\treturn _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType","\t\telse","\t\t\tSF.throw(\"vON: No serializer defined for type \\\"\" .. lastType .. \"\\\"!\", 3)","\t\tend","\tend","","\t--\tOtherwise, simply serialize the data.","\treturn _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType","end","","","","--[[    This section contains the tables with the functions necessary","        for decoding basic Lua data types.                               ]]","","","","_deserialize = {","--\tWell, tables are very loose...","--\tThe first table doesn't have to begin and end with { and }.","\t[\"table\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\tif sub(s, i, i) == \"#\" then","\t\t\tlocal e = find(s, \"#\", i + 2, true)","","\t\t\tif e then","\t\t\t\tlocal id = tonumber(sub(s, i + 1, e - 1))","","\t\t\t\tif id then","\t\t\t\t\tif jobstate[1][id] and not jobstate[2] then","\t\t\t\t\t\tSF.throw(\"vON: There already is a table of reference #\" .. id .. \"! Missing an option maybe?\", 3)","\t\t\t\t\tend","","\t\t\t\t\tjobstate[1][id] = ret","","\t\t\t\t\ti = e + 1","\t\t\t\telse","\t\t\t\t\tSF.throw(\"vON: Malformed table! Reference ID starting at char #\" .. i .. \" doesn't contain a number!\", 3)","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: Malformed table! Cannot find end of reference ID start at char #\" .. i .. \"!\", 3)","\t\t\tend","\t\tend","","\t\t--\tKeep looping.","\t\twhile true do","\t\t\t--\tUntil it meets the end.","\t\t\tif i > len then","\t\t\t\t--\tYeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.","\t\t\t\tif unnecessaryEnd then","\t\t\t\t\treturn ret, i","","\t\t\t\t--\tOtherwise, the data has to be damaged.","\t\t\t\telse","\t\t\t\t\tSF.throw( \"vON: Reached end of string, incomplete table definition.\", 2 )","\t\t\t\tend","\t\t\tend","","\t\t\t--\tCache the character.","\t\t\tc = sub(s, i, i)","\t\t\t--print(i, \"table char:\", c, tostring(unnecessaryEnd))","","\t\t\t--\tIf it's the end of a table definition, return.","\t\t\tif c == \"}\" then","\t\t\t\treturn ret, i","","\t\t\t--\tIf it's the component separator, switch to key:value pairs.","\t\t\telseif c == \"~\" then","\t\t\t\tnumeric = false","","\t\t\telseif c == \";\" then","\t\t\t\t--\tLol, nothing!","\t\t\t\t--\tRemenant from numbers, for faster parsing.","","\t\t\t--\tOK, now, if it's on the numeric component, simply add everything encountered.","\t\t\telseif numeric then","\t\t\t\t--\tFind a variable and it's value","\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\t--\tAdd it to the table.","\t\t\t\tret[ind] = val","","\t\t\t\tind = ind + 1","","\t\t\t--\tOtherwise, if it's the key:value component...","\t\t\telse","\t\t\t\t--\tIf a value is expected...","\t\t\t\tif expectValue then","\t\t\t\t\t--\tRead it.","\t\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\t\t--\tAdd it?","\t\t\t\t\tret[key] = val","\t\t\t\t\t--\tClean up.","\t\t\t\t\texpectValue, key = false, nil","","\t\t\t\t--\tIf it's the separator...","\t\t\t\telseif c == \":\" then","\t\t\t\t\t--\tExpect a value next.","\t\t\t\t\texpectValue = true","","\t\t\t\t--\tBut, if there's a key read already...","\t\t\t\telseif key then","\t\t\t\t\t--\tThen this is malformed.","\t\t\t\t\tSF.throw( \"vON: Malformed table... Two keys declared successively? Char#\" .. i .. \":\" .. c, 2 )","","\t\t\t\t--\tOtherwise the key will be read.","\t\t\t\telse","\t\t\t\t\t--\tI love multi-return and multi-assignement.","\t\t\t\t\tkey, i, lastType = d_findVariable(s, i, len, lastType, jobstate)","\t\t\t\tend","\t\t\tend","","\t\t\ti = i + 1","\t\tend","","\t\treturn nil, i","\tend,","","--\tJust a number which points to a table.","\t[\"table_reference\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\tlocal n = tonumber(sub(s, i, a - 1))","","\t\t\tif n then","\t\t\t\treturn jobstate[1][n] or SF.throw(\"vON: Table reference does not point to a (yet) known table!\", 3), a - 1","\t\t\telse","\t\t\t\tSF.throw(\"vON: Table reference definition does not contain a valid number!\", 3)","\t\t\tend","\t\tend","","\t\t--\tUsing %D breaks identification of negative numbers. :(","","\t\tSF.throw(\"vON: Number definition started... Found no end.\", 3)","\tend,","","","--\tNumbers are weakly defined.","--\tThe declaration is not very explicit. It'll do it's best to parse the number.","--\tHas various endings: \\n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.","\t[\"number\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\treturn tonumber(sub(s, i, a - 1)) or SF.throw(\"vON: Number definition does not contain a valid number!\", 3), a - 1","\t\tend","","\t\tSF.throw( \"vON: Number definition started... Found no end.\", 3 )","\tend,","","","--\tA boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.","--\tAny other attempt at boolean declaration will result in a failure.","\t[\"boolean\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal c = sub(s,i,i)","\t\t--\tOnly one character is needed.","","\t\t--\tIf it's 1, then it's true","\t\tif c == \"1\" then","\t\t\treturn true, i","","\t\t--\tIf it's 0, then it's false.","\t\telseif c == \"0\" then","\t\t\treturn false, i","\t\tend","","\t\t--\tAny other supposely \"boolean\" is just a sign of malformed data.","\t\tSF.throw( \"vON: Invalid value on boolean type... Char#\" .. i .. \": \" .. c, 3 )","\tend,","","","--\tStrings prior to 1.2.0","\t[\"oldstring\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 2), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: Old string definition started... Found no end.\", 3)","\t\t\tend","\t\tend","\tend,","","--\tStrings after 1.2.0","\t[\"string\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 1), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw(\"vON: String definition started... Found no end.\", 3)","\t\t\tend","\t\tend","\tend,","}","","","","_serialize = {","--\tUh. Nothing to comment.","--\tTon of parameters.","--\tMakes stuff faster than simply passing it around in locals.","--\ttable.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.","\t[\"table\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--print(string.format(\"data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s\", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))","","\t\tlocal result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals, locals and locals.","\t\t","\t\t--\tFirst thing to be done is separate the numeric and key:value components of the given table in two tables.","\t\t--\tpairs(data) is slower than next, data as far as my tests tell me.","\t\tfor k, v in next, data do","\t\t\t--\tSkip the numeric keyz.","\t\t\tif type(k) ~= \"number\" or k < 1 or k > len or (k % 1 ~= 0) then\t--\tk % 1 == 0 is, as proven by personal benchmarks,","\t\t\t\tkeyvals[#keyvals + 1] = k\t\t\t\t\t\t\t\t\t--\tthe quickest way to check if a number is an integer.","\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--\tk % 1 ~= 0 is the fastest way to check if a number","\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--\tis NOT an integer. > is proven slower.","","\t\tkeyvalsLen = #keyvals","","\t\t--\tMain chunk - no initial character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"{\"","\t\tend","","\t\tif jobstate[1] and jobstate[1][data] then","\t\t\tif jobstate[2][data] then","\t\t\t\tSF.throw(\"vON: Table #\" .. jobstate[1][data] .. \" written twice..?\", 2)","\t\t\tend","","\t\t\tresult[#result + 1] = \"#\"","\t\t\tresult[#result + 1] = jobstate[1][data]","\t\t\tresult[#result + 1] = \"#\"","","\t\t\tjobstate[2][data] = true","\t\tend","","\t\t--\tAdd numeric values.","\t\tif len > 0 then","\t\t\tfor i = 1, len do","\t\t\t\tval, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tIf there are key:value pairs.","\t\tif keyvalsLen > 0 then","\t\t\t--\tInsert delimiter.","\t\t\tresult[#result + 1] = \"~\"","","\t\t\t--\tInsert key:value pairs.","\t\t\tfor _i = 1, keyvalsLen do","\t\t\t\tkeyvalsProgress = keyvalsProgress + 1","","\t\t\t\tval, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)","","\t\t\t\tresult[#result + 1] = val..\":\"","","\t\t\t\tval, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)","\t\t\t\t","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tMain chunk needs no ending character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"}\"","\t\tend","","\t\treturn concat(result)","\tend,","","--\tNumber which points to table.","\t[\"table_reference\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\tdata = jobstate[1][data]","","\t\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"$\"..data","\t\t\telse","\t\t\t\treturn \"$\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn data","\t\telse","\t\t\treturn data..\";\"","\t\tend","\tend,","","","--\tNormal concatenations is a lot faster with small strings than table.concat","--\tAlso, not so branched-ish.","\t[\"number\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"n\"..data","\t\t\telse","\t\t\t\treturn \"n\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn data","\t\telse","\t\t\treturn data..\";\"","\t\tend","\tend,","","","--\tI hope gsub is fast enough.","\t[\"string\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\tif sub(data, #data, #data) == \"\\\\\" then\t--\tHah, old strings fix this best.","\t\t\treturn \"\\\"\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"v\\\"\"","\t\tend","","\t\treturn \"'\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"\\\"\"","\tend,","","","--\tFastest.","\t[\"boolean\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t--\tPrefix if we must.","\t\tif mustInitiate then","\t\t\tif data then","\t\t\t\treturn \"b1\"","\t\t\telse","\t\t\t\treturn \"b0\"","\t\t\tend","\t\tend","","\t\tif data then","\t\t\treturn \"1\"","\t\telse","\t\t\treturn \"0\"","\t\tend","\tend,","","","--\tFastest.","\t[\"nil\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\treturn \"@\"","\tend,","}","","","","--[[    This section handles additions necessary for Garry's Mod.    ]]","","","","if gmod then\t--\tLuckily, a specific table named after the game is present in Garry's Mod.","\tlocal Entity = Entity","","","","\tlocal extra_deserialize = {","--\tEntities are stored simply by the ID. They're meant to be transfered, not stored anyway.","--\tExactly like a number definition, except it begins with \"e\".","\t\t[\"Entity\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\treturn SF.WrapObject(Entity(tonumber(sub(s, i, a - 1)))), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Entity ID definition started... Found no end.\", 3)","\t\tend,","","","--\tA pair of 3 numbers separated by a comma (,).","\t\t[\"Vector\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a, x, y, z = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\tx = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\ty = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\tz = tonumber(sub(s, i, a - 1))","\t\t\tend","","\t\t\tif x and y and z then","\t\t\t\treturn SF.Vectors.Wrap(Vector(x, y, z)), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Vector definition started... Found no end.\",3)","\t\tend,","","","--\tA pair of 3 numbers separated by a comma (,).","\t\t[\"Angle\"] = function(s, i, len, unnecessaryEnd, jobstate)","\t\t\tlocal i, a, p, y, r = i or 1","\t\t\t--\tLocals, locals, locals, locals","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\tp = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \",\", i)","","\t\t\tif a then","\t\t\t\ty = tonumber(sub(s, i, a - 1))","\t\t\t\ti = a + 1","\t\t\tend","","\t\t\ta = find(s, \"[;:}~]\", i)","","\t\t\tif a then","\t\t\t\tr = tonumber(sub(s, i, a - 1))","\t\t\tend","","\t\t\tif p and y and r then","\t\t\t\treturn SF.Angles.Wrap(Angle(p, y, r)), a - 1","\t\t\tend","","\t\t\tSF.throw(\"vON: Angle definition started... Found no end.\",3)","\t\tend,","\t}","","\tlocal extra_serialize = {","--\tSame as numbers, except they start with \"e\" instead of \"n\".","\t\t[\"Entity\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tdata = data:EntIndex()","","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"e\"..data","\t\t\t\telse","\t\t\t\t\treturn \"e\"..data..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data","\t\t\telse","\t\t\t\treturn data..\";\"","\t\t\tend","\t\tend,","","","--\t3 numbers separated by a comma.","\t\t[\"Vector\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"v\"..data.x..\",\"..data.y..\",\"..data.z","\t\t\t\telse","\t\t\t\t\treturn \"v\"..data.x..\",\"..data.y..\",\"..data.z..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data.x..\",\"..data.y..\",\"..data.z","\t\t\telse","\t\t\t\treturn data.x..\",\"..data.y..\",\"..data.z..\";\"","\t\t\tend","\t\tend,","","","--\t3 numbers separated by a comma.","\t\t[\"Angle\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)","\t\t\tif mustInitiate then","\t\t\t\tif isKey or isLast then","\t\t\t\t\treturn \"a\"..data.p..\",\"..data.y..\",\"..data.r","\t\t\t\telse","\t\t\t\t\treturn \"a\"..data.p..\",\"..data.y..\",\"..data.r..\";\"","\t\t\t\tend","\t\t\tend","","\t\t\tif isKey or isLast then","\t\t\t\treturn data.p..\",\"..data.y..\",\"..data.r","\t\t\telse","\t\t\t\treturn data.p..\",\"..data.y..\",\"..data.r..\";\"","\t\t\tend","\t\tend,","\t}","","\tfor k, v in pairs(extra_serialize) do","\t\t_serialize[k] = v","\tend","","\tfor k, v in pairs(extra_deserialize) do","\t\t_deserialize[k] = v","\tend","","\tlocal extraEntityTypes = { \"Vehicle\", \"Weapon\", \"NPC\", \"Player\", \"NextBot\" }","","\tfor i = 1, #extraEntityTypes do","\t\t_serialize[extraEntityTypes[i]] = _serialize.Entity","\tend","end","","","","--[[    This section exposes the functions of the library.    ]]","","","","local function checkTableForRecursion(tab, checked, assoc)","\tlocal id = checked.ID","","\tif not checked[tab] and not assoc[tab] then","\t\tassoc[tab] = id","\t\tchecked.ID = id + 1","\telse","\t\tchecked[tab] = true","\tend","","\tfor k, v in pairs(tab) do","\t\tif type(k) == \"table\" and not checked[k] then","\t\t\tcheckTableForRecursion(k, checked, assoc)","\t\tend","\t\t","\t\tif type(v) == \"table\" and not checked[v] then","\t\t\tcheckTableForRecursion(v, checked, assoc)","\t\tend","\tend","end","","","","local _s_table = _serialize.table","local _d_table = _deserialize.table","","_d_meta = {","\t__call = function(self, str, allowIdRewriting)","\t\tif type(str) == \"string\" then","\t\t\treturn _d_table(str, nil, #str, true, {{}, allowIdRewriting})","\t\tend","\t\tSF.throw( \"vON: You must deserialize a string, not a \" .. type( str ), 2 )","\tend,","\t__newindex = function() end,","\t__metatable = false","}","_s_meta = {","\t__call = function(self, data, checkRecursion)","\t\tif type(data) == \"table\" then","\t\t\tif checkRecursion then","\t\t\t\tlocal assoc, checked = {}, {ID = 1}","","\t\t\t\tcheckTableForRecursion(data, checked, assoc)","","\t\t\t\treturn _s_table(data, nil, nil, nil, nil, true, {assoc, {}})","\t\t\tend","","\t\t\treturn _s_table(data, nil, nil, nil, nil, true, {false})","\t\tend","\t\tSF.throw( \"vON: You must serialize a table, not a \" .. type( data ), 2 )","\tend,","\t__newindex = function() end,","\t__metatable = false","}",""],"fields":[],"name":"von","client":true,"description":"\nvON Library","libtbl":"von","tables":[],"server":true},{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable({},_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}},{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable({},_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}}],"tables":[],"description":"\n","summary":"\n "},"libs_sh/game.lua":{"libraries":{"1":"game","game":{"comment":["--- Game functions","-- @shared"],"functions":{"1":"getGamemode","2":"getHostname","3":"getMap","4":"getMaxPlayers","5":"isDedicated","6":"isLan","7":"isSinglePlayer","getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},"getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]}},"class":"library","summary":"\nGame functions ","code":["local game_lib, _ = SF.Libraries.Register( \"game\" )",""],"fields":[],"name":"game","client":true,"description":"\nGame functions","libtbl":"game_lib","tables":[],"server":true}},"type":"file","name":"libs_sh/game.lua","functions":{"1":"game_lib.getGamemode","2":"game_lib.getHostname","3":"game_lib.getMap","4":"game_lib.getMaxPlayers","5":"game_lib.isDedicated","6":"game_lib.isLan","7":"game_lib.isSinglePlayer","game_lib.getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]},"game_lib.isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"game_lib.isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"game_lib.getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"game_lib.isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"game_lib.getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"game_lib.getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]}},"doc":[{"summary":"\n \nGame library \n ","description":"\n \nGame library \n","comment":["-------------------------------------------------------------------------------","-- Game library","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Game functions","-- @shared"],"functions":{"1":"getGamemode","2":"getHostname","3":"getMap","4":"getMaxPlayers","5":"isDedicated","6":"isLan","7":"isSinglePlayer","getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},"getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]}},"class":"library","summary":"\nGame functions ","code":["local game_lib, _ = SF.Libraries.Register( \"game\" )",""],"fields":[],"name":"game","client":true,"description":"\nGame functions","libtbl":"game_lib","tables":[],"server":true},{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]},{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]}],"tables":[],"description":"\n \nGame library \n","summary":"\n \nGame library \n "},"libs_sh/trace.lua":{"libraries":{"1":"trace","trace":{"comment":["--- Provides functions for doing line/AABB traces","-- @shared","-- @field MAT_ANTLION","-- @field MAT_BLOODYFLESH","-- @field MAT_CONCRETE","-- @field MAT_DIRT","-- @field MAT_FLESH","-- @field MAT_GRATE","-- @field MAT_ALIENFLESH","-- @field MAT_CLIP","-- @field MAT_PLASTIC","-- @field MAT_METAL","-- @field MAT_SAND","-- @field MAT_FOLIAGE","-- @field MAT_COMPUTER","-- @field MAT_SLOSH","-- @field MAT_TILE","-- @field MAT_VENT","-- @field MAT_WOOD","-- @field MAT_GLASS","-- @field HITGROUP_GENERIC","-- @field HITGROUP_HEAD","-- @field HITGROUP_CHEST","-- @field HITGROUP_STOMACH","-- @field HITGROUP_LEFTARM","-- @field HITGROUP_RIGHTARM","-- @field HITGROUP_LEFTLEG","-- @field HITGROUP_RIGHTLEG","-- @field HITGROUP_GEAR","-- @field MASK_SPLITAREAPORTAL","-- @field MASK_SOLID_BRUSHONLY","-- @field MASK_WATER","-- @field MASK_BLOCKLOS","-- @field MASK_OPAQUE","-- @field MASK_VISIBLE","-- @field MASK_DEADSOLID","-- @field MASK_PLAYERSOLID_BRUSHONLY","-- @field MASK_NPCWORLDSTATIC","-- @field MASK_NPCSOLID_BRUSHONLY","-- @field MASK_CURRENT","-- @field MASK_SHOT_PORTAL","-- @field MASK_SOLID","-- @field MASK_BLOCKLOS_AND_NPCS","-- @field MASK_OPAQUE_AND_NPCS","-- @field MASK_VISIBLE_AND_NPCS","-- @field MASK_PLAYERSOLID","-- @field MASK_NPCSOLID","-- @field MASK_SHOT_HULL","-- @field MASK_SHOT","-- @field MASK_ALL","-- @field CONTENTS_EMPTY","-- @field CONTENTS_SOLID","-- @field CONTENTS_WINDOW","-- @field CONTENTS_AUX","-- @field CONTENTS_GRATE","-- @field CONTENTS_SLIME","-- @field CONTENTS_WATER","-- @field CONTENTS_BLOCKLOS","-- @field CONTENTS_OPAQUE","-- @field CONTENTS_TESTFOGVOLUME","-- @field CONTENTS_TEAM4","-- @field CONTENTS_TEAM3","-- @field CONTENTS_TEAM1","-- @field CONTENTS_TEAM2","-- @field CONTENTS_IGNORE_NODRAW_OPAQUE","-- @field CONTENTS_MOVEABLE","-- @field CONTENTS_AREAPORTAL","-- @field CONTENTS_PLAYERCLIP","-- @field CONTENTS_MONSTERCLIP","-- @field CONTENTS_CURRENT_0","-- @field CONTENTS_CURRENT_90","-- @field CONTENTS_CURRENT_180","-- @field CONTENTS_CURRENT_270","-- @field CONTENTS_CURRENT_UP","-- @field CONTENTS_CURRENT_DOWN","-- @field CONTENTS_ORIGIN","-- @field CONTENTS_MONSTER","-- @field CONTENTS_DEBRIS","-- @field CONTENTS_DETAIL","-- @field CONTENTS_TRANSLUCENT","-- @field CONTENTS_LADDER","-- @field CONTENTS_HITBOX"],"functions":{"1":"trace","2":"traceHull","traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\tlocal data = util.TraceHull( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}},"trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\tlocal data = util.TraceLine( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","endpos":"End position"}}},"class":"library","summary":"\nProvides functions for doing line/AABB traces ","field":{"1":"MAT_ANTLION","2":"MAT_BLOODYFLESH","3":"MAT_CONCRETE","4":"MAT_DIRT","5":"MAT_FLESH","6":"MAT_GRATE","7":"MAT_ALIENFLESH","8":"MAT_CLIP","9":"MAT_PLASTIC","10":"MAT_METAL","11":"MAT_SAND","12":"MAT_FOLIAGE","13":"MAT_COMPUTER","14":"MAT_SLOSH","15":"MAT_TILE","16":"MAT_VENT","17":"MAT_WOOD","18":"MAT_GLASS","19":"HITGROUP_GENERIC","20":"HITGROUP_HEAD","21":"HITGROUP_CHEST","22":"HITGROUP_STOMACH","23":"HITGROUP_LEFTARM","24":"HITGROUP_RIGHTARM","25":"HITGROUP_LEFTLEG","26":"HITGROUP_RIGHTLEG","27":"HITGROUP_GEAR","28":"MASK_SPLITAREAPORTAL","29":"MASK_SOLID_BRUSHONLY","30":"MASK_WATER","31":"MASK_BLOCKLOS","32":"MASK_OPAQUE","33":"MASK_VISIBLE","34":"MASK_DEADSOLID","35":"MASK_PLAYERSOLID_BRUSHONLY","36":"MASK_NPCWORLDSTATIC","37":"MASK_NPCSOLID_BRUSHONLY","38":"MASK_CURRENT","39":"MASK_SHOT_PORTAL","40":"MASK_SOLID","41":"MASK_BLOCKLOS_AND_NPCS","42":"MASK_OPAQUE_AND_NPCS","43":"MASK_VISIBLE_AND_NPCS","44":"MASK_PLAYERSOLID","45":"MASK_NPCSOLID","46":"MASK_SHOT_HULL","47":"MASK_SHOT","48":"MASK_ALL","49":"CONTENTS_EMPTY","50":"CONTENTS_SOLID","51":"CONTENTS_WINDOW","52":"CONTENTS_AUX","53":"CONTENTS_GRATE","54":"CONTENTS_SLIME","55":"CONTENTS_WATER","56":"CONTENTS_BLOCKLOS","57":"CONTENTS_OPAQUE","58":"CONTENTS_TESTFOGVOLUME","59":"CONTENTS_TEAM4","60":"CONTENTS_TEAM3","61":"CONTENTS_TEAM1","62":"CONTENTS_TEAM2","63":"CONTENTS_IGNORE_NODRAW_OPAQUE","64":"CONTENTS_MOVEABLE","65":"CONTENTS_AREAPORTAL","66":"CONTENTS_PLAYERCLIP","67":"CONTENTS_MONSTERCLIP","68":"CONTENTS_CURRENT_0","69":"CONTENTS_CURRENT_90","70":"CONTENTS_CURRENT_180","71":"CONTENTS_CURRENT_270","72":"CONTENTS_CURRENT_UP","73":"CONTENTS_CURRENT_DOWN","74":"CONTENTS_ORIGIN","75":"CONTENTS_MONSTER","76":"CONTENTS_DEBRIS","77":"CONTENTS_DETAIL","78":"CONTENTS_TRANSLUCENT","79":"CONTENTS_LADDER","80":"CONTENTS_HITBOX","MASK_DEADSOLID":"","MASK_BLOCKLOS":"","CONTENTS_EMPTY":"","MASK_OPAQUE":"","CONTENTS_IGNORE_NODRAW_OPAQUE":"","MASK_VISIBLE":"","HITGROUP_LEFTLEG":"","MASK_PLAYERSOLID_BRUSHONLY":"","HITGROUP_RIGHTARM":"","CONTENTS_CURRENT_DOWN":"","CONTENTS_OPAQUE":"","MAT_TILE":"","MAT_FOLIAGE":"","HITGROUP_HEAD":"","MASK_SHOT":"","MAT_COMPUTER":"","CONTENTS_TEAM3":"","MASK_SPLITAREAPORTAL":"","CONTENTS_CURRENT_UP":"","MAT_CONCRETE":"","MAT_CLIP":"","MAT_WOOD":"","MAT_ANTLION":"","MASK_NPCSOLID_BRUSHONLY":"","CONTENTS_DEBRIS":"","MASK_SHOT_PORTAL":"","HITGROUP_STOMACH":"","MAT_SLOSH":"","CONTENTS_PLAYERCLIP":"","MASK_NPCWORLDSTATIC":"","MASK_OPAQUE_AND_NPCS":"","MAT_BLOODYFLESH":"","MASK_BLOCKLOS_AND_NPCS":"","CONTENTS_TEAM1":"","HITGROUP_CHEST":"","CONTENTS_AREAPORTAL":"","HITGROUP_GENERIC":"","MAT_METAL":"","HITGROUP_GEAR":"","MAT_VENT":"","MAT_PLASTIC":"","CONTENTS_CURRENT_180":"","MAT_ALIENFLESH":"","MAT_FLESH":"","MAT_GLASS":"","CONTENTS_HITBOX":"","CONTENTS_LADDER":"","CONTENTS_MONSTER":"","CONTENTS_ORIGIN":"","CONTENTS_TEAM2":"","CONTENTS_DETAIL":"","CONTENTS_GRATE":"","MASK_NPCSOLID":"","CONTENTS_MOVEABLE":"","CONTENTS_TRANSLUCENT":"","CONTENTS_CURRENT_270":"","MASK_VISIBLE_AND_NPCS":"","CONTENTS_SOLID":"","CONTENTS_MONSTERCLIP":"","MAT_SAND":"","CONTENTS_SLIME":"","CONTENTS_CURRENT_0":"","CONTENTS_WINDOW":"","MASK_PLAYERSOLID":"","MASK_ALL":"","CONTENTS_BLOCKLOS":"","MASK_WATER":"","MASK_SOLID_BRUSHONLY":"","HITGROUP_RIGHTLEG":"","CONTENTS_CURRENT_90":"","CONTENTS_AUX":"","MASK_CURRENT":"","MAT_DIRT":"","CONTENTS_TEAM4":"","CONTENTS_TESTFOGVOLUME":"","CONTENTS_WATER":"","MASK_SOLID":"","MASK_SHOT_HULL":"","HITGROUP_LEFTARM":"","MAT_GRATE":""},"code":["local trace_library, _ = SF.Libraries.Register(\"trace\")","","-- Material Enumeration","trace_library.MAT_ANTLION = MAT_ANTLION","trace_library.MAT_BLOODYFLESH = MAT_BLOODYFLESH","trace_library.MAT_CONCRETE = MAT_CONCRETE","trace_library.MAT_DIRT = MAT_DIRT","trace_library.MAT_FLESH = MAT_FLESH","trace_library.MAT_GRATE = MAT_GRATE","trace_library.MAT_ALIENFLESH = MAT_ALIENFLESH","trace_library.MAT_CLIP = MAT_CLIP","trace_library.MAT_PLASTIC = MAT_PLASTIC","trace_library.MAT_METAL = MAT_METAL","trace_library.MAT_SAND = MAT_SAND","trace_library.MAT_FOLIAGE = MAT_FOLIAGE","trace_library.MAT_COMPUTER = MAT_COMPUTER","trace_library.MAT_SLOSH = MAT_SLOSH","trace_library.MAT_TILE = MAT_TILE","trace_library.MAT_VENT = MAT_VENT","trace_library.MAT_WOOD = MAT_WOOD","trace_library.MAT_GLASS = MAT_GLASS","","-- Hithroup Enumeration","trace_library.HITGROUP_GENERIC = HITGROUP_GENERIC","trace_library.HITGROUP_HEAD = HITGROUP_HEAD","trace_library.HITGROUP_CHEST = HITGROUP_CHEST","trace_library.HITGROUP_STOMACH = HITGROUP_STOMACH","trace_library.HITGROUP_LEFTARM = HITGROUP_LEFTARM","trace_library.HITGROUP_RIGHTARM = HITGROUP_RIGHTARM","trace_library.HITGROUP_LEFTLEG = HITGROUP_LEFTLEG","trace_library.HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG","trace_library.HITGROUP_GEAR = HITGROUP_GEAR","","-- Mask Enumerations","trace_library.MASK_SPLITAREAPORTAL = MASK_SPLITAREAPORTAL","trace_library.MASK_SOLID_BRUSHONLY = MASK_SOLID_BRUSHONLY","trace_library.MASK_WATER = MASK_WATER","trace_library.MASK_BLOCKLOS = MASK_BLOCKLOS","trace_library.MASK_OPAQUE = MASK_OPAQUE","trace_library.MASK_VISIBLE = MASK_VISIBLE","trace_library.MASK_DEADSOLID = MASK_DEADSOLID","trace_library.MASK_PLAYERSOLID_BRUSHONLY = MASK_PLAYERSOLID_BRUSHONLY","trace_library.MASK_NPCWORLDSTATIC = MASK_NPCWORLDSTATIC","trace_library.MASK_NPCSOLID_BRUSHONLY = MASK_NPCSOLID_BRUSHONLY","trace_library.MASK_CURRENT = MASK_CURRENT","trace_library.MASK_SHOT_PORTAL = MASK_SHOT_PORTAL","trace_library.MASK_SOLID = MASK_SOLID","trace_library.MASK_BLOCKLOS_AND_NPCS = MASK_BLOCKLOS_AND_NPCS","trace_library.MASK_OPAQUE_AND_NPCS = MASK_OPAQUE_AND_NPCS","trace_library.MASK_VISIBLE_AND_NPCS = MASK_VISIBLE_AND_NPCS","trace_library.MASK_PLAYERSOLID = MASK_PLAYERSOLID","trace_library.MASK_NPCSOLID = MASK_NPCSOLID","trace_library.MASK_SHOT_HULL = MASK_SHOT_HULL","trace_library.MASK_SHOT = MASK_SHOT","trace_library.MASK_ALL = MASK_ALL","","-- Content Enumerations","trace_library.CONTENTS_EMPTY = CONTENTS_EMPTY","trace_library.CONTENTS_SOLID = CONTENTS_SOLID","trace_library.CONTENTS_WINDOW = CONTENTS_WINDOW","trace_library.CONTENTS_AUX = CONTENTS_AUX","trace_library.CONTENTS_GRATE = CONTENTS_GRATE","trace_library.CONTENTS_SLIME = CONTENTS_SLIME","trace_library.CONTENTS_WATER = CONTENTS_WATER","trace_library.CONTENTS_BLOCKLOS = CONTENTS_BLOCKLOS","trace_library.CONTENTS_OPAQUE = CONTENTS_OPAQUE","trace_library.CONTENTS_TESTFOGVOLUME = CONTENTS_TESTFOGVOLUME","trace_library.CONTENTS_TEAM4 = CONTENTS_TEAM4","trace_library.CONTENTS_TEAM3 = CONTENTS_TEAM3","trace_library.CONTENTS_TEAM1 = CONTENTS_TEAM1","trace_library.CONTENTS_TEAM2 = CONTENTS_TEAM2","trace_library.CONTENTS_IGNORE_NODRAW_OPAQUE = CONTENTS_IGNORE_NODRAW_OPAQUE","trace_library.CONTENTS_MOVEABLE = CONTENTS_MOVEABLE","trace_library.CONTENTS_AREAPORTAL = CONTENTS_AREAPORTAL","trace_library.CONTENTS_PLAYERCLIP = CONTENTS_PLAYERCLIP","trace_library.CONTENTS_MONSTERCLIP = CONTENTS_MONSTERCLIP","trace_library.CONTENTS_CURRENT_0 = CONTENTS_CURRENT_0","trace_library.CONTENTS_CURRENT_90 = CONTENTS_CURRENT_90","trace_library.CONTENTS_CURRENT_180 = CONTENTS_CURRENT_180","trace_library.CONTENTS_CURRENT_270 = CONTENTS_CURRENT_270","trace_library.CONTENTS_CURRENT_UP = CONTENTS_CURRENT_UP","trace_library.CONTENTS_CURRENT_DOWN = CONTENTS_CURRENT_DOWN","trace_library.CONTENTS_ORIGIN = CONTENTS_ORIGIN","trace_library.CONTENTS_MONSTER = CONTENTS_MONSTER","trace_library.CONTENTS_DEBRIS = CONTENTS_DEBRIS","trace_library.CONTENTS_DETAIL = CONTENTS_DETAIL","trace_library.CONTENTS_TRANSLUCENT = CONTENTS_TRANSLUCENT","trace_library.CONTENTS_LADDER = CONTENTS_LADDER","trace_library.CONTENTS_HITBOX = CONTENTS_HITBOX","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"trace\", \"Trace\", \"Allows the user to start traces\" )","end","","-- Local functions","","local wrap","local unwrap","","local function postload()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","end","SF.Libraries.AddHook(\"postload\",postload)","","local function convertFilter(filter)","\tlocal unwrapped = unwrap(filter)","\tif unwrapped then","\t\treturn {unwrapped}","\telse","\t\tlocal l = {}","\t\tlocal count = 1","\t\tfor i=1,#filter do","\t\t\tlocal unwrapped = unwrap(filter[i])","\t\t\tif unwrapped then","\t\t\t\tl[count] = unwrapped","\t\t\t\tcount = count + 1","\t\t\tend","\t\tend","\t\treturn l","\tend","end",""],"fields":[],"name":"trace","client":true,"description":"\nProvides functions for doing line/AABB traces","libtbl":"trace_library","tables":[],"server":true}},"type":"file","name":"libs_sh/trace.lua","functions":{"1":"trace_library.trace","2":"trace_library.traceHull","trace_library.trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\tlocal data = util.TraceLine( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","endpos":"End position"}},"trace_library.traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\tlocal data = util.TraceHull( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Trace library","-------------------------------------------------------------------------------"],"code":["","local dgetmeta = debug.getmetatable","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Here's a neat little script to convert enumerations wiki.gmod.com-style","-- into something usable in code","","local lines = <copy+paste enumeration with trailing \\n here>","","for line in lines:gmatch(\"([^\\n]*)\\n\") do"," local v = line:match(\"^.*|%s*(.*)$\")"," print(\"trace_library.\"..v..\" = \"..v)","end","]]",""],"summary":"\n \nTrace library \n ","description":"\n \nTrace library \n","param":[]},{"comment":["--- Provides functions for doing line/AABB traces","-- @shared","-- @field MAT_ANTLION","-- @field MAT_BLOODYFLESH","-- @field MAT_CONCRETE","-- @field MAT_DIRT","-- @field MAT_FLESH","-- @field MAT_GRATE","-- @field MAT_ALIENFLESH","-- @field MAT_CLIP","-- @field MAT_PLASTIC","-- @field MAT_METAL","-- @field MAT_SAND","-- @field MAT_FOLIAGE","-- @field MAT_COMPUTER","-- @field MAT_SLOSH","-- @field MAT_TILE","-- @field MAT_VENT","-- @field MAT_WOOD","-- @field MAT_GLASS","-- @field HITGROUP_GENERIC","-- @field HITGROUP_HEAD","-- @field HITGROUP_CHEST","-- @field HITGROUP_STOMACH","-- @field HITGROUP_LEFTARM","-- @field HITGROUP_RIGHTARM","-- @field HITGROUP_LEFTLEG","-- @field HITGROUP_RIGHTLEG","-- @field HITGROUP_GEAR","-- @field MASK_SPLITAREAPORTAL","-- @field MASK_SOLID_BRUSHONLY","-- @field MASK_WATER","-- @field MASK_BLOCKLOS","-- @field MASK_OPAQUE","-- @field MASK_VISIBLE","-- @field MASK_DEADSOLID","-- @field MASK_PLAYERSOLID_BRUSHONLY","-- @field MASK_NPCWORLDSTATIC","-- @field MASK_NPCSOLID_BRUSHONLY","-- @field MASK_CURRENT","-- @field MASK_SHOT_PORTAL","-- @field MASK_SOLID","-- @field MASK_BLOCKLOS_AND_NPCS","-- @field MASK_OPAQUE_AND_NPCS","-- @field MASK_VISIBLE_AND_NPCS","-- @field MASK_PLAYERSOLID","-- @field MASK_NPCSOLID","-- @field MASK_SHOT_HULL","-- @field MASK_SHOT","-- @field MASK_ALL","-- @field CONTENTS_EMPTY","-- @field CONTENTS_SOLID","-- @field CONTENTS_WINDOW","-- @field CONTENTS_AUX","-- @field CONTENTS_GRATE","-- @field CONTENTS_SLIME","-- @field CONTENTS_WATER","-- @field CONTENTS_BLOCKLOS","-- @field CONTENTS_OPAQUE","-- @field CONTENTS_TESTFOGVOLUME","-- @field CONTENTS_TEAM4","-- @field CONTENTS_TEAM3","-- @field CONTENTS_TEAM1","-- @field CONTENTS_TEAM2","-- @field CONTENTS_IGNORE_NODRAW_OPAQUE","-- @field CONTENTS_MOVEABLE","-- @field CONTENTS_AREAPORTAL","-- @field CONTENTS_PLAYERCLIP","-- @field CONTENTS_MONSTERCLIP","-- @field CONTENTS_CURRENT_0","-- @field CONTENTS_CURRENT_90","-- @field CONTENTS_CURRENT_180","-- @field CONTENTS_CURRENT_270","-- @field CONTENTS_CURRENT_UP","-- @field CONTENTS_CURRENT_DOWN","-- @field CONTENTS_ORIGIN","-- @field CONTENTS_MONSTER","-- @field CONTENTS_DEBRIS","-- @field CONTENTS_DETAIL","-- @field CONTENTS_TRANSLUCENT","-- @field CONTENTS_LADDER","-- @field CONTENTS_HITBOX"],"functions":{"1":"trace","2":"traceHull","traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\tlocal data = util.TraceHull( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}},"trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\tlocal data = util.TraceLine( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","endpos":"End position"}}},"class":"library","summary":"\nProvides functions for doing line/AABB traces ","field":{"1":"MAT_ANTLION","2":"MAT_BLOODYFLESH","3":"MAT_CONCRETE","4":"MAT_DIRT","5":"MAT_FLESH","6":"MAT_GRATE","7":"MAT_ALIENFLESH","8":"MAT_CLIP","9":"MAT_PLASTIC","10":"MAT_METAL","11":"MAT_SAND","12":"MAT_FOLIAGE","13":"MAT_COMPUTER","14":"MAT_SLOSH","15":"MAT_TILE","16":"MAT_VENT","17":"MAT_WOOD","18":"MAT_GLASS","19":"HITGROUP_GENERIC","20":"HITGROUP_HEAD","21":"HITGROUP_CHEST","22":"HITGROUP_STOMACH","23":"HITGROUP_LEFTARM","24":"HITGROUP_RIGHTARM","25":"HITGROUP_LEFTLEG","26":"HITGROUP_RIGHTLEG","27":"HITGROUP_GEAR","28":"MASK_SPLITAREAPORTAL","29":"MASK_SOLID_BRUSHONLY","30":"MASK_WATER","31":"MASK_BLOCKLOS","32":"MASK_OPAQUE","33":"MASK_VISIBLE","34":"MASK_DEADSOLID","35":"MASK_PLAYERSOLID_BRUSHONLY","36":"MASK_NPCWORLDSTATIC","37":"MASK_NPCSOLID_BRUSHONLY","38":"MASK_CURRENT","39":"MASK_SHOT_PORTAL","40":"MASK_SOLID","41":"MASK_BLOCKLOS_AND_NPCS","42":"MASK_OPAQUE_AND_NPCS","43":"MASK_VISIBLE_AND_NPCS","44":"MASK_PLAYERSOLID","45":"MASK_NPCSOLID","46":"MASK_SHOT_HULL","47":"MASK_SHOT","48":"MASK_ALL","49":"CONTENTS_EMPTY","50":"CONTENTS_SOLID","51":"CONTENTS_WINDOW","52":"CONTENTS_AUX","53":"CONTENTS_GRATE","54":"CONTENTS_SLIME","55":"CONTENTS_WATER","56":"CONTENTS_BLOCKLOS","57":"CONTENTS_OPAQUE","58":"CONTENTS_TESTFOGVOLUME","59":"CONTENTS_TEAM4","60":"CONTENTS_TEAM3","61":"CONTENTS_TEAM1","62":"CONTENTS_TEAM2","63":"CONTENTS_IGNORE_NODRAW_OPAQUE","64":"CONTENTS_MOVEABLE","65":"CONTENTS_AREAPORTAL","66":"CONTENTS_PLAYERCLIP","67":"CONTENTS_MONSTERCLIP","68":"CONTENTS_CURRENT_0","69":"CONTENTS_CURRENT_90","70":"CONTENTS_CURRENT_180","71":"CONTENTS_CURRENT_270","72":"CONTENTS_CURRENT_UP","73":"CONTENTS_CURRENT_DOWN","74":"CONTENTS_ORIGIN","75":"CONTENTS_MONSTER","76":"CONTENTS_DEBRIS","77":"CONTENTS_DETAIL","78":"CONTENTS_TRANSLUCENT","79":"CONTENTS_LADDER","80":"CONTENTS_HITBOX","MASK_DEADSOLID":"","MASK_BLOCKLOS":"","CONTENTS_EMPTY":"","MASK_OPAQUE":"","CONTENTS_IGNORE_NODRAW_OPAQUE":"","MASK_VISIBLE":"","HITGROUP_LEFTLEG":"","MASK_PLAYERSOLID_BRUSHONLY":"","HITGROUP_RIGHTARM":"","CONTENTS_CURRENT_DOWN":"","CONTENTS_OPAQUE":"","MAT_TILE":"","MAT_FOLIAGE":"","HITGROUP_HEAD":"","MASK_SHOT":"","MAT_COMPUTER":"","CONTENTS_TEAM3":"","MASK_SPLITAREAPORTAL":"","CONTENTS_CURRENT_UP":"","MAT_CONCRETE":"","MAT_CLIP":"","MAT_WOOD":"","MAT_ANTLION":"","MASK_NPCSOLID_BRUSHONLY":"","CONTENTS_DEBRIS":"","MASK_SHOT_PORTAL":"","HITGROUP_STOMACH":"","MAT_SLOSH":"","CONTENTS_PLAYERCLIP":"","MASK_NPCWORLDSTATIC":"","MASK_OPAQUE_AND_NPCS":"","MAT_BLOODYFLESH":"","MASK_BLOCKLOS_AND_NPCS":"","CONTENTS_TEAM1":"","HITGROUP_CHEST":"","CONTENTS_AREAPORTAL":"","HITGROUP_GENERIC":"","MAT_METAL":"","HITGROUP_GEAR":"","MAT_VENT":"","MAT_PLASTIC":"","CONTENTS_CURRENT_180":"","MAT_ALIENFLESH":"","MAT_FLESH":"","MAT_GLASS":"","CONTENTS_HITBOX":"","CONTENTS_LADDER":"","CONTENTS_MONSTER":"","CONTENTS_ORIGIN":"","CONTENTS_TEAM2":"","CONTENTS_DETAIL":"","CONTENTS_GRATE":"","MASK_NPCSOLID":"","CONTENTS_MOVEABLE":"","CONTENTS_TRANSLUCENT":"","CONTENTS_CURRENT_270":"","MASK_VISIBLE_AND_NPCS":"","CONTENTS_SOLID":"","CONTENTS_MONSTERCLIP":"","MAT_SAND":"","CONTENTS_SLIME":"","CONTENTS_CURRENT_0":"","CONTENTS_WINDOW":"","MASK_PLAYERSOLID":"","MASK_ALL":"","CONTENTS_BLOCKLOS":"","MASK_WATER":"","MASK_SOLID_BRUSHONLY":"","HITGROUP_RIGHTLEG":"","CONTENTS_CURRENT_90":"","CONTENTS_AUX":"","MASK_CURRENT":"","MAT_DIRT":"","CONTENTS_TEAM4":"","CONTENTS_TESTFOGVOLUME":"","CONTENTS_WATER":"","MASK_SOLID":"","MASK_SHOT_HULL":"","HITGROUP_LEFTARM":"","MAT_GRATE":""},"code":["local trace_library, _ = SF.Libraries.Register(\"trace\")","","-- Material Enumeration","trace_library.MAT_ANTLION = MAT_ANTLION","trace_library.MAT_BLOODYFLESH = MAT_BLOODYFLESH","trace_library.MAT_CONCRETE = MAT_CONCRETE","trace_library.MAT_DIRT = MAT_DIRT","trace_library.MAT_FLESH = MAT_FLESH","trace_library.MAT_GRATE = MAT_GRATE","trace_library.MAT_ALIENFLESH = MAT_ALIENFLESH","trace_library.MAT_CLIP = MAT_CLIP","trace_library.MAT_PLASTIC = MAT_PLASTIC","trace_library.MAT_METAL = MAT_METAL","trace_library.MAT_SAND = MAT_SAND","trace_library.MAT_FOLIAGE = MAT_FOLIAGE","trace_library.MAT_COMPUTER = MAT_COMPUTER","trace_library.MAT_SLOSH = MAT_SLOSH","trace_library.MAT_TILE = MAT_TILE","trace_library.MAT_VENT = MAT_VENT","trace_library.MAT_WOOD = MAT_WOOD","trace_library.MAT_GLASS = MAT_GLASS","","-- Hithroup Enumeration","trace_library.HITGROUP_GENERIC = HITGROUP_GENERIC","trace_library.HITGROUP_HEAD = HITGROUP_HEAD","trace_library.HITGROUP_CHEST = HITGROUP_CHEST","trace_library.HITGROUP_STOMACH = HITGROUP_STOMACH","trace_library.HITGROUP_LEFTARM = HITGROUP_LEFTARM","trace_library.HITGROUP_RIGHTARM = HITGROUP_RIGHTARM","trace_library.HITGROUP_LEFTLEG = HITGROUP_LEFTLEG","trace_library.HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG","trace_library.HITGROUP_GEAR = HITGROUP_GEAR","","-- Mask Enumerations","trace_library.MASK_SPLITAREAPORTAL = MASK_SPLITAREAPORTAL","trace_library.MASK_SOLID_BRUSHONLY = MASK_SOLID_BRUSHONLY","trace_library.MASK_WATER = MASK_WATER","trace_library.MASK_BLOCKLOS = MASK_BLOCKLOS","trace_library.MASK_OPAQUE = MASK_OPAQUE","trace_library.MASK_VISIBLE = MASK_VISIBLE","trace_library.MASK_DEADSOLID = MASK_DEADSOLID","trace_library.MASK_PLAYERSOLID_BRUSHONLY = MASK_PLAYERSOLID_BRUSHONLY","trace_library.MASK_NPCWORLDSTATIC = MASK_NPCWORLDSTATIC","trace_library.MASK_NPCSOLID_BRUSHONLY = MASK_NPCSOLID_BRUSHONLY","trace_library.MASK_CURRENT = MASK_CURRENT","trace_library.MASK_SHOT_PORTAL = MASK_SHOT_PORTAL","trace_library.MASK_SOLID = MASK_SOLID","trace_library.MASK_BLOCKLOS_AND_NPCS = MASK_BLOCKLOS_AND_NPCS","trace_library.MASK_OPAQUE_AND_NPCS = MASK_OPAQUE_AND_NPCS","trace_library.MASK_VISIBLE_AND_NPCS = MASK_VISIBLE_AND_NPCS","trace_library.MASK_PLAYERSOLID = MASK_PLAYERSOLID","trace_library.MASK_NPCSOLID = MASK_NPCSOLID","trace_library.MASK_SHOT_HULL = MASK_SHOT_HULL","trace_library.MASK_SHOT = MASK_SHOT","trace_library.MASK_ALL = MASK_ALL","","-- Content Enumerations","trace_library.CONTENTS_EMPTY = CONTENTS_EMPTY","trace_library.CONTENTS_SOLID = CONTENTS_SOLID","trace_library.CONTENTS_WINDOW = CONTENTS_WINDOW","trace_library.CONTENTS_AUX = CONTENTS_AUX","trace_library.CONTENTS_GRATE = CONTENTS_GRATE","trace_library.CONTENTS_SLIME = CONTENTS_SLIME","trace_library.CONTENTS_WATER = CONTENTS_WATER","trace_library.CONTENTS_BLOCKLOS = CONTENTS_BLOCKLOS","trace_library.CONTENTS_OPAQUE = CONTENTS_OPAQUE","trace_library.CONTENTS_TESTFOGVOLUME = CONTENTS_TESTFOGVOLUME","trace_library.CONTENTS_TEAM4 = CONTENTS_TEAM4","trace_library.CONTENTS_TEAM3 = CONTENTS_TEAM3","trace_library.CONTENTS_TEAM1 = CONTENTS_TEAM1","trace_library.CONTENTS_TEAM2 = CONTENTS_TEAM2","trace_library.CONTENTS_IGNORE_NODRAW_OPAQUE = CONTENTS_IGNORE_NODRAW_OPAQUE","trace_library.CONTENTS_MOVEABLE = CONTENTS_MOVEABLE","trace_library.CONTENTS_AREAPORTAL = CONTENTS_AREAPORTAL","trace_library.CONTENTS_PLAYERCLIP = CONTENTS_PLAYERCLIP","trace_library.CONTENTS_MONSTERCLIP = CONTENTS_MONSTERCLIP","trace_library.CONTENTS_CURRENT_0 = CONTENTS_CURRENT_0","trace_library.CONTENTS_CURRENT_90 = CONTENTS_CURRENT_90","trace_library.CONTENTS_CURRENT_180 = CONTENTS_CURRENT_180","trace_library.CONTENTS_CURRENT_270 = CONTENTS_CURRENT_270","trace_library.CONTENTS_CURRENT_UP = CONTENTS_CURRENT_UP","trace_library.CONTENTS_CURRENT_DOWN = CONTENTS_CURRENT_DOWN","trace_library.CONTENTS_ORIGIN = CONTENTS_ORIGIN","trace_library.CONTENTS_MONSTER = CONTENTS_MONSTER","trace_library.CONTENTS_DEBRIS = CONTENTS_DEBRIS","trace_library.CONTENTS_DETAIL = CONTENTS_DETAIL","trace_library.CONTENTS_TRANSLUCENT = CONTENTS_TRANSLUCENT","trace_library.CONTENTS_LADDER = CONTENTS_LADDER","trace_library.CONTENTS_HITBOX = CONTENTS_HITBOX","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"trace\", \"Trace\", \"Allows the user to start traces\" )","end","","-- Local functions","","local wrap","local unwrap","","local function postload()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","end","SF.Libraries.AddHook(\"postload\",postload)","","local function convertFilter(filter)","\tlocal unwrapped = unwrap(filter)","\tif unwrapped then","\t\treturn {unwrapped}","\telse","\t\tlocal l = {}","\t\tlocal count = 1","\t\tfor i=1,#filter do","\t\t\tlocal unwrapped = unwrap(filter[i])","\t\t\tif unwrapped then","\t\t\t\tl[count] = unwrapped","\t\t\t\tcount = count + 1","\t\t\tend","\t\tend","\t\treturn l","\tend","end",""],"fields":[],"name":"trace","client":true,"description":"\nProvides functions for doing line/AABB traces","libtbl":"trace_library","tables":[],"server":true},{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\tlocal data = util.TraceLine( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","endpos":"End position"}},{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter, or a function callback with an entity arguement","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tif type(filter) == \"function\" then","\t\tlocal filterfunc = filter","\t\tfilter = function(ent)","\t\t\tlocal ok, msg, traceback = SF.instance:runFunction( filterfunc, SF.WrapObject( ent ) )","\t\t\tif not ok then","\t\t\t\tSF.instance:Error( \"Trace filter callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\telse","\t\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tend","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\tlocal data = util.TraceHull( trace )","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn SF.WrapObject( data[k] )","\t\tend","\t})","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter, or a function callback with an entity arguement","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}}],"tables":[],"description":"\n \nTrace library \n","summary":"\n \nTrace library \n "},"libs_sh/vmatrix.lua":{"libraries":[],"type":"file","name":"libs_sh/vmatrix.lua","functions":{"1":"SF.DefaultEnvironment.Matrix","2":"vmatrix_metamethods:__tostring","3":"vmatrix_methods:getAngles","4":"vmatrix_methods:getInverse","5":"vmatrix_methods:getInverseTR","6":"vmatrix_methods:getScale","7":"vmatrix_methods:getTranslation","8":"vmatrix_methods:rotate","9":"vmatrix_methods:scale","10":"vmatrix_methods:scaleTranslation","11":"vmatrix_methods:setAngles","12":"vmatrix_methods:setTranslation","13":"vmatrix_methods:translate","vmatrix_methods:rotate":{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:Rotate( aunwrap( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},"vmatrix_methods:getTranslation":{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn vwrap( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},"vmatrix_methods:translate":{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\tSF.CheckType( lhs, vmatrix_metamethods )","\tlocal rhsmeta = dgetmeta( rhs )","\tif rhsmeta == vmatrix_metamethods then","\t\treturn wrap( unwrap( lhs ) * unwrap( rhs ) )","\telseif rhsmeta == vec_meta then","\t\treturn vwrap( unwrap( lhs ) * vunwrap( rhs ) )","\telse","\t\tSF.throw(\"Matrix must be multiplied with another matrix or vector on right hand side\",2)","\tend","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}},"vmatrix_methods:scale":{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},"vmatrix_methods:getAngles":{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn awrap( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},"vmatrix_methods:setTranslation":{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},"vmatrix_methods:setAngles":{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},"vmatrix_methods:scaleTranslation":{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}},"vmatrix_metamethods:__tostring":{"ret":"string representing the matrix.","comment":["--- tostring metamethod","-- @return string representing the matrix."],"code":["function vmatrix_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"vmatrix_metamethods:__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":[]},"vmatrix_methods:getScale":{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn vwrap( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},"SF.DefaultEnvironment.Matrix":{"ret":"New VMatrix","comment":["--- Returns a new VMatrix","-- @return New VMatrix"],"code":["SF.DefaultEnvironment.Matrix = function ()","\treturn wrap( Matrix() )","end",""],"class":"function","name":"SF.DefaultEnvironment.Matrix","private":false,"summary":"\nReturns a new VMatrix ","description":"\nReturns a new VMatrix","param":[]},"vmatrix_methods:getInverse":{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},"vmatrix_methods:getInverseTR":{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]}},"doc":[{"comment":["--- VMatrix type"],"code":["local vmatrix_methods, vmatrix_metamethods = SF.Typedef( \"VMatrix\" )","local wrap, unwrap = SF.CreateWrapper( vmatrix_metamethods, true, false, debug.getregistry().VMatrix )","local vec_meta, vwrap, vunwrap, ang_meta, awrap, aunwrap","","SF.Libraries.AddHook(\"postload\", function()","\tvec_meta = SF.Vectors.Metatable","\tvwrap = SF.Vectors.Wrap","\tvunwrap = SF.Vectors.Unwrap","\t","\tang_meta = SF.Angles.Metatable","\tawrap = SF.Angles.Wrap","\taunwrap = SF.Angles.Unwrap","end)","","SF.VMatrix.Methods = vmatrix_methods","SF.VMatrix.Metatable = vmatrix_metamethods","SF.VMatrix.Wrap = wrap","SF.VMatrix.Unwrap = unwrap","","local dgetmeta = debug.getmetatable",""],"typtbl":"vmatrix_methods","fields":[],"name":"VMatrix","summary":"\nVMatrix type ","description":"\nVMatrix type","class":"class","methods":{"1":"getAngles","2":"getInverse","3":"getInverseTR","4":"getScale","5":"getTranslation","6":"rotate","7":"scale","8":"scaleTranslation","9":"setAngles","10":"setTranslation","11":"translate","scale":{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},"getScale":{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn vwrap( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},"getAngles":{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn awrap( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},"translate":{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\tSF.CheckType( lhs, vmatrix_metamethods )","\tlocal rhsmeta = dgetmeta( rhs )","\tif rhsmeta == vmatrix_metamethods then","\t\treturn wrap( unwrap( lhs ) * unwrap( rhs ) )","\telseif rhsmeta == vec_meta then","\t\treturn vwrap( unwrap( lhs ) * vunwrap( rhs ) )","\telse","\t\tSF.throw(\"Matrix must be multiplied with another matrix or vector on right hand side\",2)","\tend","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}},"getTranslation":{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn vwrap( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},"setTranslation":{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},"getInverse":{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},"setAngles":{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},"rotate":{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:Rotate( aunwrap( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},"getInverseTR":{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]},"scaleTranslation":{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}}}},{"ret":"New VMatrix","comment":["--- Returns a new VMatrix","-- @return New VMatrix"],"code":["SF.DefaultEnvironment.Matrix = function ()","\treturn wrap( Matrix() )","end",""],"class":"function","name":"SF.DefaultEnvironment.Matrix","private":false,"summary":"\nReturns a new VMatrix ","description":"\nReturns a new VMatrix","param":[]},{"ret":"string representing the matrix.","comment":["--- tostring metamethod","-- @return string representing the matrix."],"code":["function vmatrix_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"vmatrix_metamethods:__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":[]},{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn awrap( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn vwrap( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn vwrap( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:Rotate( aunwrap( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]},{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}},{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\tSF.CheckType( lhs, vmatrix_metamethods )","\tlocal rhsmeta = dgetmeta( rhs )","\tif rhsmeta == vmatrix_metamethods then","\t\treturn wrap( unwrap( lhs ) * unwrap( rhs ) )","\telseif rhsmeta == vec_meta then","\t\treturn vwrap( unwrap( lhs ) * vunwrap( rhs ) )","\telse","\t\tSF.throw(\"Matrix must be multiplied with another matrix or vector on right hand side\",2)","\tend","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}}],"tables":[],"description":"\nVMatrix type","summary":"\nVMatrix type "},"libs_sh/net.lua":{"libraries":{"1":"net","net":{"comment":["--- Net message library. Used for sending data from the server to the client and back"],"functions":{"1":"getBytesLeft","2":"readAngle","3":"readBit","4":"readColor","5":"readData","6":"readDouble","7":"readEntity","8":"readFloat","9":"readInt","10":"readMatrix","11":"readStream","12":"readString","13":"readUInt","14":"readVector","15":"send","16":"start","17":"writeAngle","18":"writeBit","19":"writeColor","20":"writeData","21":"writeDouble","22":"writeEntity","23":"writeFloat","24":"writeInt","25":"writeMatrix","26":"writeStream","27":"writeString","28":"writeUInt","29":"writeVector","writeVector":{"comment":["--- Writes an vector to the net message","-- @shared","-- @param t The vector to be written"],"code":["","function net_library.writeVector( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Vector\"] )","","\twrite( instance, \"Vector\", 12, SF.Vectors.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an vector to the net message ","library":"net","name":"net_library.writeVector","server":true,"private":false,"client":true,"description":"\nWrites an vector to the net message","param":{"1":"t","t":"The vector to be written"}},"readColor":{"ret":"The color that was read","comment":["--- Reads a color from the net message","-- @shared","-- @return The color that was read"],"code":["","function net_library.readColor()","\treturn SF.Color.Wrap( net.ReadColor() )","end",""],"class":"function","summary":"\nReads a color from the net message ","library":"net","name":"net_library.readColor","server":true,"private":false,"client":true,"description":"\nReads a color from the net message","param":[]},"readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tif not instance.data.net.burst:use( instance.data.net.size ) then","\t\tSF.throw( \"Net message exceeds limit!\", 3 )","\tend","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tnet[ data[ i ][ 1 ] ]( unpack( data[ i ][ 2 ] ) )","\tend","","\tif SERVER then","\t\tlocal sendfunc, newtarget","","\t\tif target then","\t\t\tif target[1] then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tlocal pl = SF.Entities.Unwrap( target[ i ] )","\t\t\t\t\tif IsValid( pl ) and pl:IsPlayer() then","\t\t\t\t\t\tnt[ #nt + 1 ] = pl","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\t\tif not IsValid( newtarget ) or not newtarget:IsPlayer() then SF.throw( \"Invalid player\", 2 ) end","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","","\tinstance.data.net.size = 0","\tinstance.data.net.data = {}","\tinstance.data.net.started = false","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"writeAngle":{"comment":["--- Writes an angle to the net message","-- @shared","-- @param t The angle to be written"],"code":["","function net_library.writeAngle( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Angle\"] )","","\twrite( instance, \"Angle\", 12, SF.Angles.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an angle to the net message ","library":"net","name":"net_library.writeAngle","server":true,"private":false,"client":true,"description":"\nWrites an angle to the net message","param":{"1":"t","t":"The angle to be written"}},"writeStream":{"comment":["--- Streams a large 20MB string. ","-- @shared","-- @param str The string to be written"],"code":["function net_library.writeStream( str )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( str, \"string\" )","\twrite( instance, \"Stream\", 8, str )","\treturn true","end",""],"class":"function","summary":"\nStreams a large 20MB string.","library":"net","name":"net_library.writeStream","server":true,"private":false,"client":true,"description":"\nStreams a large 20MB string.","param":{"1":"str","str":"The string to be written"}},"readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", 1, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"writeMatrix":{"comment":["--- Writes an matrix to the net message","-- @shared","-- @param t The matrix to be written"],"code":["","function net_library.writeMatrix( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"VMatrix\"] )","","\twrite( instance, \"Matrix\", 64, SF.VMatrix.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an matrix to the net message ","library":"net","name":"net_library.writeMatrix","server":true,"private":false,"client":true,"description":"\nWrites an matrix to the net message","param":{"1":"t","t":"The matrix to be written"}},"readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"getBytesLeft":{"ret":"number of bytes that can be sent","comment":["--- Returns available bandwidth in bytes","-- @return number of bytes that can be sent"],"code":["function net_library.getBytesLeft()","\treturn SF.instance.data.net.burst:check() - SF.instance.data.net.size","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tif ent.instance then","\t\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\t\tend","\tend","end)",""],"class":"function","name":"net_library.getBytesLeft","summary":"\nReturns available bandwidth in bytes ","private":false,"library":"net","description":"\nReturns available bandwidth in bytes","param":[]},"readEntity":{"ret":"The entity that was read","comment":["--- Reads a entity from the net message","-- @shared","-- @return The entity that was read"],"code":["","function net_library.readEntity()","\treturn SF.WrapObject( net.ReadEntity() )","end",""],"class":"function","summary":"\nReads a entity from the net message ","library":"net","name":"net_library.readEntity","server":true,"private":false,"client":true,"description":"\nReads a entity from the net message","param":[]},"writeEntity":{"comment":["--- Writes an entity to the net message","-- @shared","-- @param t The entity to be written"],"code":["","function net_library.writeEntity( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Entity\"] )","","\twrite( instance, \"Entity\", 2, SF.UnwrapObject( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an entity to the net message ","library":"net","name":"net_library.writeEntity","server":true,"private":false,"client":true,"description":"\nWrites an entity to the net message","param":{"1":"t","t":"The entity to be written"}},"readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},"writeColor":{"comment":["--- Writes an color to the net message","-- @shared","-- @param t The color to be written"],"code":["","function net_library.writeColor( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Color\"] )","","\twrite( instance, \"Color\", 4, SF.Color.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an color to the net message ","library":"net","name":"net_library.writeColor","server":true,"private":false,"client":true,"description":"\nWrites an color to the net message","param":{"1":"t","t":"The color to be written"}},"readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"readVector":{"ret":"The vector that was read","comment":["--- Reads a vector from the net message","-- @shared","-- @return The vector that was read"],"code":["","function net_library.readVector()","\treturn SF.Vectors.Wrap( net.ReadVector() )","end",""],"class":"function","summary":"\nReads a vector from the net message ","library":"net","name":"net_library.readVector","server":true,"private":false,"client":true,"description":"\nReads a vector from the net message","param":[]},"readStream":{"comment":["--- Reads a large string stream from the net message","-- @shared","-- @param cb Callback to run when the stream is finished. The first parameter in the callback is the data."],"code":["","function net_library.readStream( cb )","\tSF.CheckType( cb, \"function\" )","\tlocal instance = SF.instance","\tif streams[instance.player] then SF.throw( \"The previous stream must finish before reading another.\", 2 ) end","\tstreams[instance.player] = true","\t","\tnet.ReadStream( ( SERVER and instance.player or nil ), function( data )","\t\tlocal ok, msg, traceback = instance:runFunction( cb, data )","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\t\tstreams[instance.player] = false","\tend )","end",""],"class":"function","summary":"\nReads a large string stream from the net message ","library":"net","name":"net_library.readStream","server":true,"private":false,"client":true,"description":"\nReads a large string stream from the net message","param":{"1":"cb","cb":"Callback to run when the stream is finished. The first parameter in the callback is the data."}},"writeString":{"comment":["--- Writes a string to the net message. Null characters will terminate the string.","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", #t, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message.","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message. Null characters will terminate the string.","param":{"1":"t","t":"The string to be written"}},"readAngle":{"ret":"The angle that was read","comment":["--- Reads an angle from the net message","-- @shared","-- @return The angle that was read"],"code":["","function net_library.readAngle()","\treturn SF.Angles.Wrap( net.ReadAngle() )","end",""],"class":"function","summary":"\nReads an angle from the net message ","library":"net","name":"net_library.readAngle","server":true,"private":false,"client":true,"description":"\nReads an angle from the net message","param":[]},"writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", 4, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}},"writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", 8, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.started then SF.throw( \"net message was already started\", 2 ) end","","\tinstance.data.net.started = true","\tinstance.data.net.size = 8 -- 8 bytes overhead","\tinstance.data.net.data = {}","","\twrite( instance, \"String\", #name, name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"writeData":{"comment":["--- Writes string containing null characters to the net message","-- @shared","-- @param t The string to be written","-- @param n How much of the string to write"],"code":["","function net_library.writeData( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Data\", n, t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites string containing null characters to the net message ","library":"net","name":"net_library.writeData","server":true,"private":false,"client":true,"description":"\nWrites string containing null characters to the net message","param":{"1":"t","2":"n","n":"How much of the string to write","t":"The string to be written"}},"readData":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @param n How many characters are in the data","-- @return The string that was read"],"code":["","function net_library.readData( n )","\tSF.CheckType( n, \"number\" )","\tn = math.Clamp( n, 0, 64000 )","\treturn net.ReadData( n )","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readData","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":{"1":"n","n":"How many characters are in the data"}},"readMatrix":{"ret":"The matrix that was read","comment":["--- Reads a matrix from the net message","-- @shared","-- @return The matrix that was read"],"code":["","function net_library.readMatrix()","\treturn SF.VMatrix.Wrap( net.ReadMatrix() )","end",""],"class":"function","summary":"\nReads a matrix from the net message ","library":"net","name":"net_library.readMatrix","server":true,"private":false,"client":true,"description":"\nReads a matrix from the net message","param":[]}},"class":"library","fields":[],"name":"net","summary":"\nNet message library.","description":"\nNet message library. Used for sending data from the server to the client and back","libtbl":"net_library","tables":[],"code":["local net_library, _ = SF.Libraries.Register(\"net\")","","local burst_limit = CreateConVar( \"sf_net_burstmax\", \"10\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\"The net message burst limit in kB.\" )","","local burst_rate = CreateConVar( \"sf_net_burstrate\", \"5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\t\"Regen rate of net message burst in kB/sec.\" )","","","local streams = SF.EntityTable(\"playerStreams\")","","local function write( instance, type, size, ... )","\tinstance.data.net.size = instance.data.net.size + size","","\tinstance.data.net.data[#instance.data.net.data+1] = { \"Write\" .. type, {...} }","end","","local instances = {}","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.net = {","\t\tstarted = false,","\t\tburst = SF.BurstObject( burst_rate:GetFloat()*1000, burst_limit:GetFloat()*1000 ),","\t\tsize = 0,","\t\tdata = {},","\t}","end)","","SF.Libraries.AddHook( \"cleanup\", function ( instance )","\tinstance.data.net.started = false","\tinstance.data.net.data = {}","end )","","if SERVER then","\tutil.AddNetworkString( \"SF_netmessage\" )","end",""]}},"type":"file","name":"libs_sh/net.lua","functions":{"1":"net_library.getBytesLeft","2":"net_library.readAngle","3":"net_library.readBit","4":"net_library.readColor","5":"net_library.readData","6":"net_library.readDouble","7":"net_library.readEntity","8":"net_library.readFloat","9":"net_library.readInt","10":"net_library.readMatrix","11":"net_library.readStream","12":"net_library.readString","13":"net_library.readUInt","14":"net_library.readVector","15":"net_library.send","16":"net_library.start","17":"net_library.writeAngle","18":"net_library.writeBit","19":"net_library.writeColor","20":"net_library.writeData","21":"net_library.writeDouble","22":"net_library.writeEntity","23":"net_library.writeFloat","24":"net_library.writeInt","25":"net_library.writeMatrix","26":"net_library.writeStream","27":"net_library.writeString","28":"net_library.writeUInt","29":"net_library.writeVector","net_library.start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.started then SF.throw( \"net message was already started\", 2 ) end","","\tinstance.data.net.started = true","\tinstance.data.net.size = 8 -- 8 bytes overhead","\tinstance.data.net.data = {}","","\twrite( instance, \"String\", #name, name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"net_library.writeVector":{"comment":["--- Writes an vector to the net message","-- @shared","-- @param t The vector to be written"],"code":["","function net_library.writeVector( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Vector\"] )","","\twrite( instance, \"Vector\", 12, SF.Vectors.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an vector to the net message ","library":"net","name":"net_library.writeVector","server":true,"private":false,"client":true,"description":"\nWrites an vector to the net message","param":{"1":"t","t":"The vector to be written"}},"net_library.writeString":{"comment":["--- Writes a string to the net message. Null characters will terminate the string.","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", #t, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message.","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message. Null characters will terminate the string.","param":{"1":"t","t":"The string to be written"}},"net_library.readAngle":{"ret":"The angle that was read","comment":["--- Reads an angle from the net message","-- @shared","-- @return The angle that was read"],"code":["","function net_library.readAngle()","\treturn SF.Angles.Wrap( net.ReadAngle() )","end",""],"class":"function","summary":"\nReads an angle from the net message ","library":"net","name":"net_library.readAngle","server":true,"private":false,"client":true,"description":"\nReads an angle from the net message","param":[]},"net_library.writeColor":{"comment":["--- Writes an color to the net message","-- @shared","-- @param t The color to be written"],"code":["","function net_library.writeColor( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Color\"] )","","\twrite( instance, \"Color\", 4, SF.Color.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an color to the net message ","library":"net","name":"net_library.writeColor","server":true,"private":false,"client":true,"description":"\nWrites an color to the net message","param":{"1":"t","t":"The color to be written"}},"net_library.readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},"net_library.writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", 8, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"net_library.readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"net_library.writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"net_library.readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"net_library.readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"net_library.writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", 1, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"net_library.getBytesLeft":{"ret":"number of bytes that can be sent","comment":["--- Returns available bandwidth in bytes","-- @return number of bytes that can be sent"],"code":["function net_library.getBytesLeft()","\treturn SF.instance.data.net.burst:check() - SF.instance.data.net.size","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tif ent.instance then","\t\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\t\tend","\tend","end)",""],"class":"function","name":"net_library.getBytesLeft","summary":"\nReturns available bandwidth in bytes ","private":false,"library":"net","description":"\nReturns available bandwidth in bytes","param":[]},"net_library.writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"net_library.writeEntity":{"comment":["--- Writes an entity to the net message","-- @shared","-- @param t The entity to be written"],"code":["","function net_library.writeEntity( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Entity\"] )","","\twrite( instance, \"Entity\", 2, SF.UnwrapObject( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an entity to the net message ","library":"net","name":"net_library.writeEntity","server":true,"private":false,"client":true,"description":"\nWrites an entity to the net message","param":{"1":"t","t":"The entity to be written"}},"net_library.readStream":{"comment":["--- Reads a large string stream from the net message","-- @shared","-- @param cb Callback to run when the stream is finished. The first parameter in the callback is the data."],"code":["","function net_library.readStream( cb )","\tSF.CheckType( cb, \"function\" )","\tlocal instance = SF.instance","\tif streams[instance.player] then SF.throw( \"The previous stream must finish before reading another.\", 2 ) end","\tstreams[instance.player] = true","\t","\tnet.ReadStream( ( SERVER and instance.player or nil ), function( data )","\t\tlocal ok, msg, traceback = instance:runFunction( cb, data )","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\t\tstreams[instance.player] = false","\tend )","end",""],"class":"function","summary":"\nReads a large string stream from the net message ","library":"net","name":"net_library.readStream","server":true,"private":false,"client":true,"description":"\nReads a large string stream from the net message","param":{"1":"cb","cb":"Callback to run when the stream is finished. The first parameter in the callback is the data."}},"net_library.readEntity":{"ret":"The entity that was read","comment":["--- Reads a entity from the net message","-- @shared","-- @return The entity that was read"],"code":["","function net_library.readEntity()","\treturn SF.WrapObject( net.ReadEntity() )","end",""],"class":"function","summary":"\nReads a entity from the net message ","library":"net","name":"net_library.readEntity","server":true,"private":false,"client":true,"description":"\nReads a entity from the net message","param":[]},"net_library.readColor":{"ret":"The color that was read","comment":["--- Reads a color from the net message","-- @shared","-- @return The color that was read"],"code":["","function net_library.readColor()","\treturn SF.Color.Wrap( net.ReadColor() )","end",""],"class":"function","summary":"\nReads a color from the net message ","library":"net","name":"net_library.readColor","server":true,"private":false,"client":true,"description":"\nReads a color from the net message","param":[]},"net_library.readMatrix":{"ret":"The matrix that was read","comment":["--- Reads a matrix from the net message","-- @shared","-- @return The matrix that was read"],"code":["","function net_library.readMatrix()","\treturn SF.VMatrix.Wrap( net.ReadMatrix() )","end",""],"class":"function","summary":"\nReads a matrix from the net message ","library":"net","name":"net_library.readMatrix","server":true,"private":false,"client":true,"description":"\nReads a matrix from the net message","param":[]},"net_library.readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"net_library.readData":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @param n How many characters are in the data","-- @return The string that was read"],"code":["","function net_library.readData( n )","\tSF.CheckType( n, \"number\" )","\tn = math.Clamp( n, 0, 64000 )","\treturn net.ReadData( n )","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readData","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":{"1":"n","n":"How many characters are in the data"}},"net_library.writeMatrix":{"comment":["--- Writes an matrix to the net message","-- @shared","-- @param t The matrix to be written"],"code":["","function net_library.writeMatrix( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"VMatrix\"] )","","\twrite( instance, \"Matrix\", 64, SF.VMatrix.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an matrix to the net message ","library":"net","name":"net_library.writeMatrix","server":true,"private":false,"client":true,"description":"\nWrites an matrix to the net message","param":{"1":"t","t":"The matrix to be written"}},"net_library.readVector":{"ret":"The vector that was read","comment":["--- Reads a vector from the net message","-- @shared","-- @return The vector that was read"],"code":["","function net_library.readVector()","\treturn SF.Vectors.Wrap( net.ReadVector() )","end",""],"class":"function","summary":"\nReads a vector from the net message ","library":"net","name":"net_library.readVector","server":true,"private":false,"client":true,"description":"\nReads a vector from the net message","param":[]},"net_library.writeStream":{"comment":["--- Streams a large 20MB string. ","-- @shared","-- @param str The string to be written"],"code":["function net_library.writeStream( str )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( str, \"string\" )","\twrite( instance, \"Stream\", 8, str )","\treturn true","end",""],"class":"function","summary":"\nStreams a large 20MB string.","library":"net","name":"net_library.writeStream","server":true,"private":false,"client":true,"description":"\nStreams a large 20MB string.","param":{"1":"str","str":"The string to be written"}},"net_library.writeAngle":{"comment":["--- Writes an angle to the net message","-- @shared","-- @param t The angle to be written"],"code":["","function net_library.writeAngle( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Angle\"] )","","\twrite( instance, \"Angle\", 12, SF.Angles.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an angle to the net message ","library":"net","name":"net_library.writeAngle","server":true,"private":false,"client":true,"description":"\nWrites an angle to the net message","param":{"1":"t","t":"The angle to be written"}},"net_library.readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"net_library.writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", 4, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}},"net_library.send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tif not instance.data.net.burst:use( instance.data.net.size ) then","\t\tSF.throw( \"Net message exceeds limit!\", 3 )","\tend","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tnet[ data[ i ][ 1 ] ]( unpack( data[ i ][ 2 ] ) )","\tend","","\tif SERVER then","\t\tlocal sendfunc, newtarget","","\t\tif target then","\t\t\tif target[1] then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tlocal pl = SF.Entities.Unwrap( target[ i ] )","\t\t\t\t\tif IsValid( pl ) and pl:IsPlayer() then","\t\t\t\t\t\tnt[ #nt + 1 ] = pl","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\t\tif not IsValid( newtarget ) or not newtarget:IsPlayer() then SF.throw( \"Invalid player\", 2 ) end","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","","\tinstance.data.net.size = 0","\tinstance.data.net.data = {}","\tinstance.data.net.started = false","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"net_library.writeData":{"comment":["--- Writes string containing null characters to the net message","-- @shared","-- @param t The string to be written","-- @param n How much of the string to write"],"code":["","function net_library.writeData( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Data\", n, t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites string containing null characters to the net message ","library":"net","name":"net_library.writeData","server":true,"private":false,"client":true,"description":"\nWrites string containing null characters to the net message","param":{"1":"t","2":"n","n":"How much of the string to write","t":"The string to be written"}}},"doc":[{"summary":"\n \nNetworking library.","description":"\n \nNetworking library. \n","comment":["-------------------------------------------------------------------------------","-- Networking library.","-------------------------------------------------------------------------------"],"code":["","local net = net",""]},{"comment":["--- Net message library. Used for sending data from the server to the client and back"],"functions":{"1":"getBytesLeft","2":"readAngle","3":"readBit","4":"readColor","5":"readData","6":"readDouble","7":"readEntity","8":"readFloat","9":"readInt","10":"readMatrix","11":"readStream","12":"readString","13":"readUInt","14":"readVector","15":"send","16":"start","17":"writeAngle","18":"writeBit","19":"writeColor","20":"writeData","21":"writeDouble","22":"writeEntity","23":"writeFloat","24":"writeInt","25":"writeMatrix","26":"writeStream","27":"writeString","28":"writeUInt","29":"writeVector","writeVector":{"comment":["--- Writes an vector to the net message","-- @shared","-- @param t The vector to be written"],"code":["","function net_library.writeVector( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Vector\"] )","","\twrite( instance, \"Vector\", 12, SF.Vectors.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an vector to the net message ","library":"net","name":"net_library.writeVector","server":true,"private":false,"client":true,"description":"\nWrites an vector to the net message","param":{"1":"t","t":"The vector to be written"}},"readColor":{"ret":"The color that was read","comment":["--- Reads a color from the net message","-- @shared","-- @return The color that was read"],"code":["","function net_library.readColor()","\treturn SF.Color.Wrap( net.ReadColor() )","end",""],"class":"function","summary":"\nReads a color from the net message ","library":"net","name":"net_library.readColor","server":true,"private":false,"client":true,"description":"\nReads a color from the net message","param":[]},"readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tif not instance.data.net.burst:use( instance.data.net.size ) then","\t\tSF.throw( \"Net message exceeds limit!\", 3 )","\tend","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tnet[ data[ i ][ 1 ] ]( unpack( data[ i ][ 2 ] ) )","\tend","","\tif SERVER then","\t\tlocal sendfunc, newtarget","","\t\tif target then","\t\t\tif target[1] then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tlocal pl = SF.Entities.Unwrap( target[ i ] )","\t\t\t\t\tif IsValid( pl ) and pl:IsPlayer() then","\t\t\t\t\t\tnt[ #nt + 1 ] = pl","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\t\tif not IsValid( newtarget ) or not newtarget:IsPlayer() then SF.throw( \"Invalid player\", 2 ) end","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","","\tinstance.data.net.size = 0","\tinstance.data.net.data = {}","\tinstance.data.net.started = false","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"writeAngle":{"comment":["--- Writes an angle to the net message","-- @shared","-- @param t The angle to be written"],"code":["","function net_library.writeAngle( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Angle\"] )","","\twrite( instance, \"Angle\", 12, SF.Angles.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an angle to the net message ","library":"net","name":"net_library.writeAngle","server":true,"private":false,"client":true,"description":"\nWrites an angle to the net message","param":{"1":"t","t":"The angle to be written"}},"writeStream":{"comment":["--- Streams a large 20MB string. ","-- @shared","-- @param str The string to be written"],"code":["function net_library.writeStream( str )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( str, \"string\" )","\twrite( instance, \"Stream\", 8, str )","\treturn true","end",""],"class":"function","summary":"\nStreams a large 20MB string.","library":"net","name":"net_library.writeStream","server":true,"private":false,"client":true,"description":"\nStreams a large 20MB string.","param":{"1":"str","str":"The string to be written"}},"readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", 1, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"writeMatrix":{"comment":["--- Writes an matrix to the net message","-- @shared","-- @param t The matrix to be written"],"code":["","function net_library.writeMatrix( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"VMatrix\"] )","","\twrite( instance, \"Matrix\", 64, SF.VMatrix.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an matrix to the net message ","library":"net","name":"net_library.writeMatrix","server":true,"private":false,"client":true,"description":"\nWrites an matrix to the net message","param":{"1":"t","t":"The matrix to be written"}},"readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"getBytesLeft":{"ret":"number of bytes that can be sent","comment":["--- Returns available bandwidth in bytes","-- @return number of bytes that can be sent"],"code":["function net_library.getBytesLeft()","\treturn SF.instance.data.net.burst:check() - SF.instance.data.net.size","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tif ent.instance then","\t\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\t\tend","\tend","end)",""],"class":"function","name":"net_library.getBytesLeft","summary":"\nReturns available bandwidth in bytes ","private":false,"library":"net","description":"\nReturns available bandwidth in bytes","param":[]},"readEntity":{"ret":"The entity that was read","comment":["--- Reads a entity from the net message","-- @shared","-- @return The entity that was read"],"code":["","function net_library.readEntity()","\treturn SF.WrapObject( net.ReadEntity() )","end",""],"class":"function","summary":"\nReads a entity from the net message ","library":"net","name":"net_library.readEntity","server":true,"private":false,"client":true,"description":"\nReads a entity from the net message","param":[]},"writeEntity":{"comment":["--- Writes an entity to the net message","-- @shared","-- @param t The entity to be written"],"code":["","function net_library.writeEntity( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Entity\"] )","","\twrite( instance, \"Entity\", 2, SF.UnwrapObject( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an entity to the net message ","library":"net","name":"net_library.writeEntity","server":true,"private":false,"client":true,"description":"\nWrites an entity to the net message","param":{"1":"t","t":"The entity to be written"}},"readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},"writeColor":{"comment":["--- Writes an color to the net message","-- @shared","-- @param t The color to be written"],"code":["","function net_library.writeColor( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Color\"] )","","\twrite( instance, \"Color\", 4, SF.Color.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an color to the net message ","library":"net","name":"net_library.writeColor","server":true,"private":false,"client":true,"description":"\nWrites an color to the net message","param":{"1":"t","t":"The color to be written"}},"readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"readVector":{"ret":"The vector that was read","comment":["--- Reads a vector from the net message","-- @shared","-- @return The vector that was read"],"code":["","function net_library.readVector()","\treturn SF.Vectors.Wrap( net.ReadVector() )","end",""],"class":"function","summary":"\nReads a vector from the net message ","library":"net","name":"net_library.readVector","server":true,"private":false,"client":true,"description":"\nReads a vector from the net message","param":[]},"readStream":{"comment":["--- Reads a large string stream from the net message","-- @shared","-- @param cb Callback to run when the stream is finished. The first parameter in the callback is the data."],"code":["","function net_library.readStream( cb )","\tSF.CheckType( cb, \"function\" )","\tlocal instance = SF.instance","\tif streams[instance.player] then SF.throw( \"The previous stream must finish before reading another.\", 2 ) end","\tstreams[instance.player] = true","\t","\tnet.ReadStream( ( SERVER and instance.player or nil ), function( data )","\t\tlocal ok, msg, traceback = instance:runFunction( cb, data )","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\t\tstreams[instance.player] = false","\tend )","end",""],"class":"function","summary":"\nReads a large string stream from the net message ","library":"net","name":"net_library.readStream","server":true,"private":false,"client":true,"description":"\nReads a large string stream from the net message","param":{"1":"cb","cb":"Callback to run when the stream is finished. The first parameter in the callback is the data."}},"writeString":{"comment":["--- Writes a string to the net message. Null characters will terminate the string.","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", #t, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message.","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message. Null characters will terminate the string.","param":{"1":"t","t":"The string to be written"}},"readAngle":{"ret":"The angle that was read","comment":["--- Reads an angle from the net message","-- @shared","-- @return The angle that was read"],"code":["","function net_library.readAngle()","\treturn SF.Angles.Wrap( net.ReadAngle() )","end",""],"class":"function","summary":"\nReads an angle from the net message ","library":"net","name":"net_library.readAngle","server":true,"private":false,"client":true,"description":"\nReads an angle from the net message","param":[]},"writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", 4, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}},"writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", 8, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.started then SF.throw( \"net message was already started\", 2 ) end","","\tinstance.data.net.started = true","\tinstance.data.net.size = 8 -- 8 bytes overhead","\tinstance.data.net.data = {}","","\twrite( instance, \"String\", #name, name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"writeData":{"comment":["--- Writes string containing null characters to the net message","-- @shared","-- @param t The string to be written","-- @param n How much of the string to write"],"code":["","function net_library.writeData( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Data\", n, t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites string containing null characters to the net message ","library":"net","name":"net_library.writeData","server":true,"private":false,"client":true,"description":"\nWrites string containing null characters to the net message","param":{"1":"t","2":"n","n":"How much of the string to write","t":"The string to be written"}},"readData":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @param n How many characters are in the data","-- @return The string that was read"],"code":["","function net_library.readData( n )","\tSF.CheckType( n, \"number\" )","\tn = math.Clamp( n, 0, 64000 )","\treturn net.ReadData( n )","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readData","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":{"1":"n","n":"How many characters are in the data"}},"readMatrix":{"ret":"The matrix that was read","comment":["--- Reads a matrix from the net message","-- @shared","-- @return The matrix that was read"],"code":["","function net_library.readMatrix()","\treturn SF.VMatrix.Wrap( net.ReadMatrix() )","end",""],"class":"function","summary":"\nReads a matrix from the net message ","library":"net","name":"net_library.readMatrix","server":true,"private":false,"client":true,"description":"\nReads a matrix from the net message","param":[]}},"class":"library","fields":[],"name":"net","summary":"\nNet message library.","description":"\nNet message library. Used for sending data from the server to the client and back","libtbl":"net_library","tables":[],"code":["local net_library, _ = SF.Libraries.Register(\"net\")","","local burst_limit = CreateConVar( \"sf_net_burstmax\", \"10\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\"The net message burst limit in kB.\" )","","local burst_rate = CreateConVar( \"sf_net_burstrate\", \"5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\t\"Regen rate of net message burst in kB/sec.\" )","","","local streams = SF.EntityTable(\"playerStreams\")","","local function write( instance, type, size, ... )","\tinstance.data.net.size = instance.data.net.size + size","","\tinstance.data.net.data[#instance.data.net.data+1] = { \"Write\" .. type, {...} }","end","","local instances = {}","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.net = {","\t\tstarted = false,","\t\tburst = SF.BurstObject( burst_rate:GetFloat()*1000, burst_limit:GetFloat()*1000 ),","\t\tsize = 0,","\t\tdata = {},","\t}","end)","","SF.Libraries.AddHook( \"cleanup\", function ( instance )","\tinstance.data.net.started = false","\tinstance.data.net.data = {}","end )","","if SERVER then","\tutil.AddNetworkString( \"SF_netmessage\" )","end",""]},{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.started then SF.throw( \"net message was already started\", 2 ) end","","\tinstance.data.net.started = true","\tinstance.data.net.size = 8 -- 8 bytes overhead","\tinstance.data.net.data = {}","","\twrite( instance, \"String\", #name, name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tif not instance.data.net.burst:use( instance.data.net.size ) then","\t\tSF.throw( \"Net message exceeds limit!\", 3 )","\tend","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tnet[ data[ i ][ 1 ] ]( unpack( data[ i ][ 2 ] ) )","\tend","","\tif SERVER then","\t\tlocal sendfunc, newtarget","","\t\tif target then","\t\t\tif target[1] then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tlocal pl = SF.Entities.Unwrap( target[ i ] )","\t\t\t\t\tif IsValid( pl ) and pl:IsPlayer() then","\t\t\t\t\t\tnt[ #nt + 1 ] = pl","\t\t\t\t\tend","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\t\tif not IsValid( newtarget ) or not newtarget:IsPlayer() then SF.throw( \"Invalid player\", 2 ) end","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","","\tinstance.data.net.size = 0","\tinstance.data.net.data = {}","\tinstance.data.net.started = false","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},{"comment":["--- Writes a string to the net message. Null characters will terminate the string.","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", #t, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message.","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message. Null characters will terminate the string.","param":{"1":"t","t":"The string to be written"}},{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},{"comment":["--- Writes string containing null characters to the net message","-- @shared","-- @param t The string to be written","-- @param n How much of the string to write"],"code":["","function net_library.writeData( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Data\", n, t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites string containing null characters to the net message ","library":"net","name":"net_library.writeData","server":true,"private":false,"client":true,"description":"\nWrites string containing null characters to the net message","param":{"1":"t","2":"n","n":"How much of the string to write","t":"The string to be written"}},{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @param n How many characters are in the data","-- @return The string that was read"],"code":["","function net_library.readData( n )","\tSF.CheckType( n, \"number\" )","\tn = math.Clamp( n, 0, 64000 )","\treturn net.ReadData( n )","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readData","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":{"1":"n","n":"How many characters are in the data"}},{"comment":["--- Streams a large 20MB string. ","-- @shared","-- @param str The string to be written"],"code":["function net_library.writeStream( str )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( str, \"string\" )","\twrite( instance, \"Stream\", 8, str )","\treturn true","end",""],"class":"function","summary":"\nStreams a large 20MB string.","library":"net","name":"net_library.writeStream","server":true,"private":false,"client":true,"description":"\nStreams a large 20MB string.","param":{"1":"str","str":"The string to be written"}},{"comment":["--- Reads a large string stream from the net message","-- @shared","-- @param cb Callback to run when the stream is finished. The first parameter in the callback is the data."],"code":["","function net_library.readStream( cb )","\tSF.CheckType( cb, \"function\" )","\tlocal instance = SF.instance","\tif streams[instance.player] then SF.throw( \"The previous stream must finish before reading another.\", 2 ) end","\tstreams[instance.player] = true","\t","\tnet.ReadStream( ( SERVER and instance.player or nil ), function( data )","\t\tlocal ok, msg, traceback = instance:runFunction( cb, data )","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\t\tstreams[instance.player] = false","\tend )","end",""],"class":"function","summary":"\nReads a large string stream from the net message ","library":"net","name":"net_library.readStream","server":true,"private":false,"client":true,"description":"\nReads a large string stream from the net message","param":{"1":"cb","cb":"Callback to run when the stream is finished. The first parameter in the callback is the data."}},{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", math.ceil(n/8), t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", 1, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", 8, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", 4, t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}},{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},{"comment":["--- Writes an angle to the net message","-- @shared","-- @param t The angle to be written"],"code":["","function net_library.writeAngle( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Angle\"] )","","\twrite( instance, \"Angle\", 12, SF.Angles.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an angle to the net message ","library":"net","name":"net_library.writeAngle","server":true,"private":false,"client":true,"description":"\nWrites an angle to the net message","param":{"1":"t","t":"The angle to be written"}},{"ret":"The angle that was read","comment":["--- Reads an angle from the net message","-- @shared","-- @return The angle that was read"],"code":["","function net_library.readAngle()","\treturn SF.Angles.Wrap( net.ReadAngle() )","end",""],"class":"function","summary":"\nReads an angle from the net message ","library":"net","name":"net_library.readAngle","server":true,"private":false,"client":true,"description":"\nReads an angle from the net message","param":[]},{"comment":["--- Writes an vector to the net message","-- @shared","-- @param t The vector to be written"],"code":["","function net_library.writeVector( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Vector\"] )","","\twrite( instance, \"Vector\", 12, SF.Vectors.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an vector to the net message ","library":"net","name":"net_library.writeVector","server":true,"private":false,"client":true,"description":"\nWrites an vector to the net message","param":{"1":"t","t":"The vector to be written"}},{"ret":"The vector that was read","comment":["--- Reads a vector from the net message","-- @shared","-- @return The vector that was read"],"code":["","function net_library.readVector()","\treturn SF.Vectors.Wrap( net.ReadVector() )","end",""],"class":"function","summary":"\nReads a vector from the net message ","library":"net","name":"net_library.readVector","server":true,"private":false,"client":true,"description":"\nReads a vector from the net message","param":[]},{"comment":["--- Writes an matrix to the net message","-- @shared","-- @param t The matrix to be written"],"code":["","function net_library.writeMatrix( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"VMatrix\"] )","","\twrite( instance, \"Matrix\", 64, SF.VMatrix.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an matrix to the net message ","library":"net","name":"net_library.writeMatrix","server":true,"private":false,"client":true,"description":"\nWrites an matrix to the net message","param":{"1":"t","t":"The matrix to be written"}},{"ret":"The matrix that was read","comment":["--- Reads a matrix from the net message","-- @shared","-- @return The matrix that was read"],"code":["","function net_library.readMatrix()","\treturn SF.VMatrix.Wrap( net.ReadMatrix() )","end",""],"class":"function","summary":"\nReads a matrix from the net message ","library":"net","name":"net_library.readMatrix","server":true,"private":false,"client":true,"description":"\nReads a matrix from the net message","param":[]},{"comment":["--- Writes an color to the net message","-- @shared","-- @param t The color to be written"],"code":["","function net_library.writeColor( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Color\"] )","","\twrite( instance, \"Color\", 4, SF.Color.Unwrap( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an color to the net message ","library":"net","name":"net_library.writeColor","server":true,"private":false,"client":true,"description":"\nWrites an color to the net message","param":{"1":"t","t":"The color to be written"}},{"ret":"The color that was read","comment":["--- Reads a color from the net message","-- @shared","-- @return The color that was read"],"code":["","function net_library.readColor()","\treturn SF.Color.Wrap( net.ReadColor() )","end",""],"class":"function","summary":"\nReads a color from the net message ","library":"net","name":"net_library.readColor","server":true,"private":false,"client":true,"description":"\nReads a color from the net message","param":[]},{"comment":["--- Writes an entity to the net message","-- @shared","-- @param t The entity to be written"],"code":["","function net_library.writeEntity( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, SF.Types[\"Entity\"] )","","\twrite( instance, \"Entity\", 2, SF.UnwrapObject( t ) )","\treturn true","end",""],"class":"function","summary":"\nWrites an entity to the net message ","library":"net","name":"net_library.writeEntity","server":true,"private":false,"client":true,"description":"\nWrites an entity to the net message","param":{"1":"t","t":"The entity to be written"}},{"ret":"The entity that was read","comment":["--- Reads a entity from the net message","-- @shared","-- @return The entity that was read"],"code":["","function net_library.readEntity()","\treturn SF.WrapObject( net.ReadEntity() )","end",""],"class":"function","summary":"\nReads a entity from the net message ","library":"net","name":"net_library.readEntity","server":true,"private":false,"client":true,"description":"\nReads a entity from the net message","param":[]},{"ret":"number of bytes that can be sent","comment":["--- Returns available bandwidth in bytes","-- @return number of bytes that can be sent"],"code":["function net_library.getBytesLeft()","\treturn SF.instance.data.net.burst:check() - SF.instance.data.net.size","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tif ent.instance then","\t\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\t\tend","\tend","end)",""],"class":"function","name":"net_library.getBytesLeft","summary":"\nReturns available bandwidth in bytes ","private":false,"library":"net","description":"\nReturns available bandwidth in bytes","param":[]},{"classForced":true,"summary":"\nCalled when a net message arrives ","comment":["--- Called when a net message arrives","-- @name net","-- @class hook","-- @param name Name of the arriving net message","-- @param len Length of the arriving net message in bytes","-- @param ply On server, the player that sent the message. Nil on client."],"code":[],"description":"\nCalled when a net message arrives","class":"hook","name":"net","param":{"1":"name","2":"len","3":"ply","len":"Length of the arriving net message in bytes","name":"Name of the arriving net message","ply":"On server, the player that sent the message. Nil on client."}}],"tables":[],"description":"\n \nNetworking library. \n","summary":"\n \nNetworking library."},"libs_sh/timer.lua":{"libraries":{"1":"timer","timer":{"comment":["--- Deals with time and timers.","-- @shared"],"functions":{"1":"adjust","2":"create","3":"curtime","4":"exists","5":"frametime","6":"getTimersLeft","7":"pause","8":"realtime","9":"remove","10":"simple","11":"start","12":"stop","13":"systime","14":"unpause","simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\ttimer_library.create(\"\", delay, 1, func, true)","end",""],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn \"sftimer_\"..tostring(instance)..\"_\"..name","end","","local simple_int = 0","local function mangle_simpletimer_name(instance)","\tsimple_int = simple_int + 1","\treturn \"sftimersimple_\"..tostring(instance)..\"_\"..simple_int","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},"systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.adjust(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tif func then SF.CheckType(func,\"function\") end","\t","\ttimer.Adjust(mangle_timer_name(SF.instance,name), delay, reps, func)","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func, simple)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tif instance.data.timer_count > max_timers:GetInt() then SF.throw( \"Max timers exceeded!\", 2 ) end","\tinstance.data.timer_count = instance.data.timer_count + 1","\t","\tlocal timername","\tif simple then","\t\ttimername = mangle_simpletimer_name(instance)","\telse","\t\ttimername = mangle_timer_name(instance,name)","\tend","\t","\tlocal function timercb()","\t\tif reps ~= 0 then","\t\t\treps = reps - 1","\t\t\tif reps==0 then","\t\t\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\t\t\tinstance.data.timers[timername] = nil","\t\t\tend","\t\tend","\t\t","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend","\t","\ttimer.Create(timername, math.max(delay, 0.001), reps, timercb )","\t","\tinstance.data.timers[timername] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","5":"simple","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"getTimersLeft":{"ret":"Number of available timers","comment":["--- Returns number of available timers","-- @return Number of available timers"],"code":["function timer_library.getTimersLeft()","\treturn max_timers:GetInt() - SF.instance.data.timer_count","end","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","\tinstance.data.timer_count = 0","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor name,_ in pairs(instance.data.timers) do","\t\ttimer.Remove(name)","\tend","end)"],"class":"function","name":"timer_library.getTimersLeft","summary":"\nReturns number of available timers ","private":false,"library":"timer","description":"\nReturns number of available timers","param":[]},"stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]}},"class":"library","summary":"\nDeals with time and timers.","code":["local timer_library, _ = SF.Libraries.Register(\"timer\")","local max_timers = CreateConVar( \"sf_maxtimers\", \"200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED}, \"The max number of timers that can be created\" )","","-- ------------------------- Time ------------------------- --",""],"fields":[],"name":"timer","client":true,"description":"\nDeals with time and timers.","libtbl":"timer_library","tables":[],"server":true}},"type":"file","name":"libs_sh/timer.lua","functions":{"1":"timer_library.adjust","2":"timer_library.create","3":"timer_library.curtime","4":"timer_library.exists","5":"timer_library.frametime","6":"timer_library.getTimersLeft","7":"timer_library.pause","8":"timer_library.realtime","9":"timer_library.remove","10":"timer_library.simple","11":"timer_library.start","12":"timer_library.stop","13":"timer_library.systime","14":"timer_library.unpause","timer_library.simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\ttimer_library.create(\"\", delay, 1, func, true)","end",""],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"timer_library.adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.adjust(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tif func then SF.CheckType(func,\"function\") end","\t","\ttimer.Adjust(mangle_timer_name(SF.instance,name), delay, reps, func)","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"timer_library.realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"timer_library.exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"timer_library.systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"timer_library.getTimersLeft":{"ret":"Number of available timers","comment":["--- Returns number of available timers","-- @return Number of available timers"],"code":["function timer_library.getTimersLeft()","\treturn max_timers:GetInt() - SF.instance.data.timer_count","end","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","\tinstance.data.timer_count = 0","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor name,_ in pairs(instance.data.timers) do","\t\ttimer.Remove(name)","\tend","end)"],"class":"function","name":"timer_library.getTimersLeft","summary":"\nReturns number of available timers ","private":false,"library":"timer","description":"\nReturns number of available timers","param":[]},"timer_library.unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"timer_library.curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]},"timer_library.pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"timer_library.remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"timer_library.start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"timer_library.stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"timer_library.create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func, simple)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tif instance.data.timer_count > max_timers:GetInt() then SF.throw( \"Max timers exceeded!\", 2 ) end","\tinstance.data.timer_count = instance.data.timer_count + 1","\t","\tlocal timername","\tif simple then","\t\ttimername = mangle_simpletimer_name(instance)","\telse","\t\ttimername = mangle_timer_name(instance,name)","\tend","\t","\tlocal function timercb()","\t\tif reps ~= 0 then","\t\t\treps = reps - 1","\t\t\tif reps==0 then","\t\t\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\t\t\tinstance.data.timers[timername] = nil","\t\t\tend","\t\tend","\t\t","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend","\t","\ttimer.Create(timername, math.max(delay, 0.001), reps, timercb )","\t","\tinstance.data.timers[timername] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","5":"simple","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"timer_library.frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn \"sftimer_\"..tostring(instance)..\"_\"..name","end","","local simple_int = 0","local function mangle_simpletimer_name(instance)","\tsimple_int = simple_int + 1","\treturn \"sftimersimple_\"..tostring(instance)..\"_\"..simple_int","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]}},"doc":[{"summary":"\n \nTime library \n ","description":"\n \nTime library \n","comment":["-------------------------------------------------------------------------------","-- Time library","-------------------------------------------------------------------------------"],"code":["","local timer = timer",""]},{"comment":["--- Deals with time and timers.","-- @shared"],"functions":{"1":"adjust","2":"create","3":"curtime","4":"exists","5":"frametime","6":"getTimersLeft","7":"pause","8":"realtime","9":"remove","10":"simple","11":"start","12":"stop","13":"systime","14":"unpause","simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\ttimer_library.create(\"\", delay, 1, func, true)","end",""],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn \"sftimer_\"..tostring(instance)..\"_\"..name","end","","local simple_int = 0","local function mangle_simpletimer_name(instance)","\tsimple_int = simple_int + 1","\treturn \"sftimersimple_\"..tostring(instance)..\"_\"..simple_int","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},"systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.adjust(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tif func then SF.CheckType(func,\"function\") end","\t","\ttimer.Adjust(mangle_timer_name(SF.instance,name), delay, reps, func)","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func, simple)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tif instance.data.timer_count > max_timers:GetInt() then SF.throw( \"Max timers exceeded!\", 2 ) end","\tinstance.data.timer_count = instance.data.timer_count + 1","\t","\tlocal timername","\tif simple then","\t\ttimername = mangle_simpletimer_name(instance)","\telse","\t\ttimername = mangle_timer_name(instance,name)","\tend","\t","\tlocal function timercb()","\t\tif reps ~= 0 then","\t\t\treps = reps - 1","\t\t\tif reps==0 then","\t\t\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\t\t\tinstance.data.timers[timername] = nil","\t\t\tend","\t\tend","\t\t","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend","\t","\ttimer.Create(timername, math.max(delay, 0.001), reps, timercb )","\t","\tinstance.data.timers[timername] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","5":"simple","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"getTimersLeft":{"ret":"Number of available timers","comment":["--- Returns number of available timers","-- @return Number of available timers"],"code":["function timer_library.getTimersLeft()","\treturn max_timers:GetInt() - SF.instance.data.timer_count","end","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","\tinstance.data.timer_count = 0","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor name,_ in pairs(instance.data.timers) do","\t\ttimer.Remove(name)","\tend","end)"],"class":"function","name":"timer_library.getTimersLeft","summary":"\nReturns number of available timers ","private":false,"library":"timer","description":"\nReturns number of available timers","param":[]},"stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]}},"class":"library","summary":"\nDeals with time and timers.","code":["local timer_library, _ = SF.Libraries.Register(\"timer\")","local max_timers = CreateConVar( \"sf_maxtimers\", \"200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED}, \"The max number of timers that can be created\" )","","-- ------------------------- Time ------------------------- --",""],"fields":[],"name":"timer","client":true,"description":"\nDeals with time and timers.","libtbl":"timer_library","tables":[],"server":true},{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]},{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn \"sftimer_\"..tostring(instance)..\"_\"..name","end","","local simple_int = 0","local function mangle_simpletimer_name(instance)","\tsimple_int = simple_int + 1","\treturn \"sftimersimple_\"..tostring(instance)..\"_\"..simple_int","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func, simple)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tif instance.data.timer_count > max_timers:GetInt() then SF.throw( \"Max timers exceeded!\", 2 ) end","\tinstance.data.timer_count = instance.data.timer_count + 1","\t","\tlocal timername","\tif simple then","\t\ttimername = mangle_simpletimer_name(instance)","\telse","\t\ttimername = mangle_timer_name(instance,name)","\tend","\t","\tlocal function timercb()","\t\tif reps ~= 0 then","\t\t\treps = reps - 1","\t\t\tif reps==0 then","\t\t\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\t\t\tinstance.data.timers[timername] = nil","\t\t\tend","\t\tend","\t\t","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend","\t","\ttimer.Create(timername, math.max(delay, 0.001), reps, timercb )","\t","\tinstance.data.timers[timername] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","5":"simple","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\ttimer_library.create(\"\", delay, 1, func, true)","end",""],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\tlocal timername = mangle_timer_name(instance,name)","\tif instance.data.timers[timername] then","\t\tinstance.data.timer_count = instance.data.timer_count - 1","\t\tinstance.data.timers[timername] = nil","\t\ttimer.Stop(timername)","\tend","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Adjusts a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.adjust(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tif func then SF.CheckType(func,\"function\") end","\t","\ttimer.Adjust(mangle_timer_name(SF.instance,name), delay, reps, func)","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(SF.instance,name))","end",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},{"ret":"Number of available timers","comment":["--- Returns number of available timers","-- @return Number of available timers"],"code":["function timer_library.getTimersLeft()","\treturn max_timers:GetInt() - SF.instance.data.timer_count","end","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","\tinstance.data.timer_count = 0","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tfor name,_ in pairs(instance.data.timers) do","\t\ttimer.Remove(name)","\tend","end)"],"class":"function","name":"timer_library.getTimersLeft","summary":"\nReturns number of available timers ","private":false,"library":"timer","description":"\nReturns number of available timers","param":[]}],"tables":[],"description":"\n \nTime library \n","summary":"\n \nTime library \n "},"libs_cl/render.lua":{"libraries":{"1":"render","render":{"comment":["--- Render library. Screens are 512x512 units. Most functions require","-- that you be in the rendering hook to call, otherwise an error is","-- thrown. +x is right, +y is down","-- @entity starfall_screen","-- @field TEXT_ALIGN_LEFT","-- @field TEXT_ALIGN_CENTER","-- @field TEXT_ALIGN_RIGHT","-- @field TEXT_ALIGN_TOP","-- @field TEXT_ALIGN_BOTTOM"],"functions":{"1":"capturePixels","2":"clear","3":"createFont","4":"createRenderTarget","5":"cursorPos","6":"drawCircle","7":"drawLine","8":"drawPoly","9":"drawRect","10":"drawRectOutline","11":"drawRoundedBox","12":"drawRoundedBoxEx","13":"drawSimpleText","14":"drawText","15":"drawTexturedRect","16":"drawTexturedRectRotated","17":"drawTexturedRectUV","18":"getDefaultFont","19":"getRenderTargetMaterial","20":"getResolution","21":"getScreenEntity","22":"getScreenInfo","23":"getTextSize","24":"getTextureID","25":"parseMarkup","26":"popMatrix","27":"popViewMatrix","28":"pushMatrix","29":"pushViewMatrix","30":"readPixel","31":"selectRenderTarget","32":"setColor","33":"setFont","34":"setRGBA","35":"setRenderTargetTexture","36":"setTexture","37":"setTextureFromScreen","drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen or screen:GetClass()~=\"starfall_screen\" then return input.GetCursorPos() end","","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","","\tlocal Normal, Pos","\t-- Get monitor screen pos & size","","\tPos = screen:LocalToWorld( screen.Origin )","","\tNormal = -screen.Transform:GetUp():GetNormalized()","","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","","\tlocal A = Normal:Dot(Dir)","","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","","\tlocal B = Normal:Dot(Pos-Start) / A","\tif (B >= 0) then","\t\tlocal w = 512/screen.Aspect","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), screen.Transform:GetTranslation(), screen.Transform:GetAngles() )","\t\tlocal x = HitPos.x/screen.Scale","\t\tlocal y = HitPos.y/screen.Scale","\t\tif x < 0 or x > w or y < 0 or y > 512 then return nil end -- Aiming off the screen","\t\treturn x, y","\tend","","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix","-- @param world Should the transformation be relative to the screen or world? "],"code":["function render_library.pushMatrix(m, world)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tif not world and renderdata.renderEnt and renderdata.renderEnt.Transform then","\t\tnewmatrix = renderdata.renderEnt.Transform * newmatrix","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","2":"world","m":"The matrix","world":"Should the transformation be relative to the screen or world?"}},"drawRoundedBoxEx":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param tl Boolean Top left corner","-- @param tr Boolean Top right corner","-- @param bl Boolean Bottom left corner","-- @param br Boolean Bottom right corner"],"code":["function render_library.drawRoundedBoxEx ( r, x, y, w, h, tl, tr, bl, br )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( tl, \"boolean\" )","\tSF.CheckType( tr, \"boolean\" )","\tSF.CheckType( bl, \"boolean\" )","\tSF.CheckType( br, \"boolean\" )","\tdraw.RoundedBoxEx( r, x, y, w, h, currentcolor, tl, tr, bl, br )","end",""],"class":"function","name":"render_library.drawRoundedBoxEx","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","6":"tl","7":"tr","8":"bl","9":"br","tr":"Boolean Top right corner","tl":"Boolean Top left corner","r":"The corner radius","w":"Width","y":"Top left corner y coordinate","h":"Height","x":"Top left corner x coordinate","br":"Boolean Bottom right corner","bl":"Boolean Bottom left corner"}},"createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blur Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- Akbar","-- \\- Coolvetica","-- \\- Roboto","-- \\- Courier New","-- \\- Verdana","-- \\- Arial","-- \\- HalfLife2","-- \\- hl2mp","-- \\- csd","-- \\- Tahoma","-- \\- Trebuchet","-- \\- Trebuchet MS","-- \\- DejaVu Sans Mono","-- \\- Lucida Console","-- \\- Times New Roman"],"code":["","function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tfont = validfonts[string.lower(font)]","\tif not font then SF.throw( \"invalid font\", 2 ) end","","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end","defaultFont = render_library.createFont(\"Default\", 16, 400, false, false, false, false, 0)",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- Akbar \n- Coolvetica \n- Roboto \n- Courier New \n- Verdana \n- Arial \n- HalfLife2 \n- hl2mp \n- csd \n- Tahoma \n- Trebuchet \n- Trebuchet MS \n- DejaVu Sans Mono \n- Lucida Console \n- Times New Roman","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","outline":"Enable outline?","font":"Base font to use","blur":"Enable blur?","weight":"Font weight (default: 400)","shadow":"Enable drop shadow?","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target"],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024 ), false }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\trt[ 3 ] = CreateMaterial( \"StarfallCustomModel_\"..name..SF.instance.data.entity:EntIndex(), \"VertexLitGeneric\", {","\t\t[ \"$model\" ] = 1,","\t} )","\trt[3]:SetTexture(\"$basetexture\", rt[1])","\t","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"setTexture":{"comment":["--- Sets the texture","-- @param id Texture table. Get it with render.getTextureID"],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id then","\t\tif texturecache[ id ] then","\t\t\tsurface.SetMaterial( texturecache[ id ] )","\t\telseif texturecachehttp[ id ] then","\t\t\tsurface.SetMaterial( texturecachehttp[ id ] )","\t\telse","\t\t\tdraw.NoTexture()","\t\tend","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture table. Get it with render.getTextureID"}},"drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"parseMarkup":{"ret":"The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject","comment":["--- Constructs a markup object for quick styled text drawing.","-- @param markup The markup string to parse","-- @param maxsize The max width of the markup","-- @return The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject"],"code":["function render_library.parseMarkup( str, maxsize )","\tSF.CheckType( str, \"string\" )","\tSF.CheckType( maxsize, \"number\" )","\tlocal marked = markup.Parse( str, maxsize )","\tlocal markedindex = marked.__index","\treturn setmetatable(marked, {","\t\t__newindex = function() end,","\t\t__index = markedindex,","\t\t__metatable = \"\"","\t})","end",""],"class":"function","name":"render_library.parseMarkup","summary":"\nConstructs a markup object for quick styled text drawing.","private":false,"library":"render","description":"\nConstructs a markup object for quick styled text drawing.","param":{"1":"str","2":"maxsize","3":"markup","markup":"The markup string to parse","maxsize":"The max width of the markup"}},"getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawText":{"comment":["--- Draws text with newlines and tabs","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.DrawText( text, font, x, y, currentcolor, alignment )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text with newlines and tabs ","private":false,"library":"render","description":"\nDraws text with newlines and tabs","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}},"getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"drawSimpleText":{"comment":["--- Draws text more easily and quickly but no new lines or tabs.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param xalign Text x alignment","-- @param yalign Text y alignment"],"code":["function render_library.drawSimpleText ( x, y, text, xalign, yalign )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif xalign then SF.CheckType( xalign, \"number\" ) end","\tif yalign then SF.CheckType( yalign, \"number\" ) end","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.SimpleText( text, font, x, y, currentcolor, xalign, yalign )","end",""],"class":"function","name":"render_library.drawSimpleText","summary":"\nDraws text more easily and quickly but no new lines or tabs.","private":false,"library":"render","description":"\nDraws text more easily and quickly but no new lines or tabs.","param":{"1":"x","2":"y","3":"text","4":"xalign","5":"yalign","y":"Y coordinate","x":"X coordinate","text":"Text to draw","yalign":"Text y alignment","xalign":"Text x alignment"}},"drawRoundedBox":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRoundedBox ( r, x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tdraw.RoundedBox( r, x, y, w, h, currentcolor )","end",""],"class":"function","name":"render_library.drawRoundedBox","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","r":"The corner radius","w":"Width","h":"Height"}},"drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif name then","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\t\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\t\tif not data.usingRT then","\t\t\tdata.oldViewPort = {0, 0, ScrW(), ScrH()}","\t\t\trender.SetViewPort( 0, 0, 1024, 1024 )","\t\t\tcam.Start2D()","\t\t\trender.SetStencilEnable( false )","\t\tend","\t\trender.SetRenderTarget( rt )","\t\tdata.usingRT = true","\telse","\t\tif data.usingRT then","\t\t\trender.SetRenderTarget()","\t\t\tcam.End2D()","\t\t\trender.SetViewPort(unpack(data.oldViewPort))","\t\t\tdata.usingRT = false","\t\t\trender.SetStencilEnable( true )","\t\tend","\tend","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"getRenderTargetMaterial":{"ret":"Model material name. Send this to the server to set the entity's material.","comment":["--- Returns the model material name that uses the render target.","--- Alternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex() ","-- @param name Render target name","-- @return Model material name. Send this to the server to set the entity's material."],"code":["function render_library.getRenderTargetMaterial( name )","\tlocal data = SF.instance.data.render","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\treturn \"!\"..tostring(globalRTs[ rtname ][ 3 ])","\tend","end",""],"class":"function","name":"render_library.getRenderTargetMaterial","summary":"\nReturns the model material name that uses the render target.","private":false,"library":"render","description":"\nReturns the model material name that uses the render target. \nAlternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex()","param":{"1":"name","name":"Render target name"}},"getResolution":{"ret":["the X size of the current render context","the Y size of the current render context"],"comment":["--- Returns the render context's width and height","-- @class function","-- @return the X size of the current render context","-- @return the Y size of the current render context"],"code":["function render_library.getResolution()","\treturn SF.instance.data.render.renderEnt:GetResolution()","end",""],"class":"function","classForced":true,"name":"render_library.getResolution","summary":"\nReturns the render context's width and height ","private":false,"library":"render","description":"\nReturns the render context's width and height","param":[]},"clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","\tif SF.instance.data.render.usingRT then","\t\tif clr == nil then","\t\t\trender.Clear( 0, 0, 0, 255 )","\t\telse","\t\t\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\t\t\trender.Clear( clr.r, clr.g, clr.b, clr.a )","\t\tend","\tend","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},"setRGBA":{"comment":["--- Sets the draw color by RGBA values"],"code":["function render_library.setRGBA( r, g, b, a )","\tSF.CheckType( r, \"number\" ) SF.CheckType( g, \"number\" ) SF.CheckType( b, \"number\" ) SF.CheckType( a, \"number\" )","\tcurrentcolor = Color( r, g, b, a )","\tsurface.SetDrawColor( r, g, b, a )","\tsurface.SetTextColor( r, g, b, a )","end",""],"class":"function","name":"render_library.setRGBA","summary":"\nSets the draw color by RGBA values ","private":false,"library":"render","description":"\nSets the draw color by RGBA values","param":["r","g","b","a"]},"drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"getTextureID":{"ret":"Texture table. Use it with render.setTexture. Returns nil if max url textures is reached.","comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url","-- @param cb Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table","-- @param alignment Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","-- @return Texture table. Use it with render.setTexture. Returns nil if max url textures is reached."],"code":["function render_library.getTextureID ( tx, cb, alignment )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","","\t\tif alignment then","\t\t\tSF.CheckType( alignment, \"string\" )","\t\t\tlocal args = string.Split( alignment, \" \" )","\t\t\tlocal validargs = {[\"left\"]=true,[\"center\"]=true,[\"right\"]=true,[\"top\"]=true,[\"bottom\"]=true}","\t\t\tif #args ~= 1 and #args ~= 2 then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tfor i=1, #args do","\t\t\t\tif not validargs[args[i]] then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tend","\t\telse","\t\t\talignment = \"center\"","\t\tend","\t\t","\t\tlocal instance = SF.instance","","\t\tlocal tbl = {}","\t\ttexturecachehttp[ tbl ] = LoadURLMaterial( tx, alignment, function()","\t\t\tif cb then","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( cb, tbl, tx )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend)","\t\tif not texturecachehttp[ tbl ] then return end","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tif not mat then return end","\t\t\tlocal cacheentry = sfCreateMaterial( \"SF_TEXTURE_\" .. id )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","2":"cb","3":"alignment","tx":"Texture file path, or a http url","alignment":"Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","cb":"Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table"}},"getScreenEntity":{"ret":"Entity of the screen or hud being rendered","comment":["--- Returns the entity currently being rendered to","-- @return Entity of the screen or hud being rendered"],"code":["function render_library.getScreenEntity()","\treturn SF.Entities.Wrap( SF.instance.data.render.renderEnt )","end",""],"class":"function","name":"render_library.getScreenEntity","summary":"\nReturns the entity currently being rendered to ","private":false,"library":"render","description":"\nReturns the entity currently being rendered to","param":[]},"setFont":{"comment":["--- Sets the font","-- @param font The font to use","-- @usage Use a font created by render.createFont or use one of these already defined fonts:","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- Default","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet24","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- HudNumbers","-- \\- DermaDefault","-- \\- DermaDefaultBold","-- \\- DermaLarge"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","summary":"\nSets the font ","name":"render_library.setFont","library":"render","private":false,"usage":"Use a font created by render.createFont or use one of these already defined fonts: \n- DebugFixed \n- DebugFixedSmall \n- Default \n- Marlett \n- Trebuchet18 \n- Trebuchet24 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- HudNumbers \n- DermaDefault \n- DermaDefaultBold \n- DermaLarge","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as world offsets, dimentions, and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @param e The screen to get info from.","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo( e )","\tlocal screen = SF.Entities.Unwrap( e )","\tif screen then","\t\treturn SF.Sanitize( screen.ScreenInfo )","\tend","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as world offsets, dimentions, and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as world offsets, dimentions, and rotation. \nNote: this does a table copy so move it out of your draw hook","param":{"1":"e","e":"The screen to get info from."}},"drawRect":{"comment":["--- Draws a rectangle using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"popViewMatrix":{"comment":["--- Pops a view matrix from the matrix stack."],"code":["function render_library.popViewMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\t","\tcam.End()","\tview_matrix_stack = view_matrix_stack - 1","end",""],"class":"function","name":"render_library.popViewMatrix","summary":"\nPops a view matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a view matrix from the matrix stack.","param":[]},"setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\tRT_Material:SetTexture( \"$basetexture\", globalRTs[ rtname ][ 1 ] )","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"pushViewMatrix":{"comment":["--- Pushes a perspective matrix onto the view matrix stack.","-- @param tbl The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"],"code":["function render_library.pushViewMatrix(tbl)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\tif tbl.type ~= \"2D\" and tbl.type ~= \"3D\" then SF.throw( \"Camera type must be \\\"3D\\\" or \\\"2D\\\"\", 2 ) end","\t","\tlocal newtbl = {}","\tfor k, v in pairs(tbl) do","\t\tif viewmatrix_checktypes[k] then","\t\t\tSF.CheckType( v, viewmatrix_checktypes[k] )","\t\t\tnewtbl[k] = v","\t\telse","\t\t\tSF.throw( \"Invalid key found in view matrix: \" .. k, 2 )","\t\tend","\tend","\tif newtbl.origin then newtbl.origin = SF.Vectors.Unwrap( newtbl.origin ) end","\tif newtbl.angles then newtbl.angles = SF.Angles.Unwrap( newtbl.angles ) end","\tif newtbl.offcenter then","\t\tSF.CheckType( tbl.offcenter.left, \"number\" )","\t\tSF.CheckType( tbl.offcenter.right, \"number\" )","\t\tSF.CheckType( tbl.offcenter.bottom, \"number\" )","\t\tSF.CheckType( tbl.offcenter.top, \"number\" )","\tend","\tif newtbl.ortho then","\t\tSF.CheckType( tbl.ortho.left, \"number\" )","\t\tSF.CheckType( tbl.ortho.right, \"number\" )","\t\tSF.CheckType( tbl.ortho.bottom, \"number\" )","\t\tSF.CheckType( tbl.ortho.top, \"number\" )","\tend","\t","\tcam.Start(newtbl)","\tview_matrix_stack = view_matrix_stack + 1","end",""],"class":"function","name":"render_library.pushViewMatrix","summary":"\nPushes a perspective matrix onto the view matrix stack.","private":false,"library":"render","description":"\nPushes a perspective matrix onto the view matrix stack.","param":{"1":"tbl","tbl":"The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"}},"popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end","","","local viewmatrix_checktypes =","{","\tx = \"number\", y = \"number\", w = \"number\", h = \"number\", type = \"string\",","\torigin = SF.Vectors.Metatable, angles = SF.Angles.Metatable, fov = \"number\",","\taspect = \"number\", zfar = \"number\", znear = \"number\", subrect = \"boolean\",","\tbloomtone = \"boolean\", offcenter = \"table\", ortho = \"table\"","}"],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"drawPoly":{"comment":["--- Draws a polygon.","-- @param poly Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"],"code":["function render_library.drawPoly(poly)","\tSF.CheckType(poly,\"table\")","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon.","param":{"1":"poly","poly":"Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"}},"capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\tif SF.instance.data.render.usingRT then","\t\trender.CapturePixels()","\tend","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"setTextureFromScreen":{"comment":["--- Sets the texture of a screen entity","-- @param ent Screen entity"],"code":["function render_library.setTextureFromScreen ( ent )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","","\tent = SF.Entities.Unwrap( ent )","\tif IsValid( ent ) and ent.GPU and ent.GPU.RT then","\t\tRT_Material:SetTexture(\"$basetexture\", ent.GPU.RT)","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","","end",""],"class":"function","name":"render_library.setTextureFromScreen","summary":"\nSets the texture of a screen entity ","private":false,"library":"render","description":"\nSets the texture of a screen entity","param":{"1":"ent","ent":"Screen entity"}}},"class":"library","summary":"\nRender library.","code":["","local render_library, _ = SF.Libraries.RegisterLocal(\"render\")","","render_library.TEXT_ALIGN_LEFT = TEXT_ALIGN_LEFT","render_library.TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER","render_library.TEXT_ALIGN_RIGHT = TEXT_ALIGN_RIGHT","render_library.TEXT_ALIGN_TOP = TEXT_ALIGN_TOP","render_library.TEXT_ALIGN_BOTTOM = TEXT_ALIGN_BOTTOM",""],"fields":[],"name":"render","description":"\nRender library. Screens are 512x512 units. Most functions require \nthat you be in the rendering hook to call, otherwise an error is \nthrown. +x is right, +y is down","entity":"starfall_screen","libtbl":"render_library","tables":[],"field":{"1":"TEXT_ALIGN_LEFT","2":"TEXT_ALIGN_CENTER","3":"TEXT_ALIGN_RIGHT","4":"TEXT_ALIGN_TOP","5":"TEXT_ALIGN_BOTTOM","TEXT_ALIGN_CENTER":"","TEXT_ALIGN_TOP":"","TEXT_ALIGN_BOTTOM":"","TEXT_ALIGN_LEFT":"","TEXT_ALIGN_RIGHT":""}}},"type":"file","name":"libs_cl/render.lua","functions":{"1":"render_library.capturePixels","2":"render_library.clear","3":"render_library.createFont","4":"render_library.createRenderTarget","5":"render_library.cursorPos","6":"render_library.drawCircle","7":"render_library.drawLine","8":"render_library.drawPoly","9":"render_library.drawRect","10":"render_library.drawRectOutline","11":"render_library.drawRoundedBox","12":"render_library.drawRoundedBoxEx","13":"render_library.drawSimpleText","14":"render_library.drawText","15":"render_library.drawTexturedRect","16":"render_library.drawTexturedRectRotated","17":"render_library.drawTexturedRectUV","18":"render_library.getDefaultFont","19":"render_library.getRenderTargetMaterial","20":"render_library.getResolution","21":"render_library.getScreenEntity","22":"render_library.getScreenInfo","23":"render_library.getTextSize","24":"render_library.getTextureID","25":"render_library.parseMarkup","26":"render_library.popMatrix","27":"render_library.popViewMatrix","28":"render_library.pushMatrix","29":"render_library.pushViewMatrix","30":"render_library.readPixel","31":"render_library.selectRenderTarget","32":"render_library.setColor","33":"render_library.setFont","34":"render_library.setRGBA","35":"render_library.setRenderTargetTexture","36":"render_library.setTexture","37":"render_library.setTextureFromScreen","render_library.drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"render_library.readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"render_library.getTextureID":{"ret":"Texture table. Use it with render.setTexture. Returns nil if max url textures is reached.","comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url","-- @param cb Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table","-- @param alignment Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","-- @return Texture table. Use it with render.setTexture. Returns nil if max url textures is reached."],"code":["function render_library.getTextureID ( tx, cb, alignment )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","","\t\tif alignment then","\t\t\tSF.CheckType( alignment, \"string\" )","\t\t\tlocal args = string.Split( alignment, \" \" )","\t\t\tlocal validargs = {[\"left\"]=true,[\"center\"]=true,[\"right\"]=true,[\"top\"]=true,[\"bottom\"]=true}","\t\t\tif #args ~= 1 and #args ~= 2 then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tfor i=1, #args do","\t\t\t\tif not validargs[args[i]] then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tend","\t\telse","\t\t\talignment = \"center\"","\t\tend","\t\t","\t\tlocal instance = SF.instance","","\t\tlocal tbl = {}","\t\ttexturecachehttp[ tbl ] = LoadURLMaterial( tx, alignment, function()","\t\t\tif cb then","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( cb, tbl, tx )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend)","\t\tif not texturecachehttp[ tbl ] then return end","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tif not mat then return end","\t\t\tlocal cacheentry = sfCreateMaterial( \"SF_TEXTURE_\" .. id )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","2":"cb","3":"alignment","tx":"Texture file path, or a http url","alignment":"Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","cb":"Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table"}},"render_library.setRGBA":{"comment":["--- Sets the draw color by RGBA values"],"code":["function render_library.setRGBA( r, g, b, a )","\tSF.CheckType( r, \"number\" ) SF.CheckType( g, \"number\" ) SF.CheckType( b, \"number\" ) SF.CheckType( a, \"number\" )","\tcurrentcolor = Color( r, g, b, a )","\tsurface.SetDrawColor( r, g, b, a )","\tsurface.SetTextColor( r, g, b, a )","end",""],"class":"function","name":"render_library.setRGBA","summary":"\nSets the draw color by RGBA values ","private":false,"library":"render","description":"\nSets the draw color by RGBA values","param":["r","g","b","a"]},"render_library.getScreenEntity":{"ret":"Entity of the screen or hud being rendered","comment":["--- Returns the entity currently being rendered to","-- @return Entity of the screen or hud being rendered"],"code":["function render_library.getScreenEntity()","\treturn SF.Entities.Wrap( SF.instance.data.render.renderEnt )","end",""],"class":"function","name":"render_library.getScreenEntity","summary":"\nReturns the entity currently being rendered to ","private":false,"library":"render","description":"\nReturns the entity currently being rendered to","param":[]},"render_library.pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix","-- @param world Should the transformation be relative to the screen or world? "],"code":["function render_library.pushMatrix(m, world)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tif not world and renderdata.renderEnt and renderdata.renderEnt.Transform then","\t\tnewmatrix = renderdata.renderEnt.Transform * newmatrix","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","2":"world","m":"The matrix","world":"Should the transformation be relative to the screen or world?"}},"render_library.drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"render_library.selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif name then","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\t\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\t\tif not data.usingRT then","\t\t\tdata.oldViewPort = {0, 0, ScrW(), ScrH()}","\t\t\trender.SetViewPort( 0, 0, 1024, 1024 )","\t\t\tcam.Start2D()","\t\t\trender.SetStencilEnable( false )","\t\tend","\t\trender.SetRenderTarget( rt )","\t\tdata.usingRT = true","\telse","\t\tif data.usingRT then","\t\t\trender.SetRenderTarget()","\t\t\tcam.End2D()","\t\t\trender.SetViewPort(unpack(data.oldViewPort))","\t\t\tdata.usingRT = false","\t\t\trender.SetStencilEnable( true )","\t\tend","\tend","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"render_library.cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen or screen:GetClass()~=\"starfall_screen\" then return input.GetCursorPos() end","","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","","\tlocal Normal, Pos","\t-- Get monitor screen pos & size","","\tPos = screen:LocalToWorld( screen.Origin )","","\tNormal = -screen.Transform:GetUp():GetNormalized()","","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","","\tlocal A = Normal:Dot(Dir)","","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","","\tlocal B = Normal:Dot(Pos-Start) / A","\tif (B >= 0) then","\t\tlocal w = 512/screen.Aspect","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), screen.Transform:GetTranslation(), screen.Transform:GetAngles() )","\t\tlocal x = HitPos.x/screen.Scale","\t\tlocal y = HitPos.y/screen.Scale","\t\tif x < 0 or x > w or y < 0 or y > 512 then return nil end -- Aiming off the screen","\t\treturn x, y","\tend","","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"render_library.popViewMatrix":{"comment":["--- Pops a view matrix from the matrix stack."],"code":["function render_library.popViewMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\t","\tcam.End()","\tview_matrix_stack = view_matrix_stack - 1","end",""],"class":"function","name":"render_library.popViewMatrix","summary":"\nPops a view matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a view matrix from the matrix stack.","param":[]},"render_library.setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\tRT_Material:SetTexture( \"$basetexture\", globalRTs[ rtname ][ 1 ] )","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"render_library.parseMarkup":{"ret":"The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject","comment":["--- Constructs a markup object for quick styled text drawing.","-- @param markup The markup string to parse","-- @param maxsize The max width of the markup","-- @return The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject"],"code":["function render_library.parseMarkup( str, maxsize )","\tSF.CheckType( str, \"string\" )","\tSF.CheckType( maxsize, \"number\" )","\tlocal marked = markup.Parse( str, maxsize )","\tlocal markedindex = marked.__index","\treturn setmetatable(marked, {","\t\t__newindex = function() end,","\t\t__index = markedindex,","\t\t__metatable = \"\"","\t})","end",""],"class":"function","name":"render_library.parseMarkup","summary":"\nConstructs a markup object for quick styled text drawing.","private":false,"library":"render","description":"\nConstructs a markup object for quick styled text drawing.","param":{"1":"str","2":"maxsize","3":"markup","markup":"The markup string to parse","maxsize":"The max width of the markup"}},"render_library.setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}},"render_library.drawRect":{"comment":["--- Draws a rectangle using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"render_library.drawText":{"comment":["--- Draws text with newlines and tabs","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.DrawText( text, font, x, y, currentcolor, alignment )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text with newlines and tabs ","private":false,"library":"render","description":"\nDraws text with newlines and tabs","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"render_library.setTextureFromScreen":{"comment":["--- Sets the texture of a screen entity","-- @param ent Screen entity"],"code":["function render_library.setTextureFromScreen ( ent )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","","\tent = SF.Entities.Unwrap( ent )","\tif IsValid( ent ) and ent.GPU and ent.GPU.RT then","\t\tRT_Material:SetTexture(\"$basetexture\", ent.GPU.RT)","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","","end",""],"class":"function","name":"render_library.setTextureFromScreen","summary":"\nSets the texture of a screen entity ","private":false,"library":"render","description":"\nSets the texture of a screen entity","param":{"1":"ent","ent":"Screen entity"}},"render_library.drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"render_library.getResolution":{"ret":["the X size of the current render context","the Y size of the current render context"],"comment":["--- Returns the render context's width and height","-- @class function","-- @return the X size of the current render context","-- @return the Y size of the current render context"],"code":["function render_library.getResolution()","\treturn SF.instance.data.render.renderEnt:GetResolution()","end",""],"class":"function","classForced":true,"name":"render_library.getResolution","summary":"\nReturns the render context's width and height ","private":false,"library":"render","description":"\nReturns the render context's width and height","param":[]},"render_library.getRenderTargetMaterial":{"ret":"Model material name. Send this to the server to set the entity's material.","comment":["--- Returns the model material name that uses the render target.","--- Alternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex() ","-- @param name Render target name","-- @return Model material name. Send this to the server to set the entity's material."],"code":["function render_library.getRenderTargetMaterial( name )","\tlocal data = SF.instance.data.render","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\treturn \"!\"..tostring(globalRTs[ rtname ][ 3 ])","\tend","end",""],"class":"function","name":"render_library.getRenderTargetMaterial","summary":"\nReturns the model material name that uses the render target.","private":false,"library":"render","description":"\nReturns the model material name that uses the render target. \nAlternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex()","param":{"1":"name","name":"Render target name"}},"render_library.setTexture":{"comment":["--- Sets the texture","-- @param id Texture table. Get it with render.getTextureID"],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id then","\t\tif texturecache[ id ] then","\t\t\tsurface.SetMaterial( texturecache[ id ] )","\t\telseif texturecachehttp[ id ] then","\t\t\tsurface.SetMaterial( texturecachehttp[ id ] )","\t\telse","\t\t\tdraw.NoTexture()","\t\tend","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture table. Get it with render.getTextureID"}},"render_library.drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"render_library.createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target"],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024 ), false }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\trt[ 3 ] = CreateMaterial( \"StarfallCustomModel_\"..name..SF.instance.data.entity:EntIndex(), \"VertexLitGeneric\", {","\t\t[ \"$model\" ] = 1,","\t} )","\trt[3]:SetTexture(\"$basetexture\", rt[1])","\t","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"render_library.getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as world offsets, dimentions, and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @param e The screen to get info from.","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo( e )","\tlocal screen = SF.Entities.Unwrap( e )","\tif screen then","\t\treturn SF.Sanitize( screen.ScreenInfo )","\tend","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as world offsets, dimentions, and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as world offsets, dimentions, and rotation. \nNote: this does a table copy so move it out of your draw hook","param":{"1":"e","e":"The screen to get info from."}},"render_library.drawPoly":{"comment":["--- Draws a polygon.","-- @param poly Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"],"code":["function render_library.drawPoly(poly)","\tSF.CheckType(poly,\"table\")","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon.","param":{"1":"poly","poly":"Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"}},"render_library.createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blur Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- Akbar","-- \\- Coolvetica","-- \\- Roboto","-- \\- Courier New","-- \\- Verdana","-- \\- Arial","-- \\- HalfLife2","-- \\- hl2mp","-- \\- csd","-- \\- Tahoma","-- \\- Trebuchet","-- \\- Trebuchet MS","-- \\- DejaVu Sans Mono","-- \\- Lucida Console","-- \\- Times New Roman"],"code":["","function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tfont = validfonts[string.lower(font)]","\tif not font then SF.throw( \"invalid font\", 2 ) end","","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end","defaultFont = render_library.createFont(\"Default\", 16, 400, false, false, false, false, 0)",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- Akbar \n- Coolvetica \n- Roboto \n- Courier New \n- Verdana \n- Arial \n- HalfLife2 \n- hl2mp \n- csd \n- Tahoma \n- Trebuchet \n- Trebuchet MS \n- DejaVu Sans Mono \n- Lucida Console \n- Times New Roman","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","outline":"Enable outline?","font":"Base font to use","blur":"Enable blur?","weight":"Font weight (default: 400)","shadow":"Enable drop shadow?","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"render_library.drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"render_library.drawSimpleText":{"comment":["--- Draws text more easily and quickly but no new lines or tabs.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param xalign Text x alignment","-- @param yalign Text y alignment"],"code":["function render_library.drawSimpleText ( x, y, text, xalign, yalign )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif xalign then SF.CheckType( xalign, \"number\" ) end","\tif yalign then SF.CheckType( yalign, \"number\" ) end","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.SimpleText( text, font, x, y, currentcolor, xalign, yalign )","end",""],"class":"function","name":"render_library.drawSimpleText","summary":"\nDraws text more easily and quickly but no new lines or tabs.","private":false,"library":"render","description":"\nDraws text more easily and quickly but no new lines or tabs.","param":{"1":"x","2":"y","3":"text","4":"xalign","5":"yalign","y":"Y coordinate","x":"X coordinate","text":"Text to draw","yalign":"Text y alignment","xalign":"Text x alignment"}},"render_library.drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"render_library.drawRoundedBoxEx":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param tl Boolean Top left corner","-- @param tr Boolean Top right corner","-- @param bl Boolean Bottom left corner","-- @param br Boolean Bottom right corner"],"code":["function render_library.drawRoundedBoxEx ( r, x, y, w, h, tl, tr, bl, br )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( tl, \"boolean\" )","\tSF.CheckType( tr, \"boolean\" )","\tSF.CheckType( bl, \"boolean\" )","\tSF.CheckType( br, \"boolean\" )","\tdraw.RoundedBoxEx( r, x, y, w, h, currentcolor, tl, tr, bl, br )","end",""],"class":"function","name":"render_library.drawRoundedBoxEx","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","6":"tl","7":"tr","8":"bl","9":"br","tr":"Boolean Top right corner","tl":"Boolean Top left corner","r":"The corner radius","w":"Width","y":"Top left corner y coordinate","h":"Height","x":"Top left corner x coordinate","br":"Boolean Bottom right corner","bl":"Boolean Bottom left corner"}},"render_library.popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end","","","local viewmatrix_checktypes =","{","\tx = \"number\", y = \"number\", w = \"number\", h = \"number\", type = \"string\",","\torigin = SF.Vectors.Metatable, angles = SF.Angles.Metatable, fov = \"number\",","\taspect = \"number\", zfar = \"number\", znear = \"number\", subrect = \"boolean\",","\tbloomtone = \"boolean\", offcenter = \"table\", ortho = \"table\"","}"],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"render_library.capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\tif SF.instance.data.render.usingRT then","\t\trender.CapturePixels()","\tend","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"render_library.getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"render_library.setFont":{"comment":["--- Sets the font","-- @param font The font to use","-- @usage Use a font created by render.createFont or use one of these already defined fonts:","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- Default","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet24","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- HudNumbers","-- \\- DermaDefault","-- \\- DermaDefaultBold","-- \\- DermaLarge"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","summary":"\nSets the font ","name":"render_library.setFont","library":"render","private":false,"usage":"Use a font created by render.createFont or use one of these already defined fonts: \n- DebugFixed \n- DebugFixedSmall \n- Default \n- Marlett \n- Trebuchet18 \n- Trebuchet24 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- HudNumbers \n- DermaDefault \n- DermaDefaultBold \n- DermaLarge","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"render_library.drawRoundedBox":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRoundedBox ( r, x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tdraw.RoundedBox( r, x, y, w, h, currentcolor )","end",""],"class":"function","name":"render_library.drawRoundedBox","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","r":"The corner radius","w":"Width","h":"Height"}},"render_library.pushViewMatrix":{"comment":["--- Pushes a perspective matrix onto the view matrix stack.","-- @param tbl The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"],"code":["function render_library.pushViewMatrix(tbl)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\tif tbl.type ~= \"2D\" and tbl.type ~= \"3D\" then SF.throw( \"Camera type must be \\\"3D\\\" or \\\"2D\\\"\", 2 ) end","\t","\tlocal newtbl = {}","\tfor k, v in pairs(tbl) do","\t\tif viewmatrix_checktypes[k] then","\t\t\tSF.CheckType( v, viewmatrix_checktypes[k] )","\t\t\tnewtbl[k] = v","\t\telse","\t\t\tSF.throw( \"Invalid key found in view matrix: \" .. k, 2 )","\t\tend","\tend","\tif newtbl.origin then newtbl.origin = SF.Vectors.Unwrap( newtbl.origin ) end","\tif newtbl.angles then newtbl.angles = SF.Angles.Unwrap( newtbl.angles ) end","\tif newtbl.offcenter then","\t\tSF.CheckType( tbl.offcenter.left, \"number\" )","\t\tSF.CheckType( tbl.offcenter.right, \"number\" )","\t\tSF.CheckType( tbl.offcenter.bottom, \"number\" )","\t\tSF.CheckType( tbl.offcenter.top, \"number\" )","\tend","\tif newtbl.ortho then","\t\tSF.CheckType( tbl.ortho.left, \"number\" )","\t\tSF.CheckType( tbl.ortho.right, \"number\" )","\t\tSF.CheckType( tbl.ortho.bottom, \"number\" )","\t\tSF.CheckType( tbl.ortho.top, \"number\" )","\tend","\t","\tcam.Start(newtbl)","\tview_matrix_stack = view_matrix_stack + 1","end",""],"class":"function","name":"render_library.pushViewMatrix","summary":"\nPushes a perspective matrix onto the view matrix stack.","private":false,"library":"render","description":"\nPushes a perspective matrix onto the view matrix stack.","param":{"1":"tbl","tbl":"The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"}},"render_library.getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"render_library.clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","\tif SF.instance.data.render.usingRT then","\t\tif clr == nil then","\t\t\trender.Clear( 0, 0, 0, 255 )","\t\telse","\t\t\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\t\t\trender.Clear( clr.r, clr.g, clr.b, clr.a )","\t\tend","\tend","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}}},"doc":[{"summary":"\n \nRender library \n ","description":"\n \nRender library \n","comment":["-------------------------------------------------------------------------------","-- Render library","-------------------------------------------------------------------------------"],"code":[""]},{"description":"\nCalled when a frame is requested to be drawn.","code":["",""],"class":"hook","classForced":true,"name":"render","summary":"\nCalled when a frame is requested to be drawn.","client":true,"comment":["--- Called when a frame is requested to be drawn.","-- @name render","-- @class hook","-- @client"],"param":[]},{"ret":"table Table containing information for the camera. {origin=camera origin, angles=camera angles, fov=camera fov, znear=znear, zfar=zfar, drawviewer=drawviewer}","description":"\nCalled when the engine wants to calculate the player's view","code":[""],"class":"hook","classForced":true,"name":"calcview","summary":"\nCalled when the engine wants to calculate the player's view ","client":true,"comment":["--- Called when the engine wants to calculate the player's view","-- @name calcview","-- @class hook","-- @client","-- @param pos Current position of the camera","-- @param ang Current angles of the camera","-- @param fov Current fov of the camera","-- @param znear Current near plane of the camera","-- @param zfar Current far plane of the camera","-- @return table Table containing information for the camera. {origin=camera origin, angles=camera angles, fov=camera fov, znear=znear, zfar=zfar, drawviewer=drawviewer}"],"param":{"1":"pos","2":"ang","3":"fov","4":"znear","5":"zfar","fov":"Current fov of the camera","ang":"Current angles of the camera","zfar":"Current far plane of the camera","znear":"Current near plane of the camera","pos":"Current position of the camera"}},{"comment":["--- Render library. Screens are 512x512 units. Most functions require","-- that you be in the rendering hook to call, otherwise an error is","-- thrown. +x is right, +y is down","-- @entity starfall_screen","-- @field TEXT_ALIGN_LEFT","-- @field TEXT_ALIGN_CENTER","-- @field TEXT_ALIGN_RIGHT","-- @field TEXT_ALIGN_TOP","-- @field TEXT_ALIGN_BOTTOM"],"functions":{"1":"capturePixels","2":"clear","3":"createFont","4":"createRenderTarget","5":"cursorPos","6":"drawCircle","7":"drawLine","8":"drawPoly","9":"drawRect","10":"drawRectOutline","11":"drawRoundedBox","12":"drawRoundedBoxEx","13":"drawSimpleText","14":"drawText","15":"drawTexturedRect","16":"drawTexturedRectRotated","17":"drawTexturedRectUV","18":"getDefaultFont","19":"getRenderTargetMaterial","20":"getResolution","21":"getScreenEntity","22":"getScreenInfo","23":"getTextSize","24":"getTextureID","25":"parseMarkup","26":"popMatrix","27":"popViewMatrix","28":"pushMatrix","29":"pushViewMatrix","30":"readPixel","31":"selectRenderTarget","32":"setColor","33":"setFont","34":"setRGBA","35":"setRenderTargetTexture","36":"setTexture","37":"setTextureFromScreen","drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen or screen:GetClass()~=\"starfall_screen\" then return input.GetCursorPos() end","","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","","\tlocal Normal, Pos","\t-- Get monitor screen pos & size","","\tPos = screen:LocalToWorld( screen.Origin )","","\tNormal = -screen.Transform:GetUp():GetNormalized()","","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","","\tlocal A = Normal:Dot(Dir)","","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","","\tlocal B = Normal:Dot(Pos-Start) / A","\tif (B >= 0) then","\t\tlocal w = 512/screen.Aspect","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), screen.Transform:GetTranslation(), screen.Transform:GetAngles() )","\t\tlocal x = HitPos.x/screen.Scale","\t\tlocal y = HitPos.y/screen.Scale","\t\tif x < 0 or x > w or y < 0 or y > 512 then return nil end -- Aiming off the screen","\t\treturn x, y","\tend","","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix","-- @param world Should the transformation be relative to the screen or world? "],"code":["function render_library.pushMatrix(m, world)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tif not world and renderdata.renderEnt and renderdata.renderEnt.Transform then","\t\tnewmatrix = renderdata.renderEnt.Transform * newmatrix","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","2":"world","m":"The matrix","world":"Should the transformation be relative to the screen or world?"}},"drawRoundedBoxEx":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param tl Boolean Top left corner","-- @param tr Boolean Top right corner","-- @param bl Boolean Bottom left corner","-- @param br Boolean Bottom right corner"],"code":["function render_library.drawRoundedBoxEx ( r, x, y, w, h, tl, tr, bl, br )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( tl, \"boolean\" )","\tSF.CheckType( tr, \"boolean\" )","\tSF.CheckType( bl, \"boolean\" )","\tSF.CheckType( br, \"boolean\" )","\tdraw.RoundedBoxEx( r, x, y, w, h, currentcolor, tl, tr, bl, br )","end",""],"class":"function","name":"render_library.drawRoundedBoxEx","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","6":"tl","7":"tr","8":"bl","9":"br","tr":"Boolean Top right corner","tl":"Boolean Top left corner","r":"The corner radius","w":"Width","y":"Top left corner y coordinate","h":"Height","x":"Top left corner x coordinate","br":"Boolean Bottom right corner","bl":"Boolean Bottom left corner"}},"createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blur Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- Akbar","-- \\- Coolvetica","-- \\- Roboto","-- \\- Courier New","-- \\- Verdana","-- \\- Arial","-- \\- HalfLife2","-- \\- hl2mp","-- \\- csd","-- \\- Tahoma","-- \\- Trebuchet","-- \\- Trebuchet MS","-- \\- DejaVu Sans Mono","-- \\- Lucida Console","-- \\- Times New Roman"],"code":["","function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tfont = validfonts[string.lower(font)]","\tif not font then SF.throw( \"invalid font\", 2 ) end","","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end","defaultFont = render_library.createFont(\"Default\", 16, 400, false, false, false, false, 0)",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- Akbar \n- Coolvetica \n- Roboto \n- Courier New \n- Verdana \n- Arial \n- HalfLife2 \n- hl2mp \n- csd \n- Tahoma \n- Trebuchet \n- Trebuchet MS \n- DejaVu Sans Mono \n- Lucida Console \n- Times New Roman","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","outline":"Enable outline?","font":"Base font to use","blur":"Enable blur?","weight":"Font weight (default: 400)","shadow":"Enable drop shadow?","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target"],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024 ), false }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\trt[ 3 ] = CreateMaterial( \"StarfallCustomModel_\"..name..SF.instance.data.entity:EntIndex(), \"VertexLitGeneric\", {","\t\t[ \"$model\" ] = 1,","\t} )","\trt[3]:SetTexture(\"$basetexture\", rt[1])","\t","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"setTexture":{"comment":["--- Sets the texture","-- @param id Texture table. Get it with render.getTextureID"],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id then","\t\tif texturecache[ id ] then","\t\t\tsurface.SetMaterial( texturecache[ id ] )","\t\telseif texturecachehttp[ id ] then","\t\t\tsurface.SetMaterial( texturecachehttp[ id ] )","\t\telse","\t\t\tdraw.NoTexture()","\t\tend","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture table. Get it with render.getTextureID"}},"drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"parseMarkup":{"ret":"The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject","comment":["--- Constructs a markup object for quick styled text drawing.","-- @param markup The markup string to parse","-- @param maxsize The max width of the markup","-- @return The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject"],"code":["function render_library.parseMarkup( str, maxsize )","\tSF.CheckType( str, \"string\" )","\tSF.CheckType( maxsize, \"number\" )","\tlocal marked = markup.Parse( str, maxsize )","\tlocal markedindex = marked.__index","\treturn setmetatable(marked, {","\t\t__newindex = function() end,","\t\t__index = markedindex,","\t\t__metatable = \"\"","\t})","end",""],"class":"function","name":"render_library.parseMarkup","summary":"\nConstructs a markup object for quick styled text drawing.","private":false,"library":"render","description":"\nConstructs a markup object for quick styled text drawing.","param":{"1":"str","2":"maxsize","3":"markup","markup":"The markup string to parse","maxsize":"The max width of the markup"}},"getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawText":{"comment":["--- Draws text with newlines and tabs","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.DrawText( text, font, x, y, currentcolor, alignment )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text with newlines and tabs ","private":false,"library":"render","description":"\nDraws text with newlines and tabs","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}},"getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"drawSimpleText":{"comment":["--- Draws text more easily and quickly but no new lines or tabs.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param xalign Text x alignment","-- @param yalign Text y alignment"],"code":["function render_library.drawSimpleText ( x, y, text, xalign, yalign )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif xalign then SF.CheckType( xalign, \"number\" ) end","\tif yalign then SF.CheckType( yalign, \"number\" ) end","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.SimpleText( text, font, x, y, currentcolor, xalign, yalign )","end",""],"class":"function","name":"render_library.drawSimpleText","summary":"\nDraws text more easily and quickly but no new lines or tabs.","private":false,"library":"render","description":"\nDraws text more easily and quickly but no new lines or tabs.","param":{"1":"x","2":"y","3":"text","4":"xalign","5":"yalign","y":"Y coordinate","x":"X coordinate","text":"Text to draw","yalign":"Text y alignment","xalign":"Text x alignment"}},"drawRoundedBox":{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRoundedBox ( r, x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tdraw.RoundedBox( r, x, y, w, h, currentcolor )","end",""],"class":"function","name":"render_library.drawRoundedBox","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","r":"The corner radius","w":"Width","h":"Height"}},"drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif name then","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\t\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\t\tif not data.usingRT then","\t\t\tdata.oldViewPort = {0, 0, ScrW(), ScrH()}","\t\t\trender.SetViewPort( 0, 0, 1024, 1024 )","\t\t\tcam.Start2D()","\t\t\trender.SetStencilEnable( false )","\t\tend","\t\trender.SetRenderTarget( rt )","\t\tdata.usingRT = true","\telse","\t\tif data.usingRT then","\t\t\trender.SetRenderTarget()","\t\t\tcam.End2D()","\t\t\trender.SetViewPort(unpack(data.oldViewPort))","\t\t\tdata.usingRT = false","\t\t\trender.SetStencilEnable( true )","\t\tend","\tend","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"getRenderTargetMaterial":{"ret":"Model material name. Send this to the server to set the entity's material.","comment":["--- Returns the model material name that uses the render target.","--- Alternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex() ","-- @param name Render target name","-- @return Model material name. Send this to the server to set the entity's material."],"code":["function render_library.getRenderTargetMaterial( name )","\tlocal data = SF.instance.data.render","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\treturn \"!\"..tostring(globalRTs[ rtname ][ 3 ])","\tend","end",""],"class":"function","name":"render_library.getRenderTargetMaterial","summary":"\nReturns the model material name that uses the render target.","private":false,"library":"render","description":"\nReturns the model material name that uses the render target. \nAlternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex()","param":{"1":"name","name":"Render target name"}},"getResolution":{"ret":["the X size of the current render context","the Y size of the current render context"],"comment":["--- Returns the render context's width and height","-- @class function","-- @return the X size of the current render context","-- @return the Y size of the current render context"],"code":["function render_library.getResolution()","\treturn SF.instance.data.render.renderEnt:GetResolution()","end",""],"class":"function","classForced":true,"name":"render_library.getResolution","summary":"\nReturns the render context's width and height ","private":false,"library":"render","description":"\nReturns the render context's width and height","param":[]},"clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","\tif SF.instance.data.render.usingRT then","\t\tif clr == nil then","\t\t\trender.Clear( 0, 0, 0, 255 )","\t\telse","\t\t\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\t\t\trender.Clear( clr.r, clr.g, clr.b, clr.a )","\t\tend","\tend","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},"setRGBA":{"comment":["--- Sets the draw color by RGBA values"],"code":["function render_library.setRGBA( r, g, b, a )","\tSF.CheckType( r, \"number\" ) SF.CheckType( g, \"number\" ) SF.CheckType( b, \"number\" ) SF.CheckType( a, \"number\" )","\tcurrentcolor = Color( r, g, b, a )","\tsurface.SetDrawColor( r, g, b, a )","\tsurface.SetTextColor( r, g, b, a )","end",""],"class":"function","name":"render_library.setRGBA","summary":"\nSets the draw color by RGBA values ","private":false,"library":"render","description":"\nSets the draw color by RGBA values","param":["r","g","b","a"]},"drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"getTextureID":{"ret":"Texture table. Use it with render.setTexture. Returns nil if max url textures is reached.","comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url","-- @param cb Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table","-- @param alignment Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","-- @return Texture table. Use it with render.setTexture. Returns nil if max url textures is reached."],"code":["function render_library.getTextureID ( tx, cb, alignment )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","","\t\tif alignment then","\t\t\tSF.CheckType( alignment, \"string\" )","\t\t\tlocal args = string.Split( alignment, \" \" )","\t\t\tlocal validargs = {[\"left\"]=true,[\"center\"]=true,[\"right\"]=true,[\"top\"]=true,[\"bottom\"]=true}","\t\t\tif #args ~= 1 and #args ~= 2 then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tfor i=1, #args do","\t\t\t\tif not validargs[args[i]] then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tend","\t\telse","\t\t\talignment = \"center\"","\t\tend","\t\t","\t\tlocal instance = SF.instance","","\t\tlocal tbl = {}","\t\ttexturecachehttp[ tbl ] = LoadURLMaterial( tx, alignment, function()","\t\t\tif cb then","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( cb, tbl, tx )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend)","\t\tif not texturecachehttp[ tbl ] then return end","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tif not mat then return end","\t\t\tlocal cacheentry = sfCreateMaterial( \"SF_TEXTURE_\" .. id )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","2":"cb","3":"alignment","tx":"Texture file path, or a http url","alignment":"Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","cb":"Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table"}},"getScreenEntity":{"ret":"Entity of the screen or hud being rendered","comment":["--- Returns the entity currently being rendered to","-- @return Entity of the screen or hud being rendered"],"code":["function render_library.getScreenEntity()","\treturn SF.Entities.Wrap( SF.instance.data.render.renderEnt )","end",""],"class":"function","name":"render_library.getScreenEntity","summary":"\nReturns the entity currently being rendered to ","private":false,"library":"render","description":"\nReturns the entity currently being rendered to","param":[]},"setFont":{"comment":["--- Sets the font","-- @param font The font to use","-- @usage Use a font created by render.createFont or use one of these already defined fonts:","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- Default","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet24","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- HudNumbers","-- \\- DermaDefault","-- \\- DermaDefaultBold","-- \\- DermaLarge"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","summary":"\nSets the font ","name":"render_library.setFont","library":"render","private":false,"usage":"Use a font created by render.createFont or use one of these already defined fonts: \n- DebugFixed \n- DebugFixedSmall \n- Default \n- Marlett \n- Trebuchet18 \n- Trebuchet24 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- HudNumbers \n- DermaDefault \n- DermaDefaultBold \n- DermaLarge","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as world offsets, dimentions, and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @param e The screen to get info from.","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo( e )","\tlocal screen = SF.Entities.Unwrap( e )","\tif screen then","\t\treturn SF.Sanitize( screen.ScreenInfo )","\tend","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as world offsets, dimentions, and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as world offsets, dimentions, and rotation. \nNote: this does a table copy so move it out of your draw hook","param":{"1":"e","e":"The screen to get info from."}},"drawRect":{"comment":["--- Draws a rectangle using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"popViewMatrix":{"comment":["--- Pops a view matrix from the matrix stack."],"code":["function render_library.popViewMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\t","\tcam.End()","\tview_matrix_stack = view_matrix_stack - 1","end",""],"class":"function","name":"render_library.popViewMatrix","summary":"\nPops a view matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a view matrix from the matrix stack.","param":[]},"setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\tRT_Material:SetTexture( \"$basetexture\", globalRTs[ rtname ][ 1 ] )","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"pushViewMatrix":{"comment":["--- Pushes a perspective matrix onto the view matrix stack.","-- @param tbl The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"],"code":["function render_library.pushViewMatrix(tbl)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\tif tbl.type ~= \"2D\" and tbl.type ~= \"3D\" then SF.throw( \"Camera type must be \\\"3D\\\" or \\\"2D\\\"\", 2 ) end","\t","\tlocal newtbl = {}","\tfor k, v in pairs(tbl) do","\t\tif viewmatrix_checktypes[k] then","\t\t\tSF.CheckType( v, viewmatrix_checktypes[k] )","\t\t\tnewtbl[k] = v","\t\telse","\t\t\tSF.throw( \"Invalid key found in view matrix: \" .. k, 2 )","\t\tend","\tend","\tif newtbl.origin then newtbl.origin = SF.Vectors.Unwrap( newtbl.origin ) end","\tif newtbl.angles then newtbl.angles = SF.Angles.Unwrap( newtbl.angles ) end","\tif newtbl.offcenter then","\t\tSF.CheckType( tbl.offcenter.left, \"number\" )","\t\tSF.CheckType( tbl.offcenter.right, \"number\" )","\t\tSF.CheckType( tbl.offcenter.bottom, \"number\" )","\t\tSF.CheckType( tbl.offcenter.top, \"number\" )","\tend","\tif newtbl.ortho then","\t\tSF.CheckType( tbl.ortho.left, \"number\" )","\t\tSF.CheckType( tbl.ortho.right, \"number\" )","\t\tSF.CheckType( tbl.ortho.bottom, \"number\" )","\t\tSF.CheckType( tbl.ortho.top, \"number\" )","\tend","\t","\tcam.Start(newtbl)","\tview_matrix_stack = view_matrix_stack + 1","end",""],"class":"function","name":"render_library.pushViewMatrix","summary":"\nPushes a perspective matrix onto the view matrix stack.","private":false,"library":"render","description":"\nPushes a perspective matrix onto the view matrix stack.","param":{"1":"tbl","tbl":"The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"}},"popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end","","","local viewmatrix_checktypes =","{","\tx = \"number\", y = \"number\", w = \"number\", h = \"number\", type = \"string\",","\torigin = SF.Vectors.Metatable, angles = SF.Angles.Metatable, fov = \"number\",","\taspect = \"number\", zfar = \"number\", znear = \"number\", subrect = \"boolean\",","\tbloomtone = \"boolean\", offcenter = \"table\", ortho = \"table\"","}"],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"drawPoly":{"comment":["--- Draws a polygon.","-- @param poly Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"],"code":["function render_library.drawPoly(poly)","\tSF.CheckType(poly,\"table\")","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon.","param":{"1":"poly","poly":"Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"}},"capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\tif SF.instance.data.render.usingRT then","\t\trender.CapturePixels()","\tend","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"setTextureFromScreen":{"comment":["--- Sets the texture of a screen entity","-- @param ent Screen entity"],"code":["function render_library.setTextureFromScreen ( ent )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","","\tent = SF.Entities.Unwrap( ent )","\tif IsValid( ent ) and ent.GPU and ent.GPU.RT then","\t\tRT_Material:SetTexture(\"$basetexture\", ent.GPU.RT)","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","","end",""],"class":"function","name":"render_library.setTextureFromScreen","summary":"\nSets the texture of a screen entity ","private":false,"library":"render","description":"\nSets the texture of a screen entity","param":{"1":"ent","ent":"Screen entity"}}},"class":"library","summary":"\nRender library.","code":["","local render_library, _ = SF.Libraries.RegisterLocal(\"render\")","","render_library.TEXT_ALIGN_LEFT = TEXT_ALIGN_LEFT","render_library.TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER","render_library.TEXT_ALIGN_RIGHT = TEXT_ALIGN_RIGHT","render_library.TEXT_ALIGN_TOP = TEXT_ALIGN_TOP","render_library.TEXT_ALIGN_BOTTOM = TEXT_ALIGN_BOTTOM",""],"fields":[],"name":"render","description":"\nRender library. Screens are 512x512 units. Most functions require \nthat you be in the rendering hook to call, otherwise an error is \nthrown. +x is right, +y is down","entity":"starfall_screen","libtbl":"render_library","tables":[],"field":{"1":"TEXT_ALIGN_LEFT","2":"TEXT_ALIGN_CENTER","3":"TEXT_ALIGN_RIGHT","4":"TEXT_ALIGN_TOP","5":"TEXT_ALIGN_BOTTOM","TEXT_ALIGN_CENTER":"","TEXT_ALIGN_TOP":"","TEXT_ALIGN_BOTTOM":"","TEXT_ALIGN_LEFT":"","TEXT_ALIGN_RIGHT":""}},{"description":"\nVertex format","code":["","local render = render","local surface = surface","local clamp = math.Clamp","local max = math.max","local cam = cam","local dgetmeta = debug.getmetatable","local matrix_meta = SF.VMatrix.Metatable --debug.getregistry().VMatrix","","local v_unwrap = SF.VMatrix.Unwrap","","","local function sfCreateMaterial( name )","\treturn CreateMaterial( name, \"UnlitGeneric\", {","\t\t\t\t[ \"$nolod\" ] = 1,","\t\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t\t[ \"$vertexalpha\" ] = 1,","\t\t\t\t[ \"$basetexturetransform\"] = \"center .5 .5 scale 1.032 1.032 rotate 0 translate 0 0\"","\t\t\t} )","end","","local currentcolor","local MATRIX_STACK_LIMIT = 8","local matrix_stack = {}","local view_matrix_stack = 0","","local globalRTs = {}","local globalRTcount = 0","local RT_Material = sfCreateMaterial( \"SF_RT_Material\" )","","local function findAvailableRT ()","\tfor k, v in pairs( globalRTs ) do","\t\tif v[ 2 ] then","\t\t\treturn k, v","\t\tend","\tend","\treturn nil","end","","SF.Libraries.AddHook( \"prepare\", function ( instance, hook )","\tif hook == \"render\" then","\t\tcurrentcolor = Color(0,0,0,0)","\tend","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, hook )","\tif hook == \"render\" then","\t\tfor i=#matrix_stack,1,-1 do","\t\t\tcam.PopModelMatrix()","\t\t\tmatrix_stack[i] = nil","\t\tend","\t\tlocal data = instance.data.render","\t\tif data.usingRT then","\t\t\trender.SetRenderTarget()","\t\t\tcam.End2D()","\t\t\trender.SetViewPort(unpack(data.oldViewPort))","\t\t\tdata.usingRT = false","\t\tend","\t\tfor i=1, view_matrix_stack do","\t\t\tcam.End()","\t\tend","\t\tview_matrix_stack = 0","\tend","end )","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.render.rendertargets = {}","\tinstance.data.render.rendertargetcount = 0","end)","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tfor k, v in pairs( instance.data.render.rendertargets ) do","\t\tglobalRTs[ v ][ 2 ] = true -- mark as available","\tend","end )",""],"class":"table","classForced":true,"name":"Vertex Format","summary":"\nVertex format ","field":{"1":"x","2":"y","3":"u","4":"v","y":"Y coordinate","x":"X coordinate","u":"U coordinate (optional, default is 0)","v":"V coordinate (optional, default is 0)"},"comment":["--- Vertex format","-- @name Vertex Format","-- @class table","-- @field x X coordinate","-- @field y Y coordinate","-- @field u U coordinate (optional, default is 0)","-- @field v V coordinate (optional, default is 0)"],"param":[]},{"comment":["---URL Textures"],"code":["local LoadingURLQueue = {}","","local texturecache, texturecachehttp","","","local function CheckURLDownloads()","\tlocal requestTbl = LoadingURLQueue[1]","\tif requestTbl then","\t\tif requestTbl.Panel then","\t\t\tif not requestTbl.Panel:IsLoading() then","\t\t\t\ttimer.Simple(0.2,function()","\t\t\t\t\tlocal tex = requestTbl.Panel:GetHTMLMaterial():GetTexture(\"$basetexture\")","\t\t\t\t\trequestTbl.Material:SetTexture(\"$basetexture\", tex)","\t\t\t\t\trequestTbl.Panel:Remove()","\t\t\t\t\tif requestTbl.cb then requestTbl.cb() end","\t\t\t\tend)","\t\t\t\ttable.remove(LoadingURLQueue, 1)","\t\t\telse","\t\t\t\tif CurTime() > requestTbl.Timeout then","\t\t\t\t\trequestTbl.Panel:Remove()","\t\t\t\t\ttable.remove(LoadingURLQueue, 1)","\t\t\t\tend","\t\t\tend","\t\telse","\t\t\tlocal Panel = vgui.Create( \"DHTML\" )","\t\t\tPanel:SetSize( 1024, 1024 )","\t\t\tPanel:SetAlpha( 0 )","\t\t\tPanel:SetMouseInputEnabled( false )","\t\t\tPanel:SetHTML(","\t\t\t[[","\t\t\t\t<html><head><style type=\"text/css\">","\t\t\t\t\tbody {","\t\t\t\t\t\tbackground-image: url(]] .. requestTbl.Url .. [[);","\t\t\t\t\t\tbackground-size: contain;","\t\t\t\t\t\tbackground-position: ]] .. requestTbl.Alignment .. [[;","\t\t\t\t\t\tbackground-repeat: no-repeat;","\t\t\t\t\t}","\t\t\t\t</style></head><body></body></html>","\t\t\t]]","\t\t\t)","\t\t\trequestTbl.Timeout = CurTime()+10","\t\t\trequestTbl.Panel = Panel","\t\tend","\telse","\t\ttimer.Destroy(\"SF_URLMaterialChecker\")","\tend","end","","local cv_max_url_materials = CreateConVar( \"sf_render_maxurlmaterials\", \"30\", { FCVAR_REPLICATED, FCVAR_ARCHIVE } )","","local function LoadURLMaterial( url, alignment, cb )","\tif table.Count(texturecachehttp) + #LoadingURLQueue >= cv_max_url_materials:GetInt() then return end","\t","\tlocal urlmaterial = sfCreateMaterial(\"SF_TEXTURE_\" .. util.CRC(url .. SysTime()))","\t\t","\tif #LoadingURLQueue == 0 then","\t\ttimer.Create(\"SF_URLMaterialChecker\",1,0,CheckURLDownloads)","\tend","\tLoadingURLQueue[#LoadingURLQueue + 1] = {Material = urlmaterial, Url = url, Alignment = alignment, cb = cb}","\t","\treturn urlmaterial","\t","end","","texturecache = setmetatable({},{__mode = \"k\"})","texturecachehttp = setmetatable({},{__mode = \"k\"})","","local validfonts = {","\takbar = \"Akbar\",","\tcoolvetica = \"Coolvetica\",","\troboto = \"Roboto\",","\t[\"courier new\"] = \"Courier New\",","\tverdana = \"Verdana\",","\tarial = \"Arial\",","\thalflife2 = \"HalfLife2\",","\thl2mp = \"hl2mp\",","\tcsd = \"csd\",","\ttahoma = \"Tahoma\",","\ttrebuchet = \"Trebuchet\",","\t[\"trebuchet ms\"] = \"Trebuchet MS\",","\t[ \"dejavu sans mono\" ] = \"DejaVu Sans Mono\",","\t[ \"lucida console\" ] = \"Lucida Console\",","\t[ \"times new roman\" ] = \"Times New Roman\"","}","","local defined_fonts = {","\tDebugFixed = true,","\tDebugFixedSmall = true,","\tDefault = true,","\tMarlett = true,","\tTrebuchet18 = true,","\tTrebuchet24 = true,","\tHudHintTextLarge = true,","\tHudHintTextSmall = true,","\tCenterPrintText = true,","\tHudSelectionText = true,","\tCloseCaption_Normal = true,","\tCloseCaption_Bold = true,","\tCloseCaption_BoldItalic = true,","\tChatFont = true,","\tTargetID = true,","\tTargetIDSmall = true,","\tHL2MPTypeDeath = true,","\tBudgetLabel = true,","\tHudNumbers = true,","\tDermaDefault = true,","\tDermaDefaultBold = true,","\tDermaLarge = true,","}","-- Using an already defined font's name will use its font","for k, v in pairs(defined_fonts) do","\tvalidfonts[string.lower(k)] = k","end","","local defaultFont","","-- ------------------------------------------------------------------ --",""],"summary":"\nURL Textures ","description":"\nURL Textures","param":[]},{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix","-- @param world Should the transformation be relative to the screen or world? "],"code":["function render_library.pushMatrix(m, world)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tif not world and renderdata.renderEnt and renderdata.renderEnt.Transform then","\t\tnewmatrix = renderdata.renderEnt.Transform * newmatrix","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","2":"world","m":"The matrix","world":"Should the transformation be relative to the screen or world?"}},{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end","","","local viewmatrix_checktypes =","{","\tx = \"number\", y = \"number\", w = \"number\", h = \"number\", type = \"string\",","\torigin = SF.Vectors.Metatable, angles = SF.Angles.Metatable, fov = \"number\",","\taspect = \"number\", zfar = \"number\", znear = \"number\", subrect = \"boolean\",","\tbloomtone = \"boolean\", offcenter = \"table\", ortho = \"table\"","}"],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},{"comment":["--- Pushes a perspective matrix onto the view matrix stack.","-- @param tbl The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"],"code":["function render_library.pushViewMatrix(tbl)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\tif tbl.type ~= \"2D\" and tbl.type ~= \"3D\" then SF.throw( \"Camera type must be \\\"3D\\\" or \\\"2D\\\"\", 2 ) end","\t","\tlocal newtbl = {}","\tfor k, v in pairs(tbl) do","\t\tif viewmatrix_checktypes[k] then","\t\t\tSF.CheckType( v, viewmatrix_checktypes[k] )","\t\t\tnewtbl[k] = v","\t\telse","\t\t\tSF.throw( \"Invalid key found in view matrix: \" .. k, 2 )","\t\tend","\tend","\tif newtbl.origin then newtbl.origin = SF.Vectors.Unwrap( newtbl.origin ) end","\tif newtbl.angles then newtbl.angles = SF.Angles.Unwrap( newtbl.angles ) end","\tif newtbl.offcenter then","\t\tSF.CheckType( tbl.offcenter.left, \"number\" )","\t\tSF.CheckType( tbl.offcenter.right, \"number\" )","\t\tSF.CheckType( tbl.offcenter.bottom, \"number\" )","\t\tSF.CheckType( tbl.offcenter.top, \"number\" )","\tend","\tif newtbl.ortho then","\t\tSF.CheckType( tbl.ortho.left, \"number\" )","\t\tSF.CheckType( tbl.ortho.right, \"number\" )","\t\tSF.CheckType( tbl.ortho.bottom, \"number\" )","\t\tSF.CheckType( tbl.ortho.top, \"number\" )","\tend","\t","\tcam.Start(newtbl)","\tview_matrix_stack = view_matrix_stack + 1","end",""],"class":"function","name":"render_library.pushViewMatrix","summary":"\nPushes a perspective matrix onto the view matrix stack.","private":false,"library":"render","description":"\nPushes a perspective matrix onto the view matrix stack.","param":{"1":"tbl","tbl":"The view matrix data. See http://wiki.garrysmod.com/page/Structures/RenderCamData"}},{"comment":["--- Pops a view matrix from the matrix stack."],"code":["function render_library.popViewMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif view_matrix_stack == 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tif renderdata.usingRT then SF.throw( \"Can't start a new context within a 2D rendertarget\", 2 ) end","\t","\tcam.End()","\tview_matrix_stack = view_matrix_stack - 1","end",""],"class":"function","name":"render_library.popViewMatrix","summary":"\nPops a view matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a view matrix from the matrix stack.","param":[]},{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}},{"comment":["--- Sets the draw color by RGBA values"],"code":["function render_library.setRGBA( r, g, b, a )","\tSF.CheckType( r, \"number\" ) SF.CheckType( g, \"number\" ) SF.CheckType( b, \"number\" ) SF.CheckType( a, \"number\" )","\tcurrentcolor = Color( r, g, b, a )","\tsurface.SetDrawColor( r, g, b, a )","\tsurface.SetTextColor( r, g, b, a )","end",""],"class":"function","name":"render_library.setRGBA","summary":"\nSets the draw color by RGBA values ","private":false,"library":"render","description":"\nSets the draw color by RGBA values","param":["r","g","b","a"]},{"ret":"Texture table. Use it with render.setTexture. Returns nil if max url textures is reached.","comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url","-- @param cb Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table","-- @param alignment Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","-- @return Texture table. Use it with render.setTexture. Returns nil if max url textures is reached."],"code":["function render_library.getTextureID ( tx, cb, alignment )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","","\t\tif alignment then","\t\t\tSF.CheckType( alignment, \"string\" )","\t\t\tlocal args = string.Split( alignment, \" \" )","\t\t\tlocal validargs = {[\"left\"]=true,[\"center\"]=true,[\"right\"]=true,[\"top\"]=true,[\"bottom\"]=true}","\t\t\tif #args ~= 1 and #args ~= 2 then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tfor i=1, #args do","\t\t\t\tif not validargs[args[i]] then SF.throw( \"Invalid urltexture alignment given.\" ) end","\t\t\tend","\t\telse","\t\t\talignment = \"center\"","\t\tend","\t\t","\t\tlocal instance = SF.instance","","\t\tlocal tbl = {}","\t\ttexturecachehttp[ tbl ] = LoadURLMaterial( tx, alignment, function()","\t\t\tif cb then","\t\t\t\tlocal ok, msg, traceback = instance:runFunction( cb, tbl, tx )","\t\t\t\tif not ok then","\t\t\t\t\tinstance:Error( msg, traceback )","\t\t\t\tend","\t\t\tend","\t\tend)","\t\tif not texturecachehttp[ tbl ] then return end","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tif not mat then return end","\t\t\tlocal cacheentry = sfCreateMaterial( \"SF_TEXTURE_\" .. id )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","2":"cb","3":"alignment","tx":"Texture file path, or a http url","alignment":"Optional alignment for the url texture. Default: \"center\", See http://www.w3schools.com/cssref/pr_background-position.asp","cb":"Optional callback for when a url texture finishes loading. param1 - The texture url, param2 - The texture table"}},{"comment":["--- Sets the texture","-- @param id Texture table. Get it with render.getTextureID"],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id then","\t\tif texturecache[ id ] then","\t\t\tsurface.SetMaterial( texturecache[ id ] )","\t\telseif texturecachehttp[ id ] then","\t\t\tsurface.SetMaterial( texturecachehttp[ id ] )","\t\telse","\t\t\tdraw.NoTexture()","\t\tend","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture table. Get it with render.getTextureID"}},{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target"],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024 ), false }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\trt[ 3 ] = CreateMaterial( \"StarfallCustomModel_\"..name..SF.instance.data.entity:EntIndex(), \"VertexLitGeneric\", {","\t\t[ \"$model\" ] = 1,","\t} )","\trt[3]:SetTexture(\"$basetexture\", rt[1])","\t","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif name then","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\t\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\t\tif not data.usingRT then","\t\t\tdata.oldViewPort = {0, 0, ScrW(), ScrH()}","\t\t\trender.SetViewPort( 0, 0, 1024, 1024 )","\t\t\tcam.Start2D()","\t\t\trender.SetStencilEnable( false )","\t\tend","\t\trender.SetRenderTarget( rt )","\t\tdata.usingRT = true","\telse","\t\tif data.usingRT then","\t\t\trender.SetRenderTarget()","\t\t\tcam.End2D()","\t\t\trender.SetViewPort(unpack(data.oldViewPort))","\t\t\tdata.usingRT = false","\t\t\trender.SetStencilEnable( true )","\t\tend","\tend","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\tRT_Material:SetTexture( \"$basetexture\", globalRTs[ rtname ][ 1 ] )","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},{"ret":"Model material name. Send this to the server to set the entity's material.","comment":["--- Returns the model material name that uses the render target.","--- Alternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex() ","-- @param name Render target name","-- @return Model material name. Send this to the server to set the entity's material."],"code":["function render_library.getRenderTargetMaterial( name )","\tlocal data = SF.instance.data.render","\tSF.CheckType( name, \"string\" )","","\tlocal rtname = data.rendertargets[ name ]","\tif rtname and globalRTs[ rtname ] then","\t\treturn \"!\"..tostring(globalRTs[ rtname ][ 3 ])","\tend","end",""],"class":"function","name":"render_library.getRenderTargetMaterial","summary":"\nReturns the model material name that uses the render target.","private":false,"library":"render","description":"\nReturns the model material name that uses the render target. \nAlternatively, just construct the name yourself with \"!StarfallCustomModel_\"..name..chip():entIndex()","param":{"1":"name","name":"Render target name"}},{"comment":["--- Sets the texture of a screen entity","-- @param ent Screen entity"],"code":["function render_library.setTextureFromScreen ( ent )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","","\tent = SF.Entities.Unwrap( ent )","\tif IsValid( ent ) and ent.GPU and ent.GPU.RT then","\t\tRT_Material:SetTexture(\"$basetexture\", ent.GPU.RT)","\t\tsurface.SetMaterial( RT_Material )","\telse","\t\tdraw.NoTexture()","\tend","","end",""],"class":"function","name":"render_library.setTextureFromScreen","summary":"\nSets the texture of a screen entity ","private":false,"library":"render","description":"\nSets the texture of a screen entity","param":{"1":"ent","ent":"Screen entity"}},{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","\tif SF.instance.data.render.usingRT then","\t\tif clr == nil then","\t\t\trender.Clear( 0, 0, 0, 255 )","\t\telse","\t\t\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\t\t\trender.Clear( clr.r, clr.g, clr.b, clr.a )","\t\tend","\tend","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRoundedBox ( r, x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tdraw.RoundedBox( r, x, y, w, h, currentcolor )","end",""],"class":"function","name":"render_library.drawRoundedBox","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","r":"The corner radius","w":"Width","h":"Height"}},{"comment":["--- Draws a rounded rectangle using the current color","-- @param r The corner radius","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param tl Boolean Top left corner","-- @param tr Boolean Top right corner","-- @param bl Boolean Bottom left corner","-- @param br Boolean Bottom right corner"],"code":["function render_library.drawRoundedBoxEx ( r, x, y, w, h, tl, tr, bl, br )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( r, \"number\" )","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( tl, \"boolean\" )","\tSF.CheckType( tr, \"boolean\" )","\tSF.CheckType( bl, \"boolean\" )","\tSF.CheckType( br, \"boolean\" )","\tdraw.RoundedBoxEx( r, x, y, w, h, currentcolor, tl, tr, bl, br )","end",""],"class":"function","name":"render_library.drawRoundedBoxEx","summary":"\nDraws a rounded rectangle using the current color ","private":false,"library":"render","description":"\nDraws a rounded rectangle using the current color","param":{"1":"r","2":"x","3":"y","4":"w","5":"h","6":"tl","7":"tr","8":"bl","9":"br","tr":"Boolean Top right corner","tl":"Boolean Top left corner","r":"The corner radius","w":"Width","y":"Top left corner y coordinate","h":"Height","x":"Top left corner x coordinate","br":"Boolean Bottom right corner","bl":"Boolean Bottom left corner"}},{"comment":["--- Draws a rectangle using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blur Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- Akbar","-- \\- Coolvetica","-- \\- Roboto","-- \\- Courier New","-- \\- Verdana","-- \\- Arial","-- \\- HalfLife2","-- \\- hl2mp","-- \\- csd","-- \\- Tahoma","-- \\- Trebuchet","-- \\- Trebuchet MS","-- \\- DejaVu Sans Mono","-- \\- Lucida Console","-- \\- Times New Roman"],"code":["","function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tfont = validfonts[string.lower(font)]","\tif not font then SF.throw( \"invalid font\", 2 ) end","","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end","defaultFont = render_library.createFont(\"Default\", 16, 400, false, false, false, false, 0)",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- Akbar \n- Coolvetica \n- Roboto \n- Courier New \n- Verdana \n- Arial \n- HalfLife2 \n- hl2mp \n- csd \n- Tahoma \n- Trebuchet \n- Trebuchet MS \n- DejaVu Sans Mono \n- Lucida Console \n- Times New Roman","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","outline":"Enable outline?","font":"Base font to use","blur":"Enable blur?","weight":"Font weight (default: 400)","shadow":"Enable drop shadow?","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},{"comment":["--- Sets the font","-- @param font The font to use","-- @usage Use a font created by render.createFont or use one of these already defined fonts:","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- Default","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet24","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- HudNumbers","-- \\- DermaDefault","-- \\- DermaDefaultBold","-- \\- DermaLarge"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","summary":"\nSets the font ","name":"render_library.setFont","library":"render","private":false,"usage":"Use a font created by render.createFont or use one of these already defined fonts: \n- DebugFixed \n- DebugFixedSmall \n- Default \n- Marlett \n- Trebuchet18 \n- Trebuchet24 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- HudNumbers \n- DermaDefault \n- DermaDefaultBold \n- DermaLarge","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},{"comment":["--- Draws text with newlines and tabs","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.DrawText( text, font, x, y, currentcolor, alignment )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text with newlines and tabs ","private":false,"library":"render","description":"\nDraws text with newlines and tabs","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},{"comment":["--- Draws text more easily and quickly but no new lines or tabs.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param xalign Text x alignment","-- @param yalign Text y alignment"],"code":["function render_library.drawSimpleText ( x, y, text, xalign, yalign )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif xalign then SF.CheckType( xalign, \"number\" ) end","\tif yalign then SF.CheckType( yalign, \"number\" ) end","","\tlocal font = SF.instance.data.render.font or defaultFont","","\tdraw.SimpleText( text, font, x, y, currentcolor, xalign, yalign )","end",""],"class":"function","name":"render_library.drawSimpleText","summary":"\nDraws text more easily and quickly but no new lines or tabs.","private":false,"library":"render","description":"\nDraws text more easily and quickly but no new lines or tabs.","param":{"1":"x","2":"y","3":"text","4":"xalign","5":"yalign","y":"Y coordinate","x":"X coordinate","text":"Text to draw","yalign":"Text y alignment","xalign":"Text x alignment"}},{"ret":"The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject","comment":["--- Constructs a markup object for quick styled text drawing.","-- @param markup The markup string to parse","-- @param maxsize The max width of the markup","-- @return The markup object. See https://wiki.garrysmod.com/page/Category:MarkupObject"],"code":["function render_library.parseMarkup( str, maxsize )","\tSF.CheckType( str, \"string\" )","\tSF.CheckType( maxsize, \"number\" )","\tlocal marked = markup.Parse( str, maxsize )","\tlocal markedindex = marked.__index","\treturn setmetatable(marked, {","\t\t__newindex = function() end,","\t\t__index = markedindex,","\t\t__metatable = \"\"","\t})","end",""],"class":"function","name":"render_library.parseMarkup","summary":"\nConstructs a markup object for quick styled text drawing.","private":false,"library":"render","description":"\nConstructs a markup object for quick styled text drawing.","param":{"1":"str","2":"maxsize","3":"markup","markup":"The markup string to parse","maxsize":"The max width of the markup"}},{"comment":["--- Draws a polygon.","-- @param poly Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"],"code":["function render_library.drawPoly(poly)","\tSF.CheckType(poly,\"table\")","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon.","param":{"1":"poly","poly":"Table of polygon vertices. Texture coordinates are optional. {{x=x1, y=y1, u=u1, v=v1}, ... }"}},{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen or screen:GetClass()~=\"starfall_screen\" then return input.GetCursorPos() end","","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","","\tlocal Normal, Pos","\t-- Get monitor screen pos & size","","\tPos = screen:LocalToWorld( screen.Origin )","","\tNormal = -screen.Transform:GetUp():GetNormalized()","","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","","\tlocal A = Normal:Dot(Dir)","","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","","\tlocal B = Normal:Dot(Pos-Start) / A","\tif (B >= 0) then","\t\tlocal w = 512/screen.Aspect","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), screen.Transform:GetTranslation(), screen.Transform:GetAngles() )","\t\tlocal x = HitPos.x/screen.Scale","\t\tlocal y = HitPos.y/screen.Scale","\t\tif x < 0 or x > w or y < 0 or y > 512 then return nil end -- Aiming off the screen","\t\treturn x, y","\tend","","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as world offsets, dimentions, and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @param e The screen to get info from.","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo( e )","\tlocal screen = SF.Entities.Unwrap( e )","\tif screen then","\t\treturn SF.Sanitize( screen.ScreenInfo )","\tend","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as world offsets, dimentions, and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as world offsets, dimentions, and rotation. \nNote: this does a table copy so move it out of your draw hook","param":{"1":"e","e":"The screen to get info from."}},{"ret":"Entity of the screen or hud being rendered","comment":["--- Returns the entity currently being rendered to","-- @return Entity of the screen or hud being rendered"],"code":["function render_library.getScreenEntity()","\treturn SF.Entities.Wrap( SF.instance.data.render.renderEnt )","end",""],"class":"function","name":"render_library.getScreenEntity","summary":"\nReturns the entity currently being rendered to ","private":false,"library":"render","description":"\nReturns the entity currently being rendered to","param":[]},{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\tif SF.instance.data.render.usingRT then","\t\trender.CapturePixels()","\tend","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},{"ret":["the X size of the current render context","the Y size of the current render context"],"comment":["--- Returns the render context's width and height","-- @class function","-- @return the X size of the current render context","-- @return the Y size of the current render context"],"code":["function render_library.getResolution()","\treturn SF.instance.data.render.renderEnt:GetResolution()","end",""],"class":"function","classForced":true,"name":"render_library.getResolution","summary":"\nReturns the render context's width and height ","private":false,"library":"render","description":"\nReturns the render context's width and height","param":[]},{"classForced":true,"summary":"\nCalled when a player uses the screen ","comment":["--- Called when a player uses the screen","-- @name starfallUsed","-- @class hook","-- @param activator Player using the screen"],"code":[""],"description":"\nCalled when a player uses the screen","class":"hook","name":"starfallUsed","param":{"1":"activator","activator":"Player using the screen"}},{"classForced":true,"summary":"\n ","comment":["---","-- @name Screen information table","-- @class table","-- @field Name Pretty name of model","-- @field offset Offset of screen from prop","-- @field RS Resolution/scale","-- @field RatioX Inverted Aspect ratio (height divided by width)","-- @field x1 Corner of screen in local coordinates (relative to offset?)","-- @field x2 Corner of screen in local coordinates (relative to offset?)","-- @field y1 Corner of screen in local coordinates (relative to offset?)","-- @field y2 Corner of screen in local coordinates (relative to offset?)","-- @field z Screen plane offset in local coordinates (relative to offset?)","-- @field rot Screen rotation"],"code":[],"description":"\n","class":"table","name":"Screen information table","field":{"1":"Name","2":"offset","3":"RS","4":"RatioX","5":"x1","6":"x2","7":"y1","8":"y2","9":"z","10":"rot","offset":"Offset of screen from prop","x2":"Corner of screen in local coordinates (relative to offset?)","y2":"Corner of screen in local coordinates (relative to offset?)","y1":"Corner of screen in local coordinates (relative to offset?)","RS":"Resolution/scale","Name":"Pretty name of model","z":"Screen plane offset in local coordinates (relative to offset?)","RatioX":"Inverted Aspect ratio (height divided by width)","rot":"Screen rotation","x1":"Corner of screen in local coordinates (relative to offset?)"}}],"tables":{"1":"Screen information table","2":"Vertex Format","Vertex Format":{"description":"\nVertex format","code":["","local render = render","local surface = surface","local clamp = math.Clamp","local max = math.max","local cam = cam","local dgetmeta = debug.getmetatable","local matrix_meta = SF.VMatrix.Metatable --debug.getregistry().VMatrix","","local v_unwrap = SF.VMatrix.Unwrap","","","local function sfCreateMaterial( name )","\treturn CreateMaterial( name, \"UnlitGeneric\", {","\t\t\t\t[ \"$nolod\" ] = 1,","\t\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t\t[ \"$vertexalpha\" ] = 1,","\t\t\t\t[ \"$basetexturetransform\"] = \"center .5 .5 scale 1.032 1.032 rotate 0 translate 0 0\"","\t\t\t} )","end","","local currentcolor","local MATRIX_STACK_LIMIT = 8","local matrix_stack = {}","local view_matrix_stack = 0","","local globalRTs = {}","local globalRTcount = 0","local RT_Material = sfCreateMaterial( \"SF_RT_Material\" )","","local function findAvailableRT ()","\tfor k, v in pairs( globalRTs ) do","\t\tif v[ 2 ] then","\t\t\treturn k, v","\t\tend","\tend","\treturn nil","end","","SF.Libraries.AddHook( \"prepare\", function ( instance, hook )","\tif hook == \"render\" then","\t\tcurrentcolor = Color(0,0,0,0)","\tend","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, hook )","\tif hook == \"render\" then","\t\tfor i=#matrix_stack,1,-1 do","\t\t\tcam.PopModelMatrix()","\t\t\tmatrix_stack[i] = nil","\t\tend","\t\tlocal data = instance.data.render","\t\tif data.usingRT then","\t\t\trender.SetRenderTarget()","\t\t\tcam.End2D()","\t\t\trender.SetViewPort(unpack(data.oldViewPort))","\t\t\tdata.usingRT = false","\t\tend","\t\tfor i=1, view_matrix_stack do","\t\t\tcam.End()","\t\tend","\t\tview_matrix_stack = 0","\tend","end )","","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.render.rendertargets = {}","\tinstance.data.render.rendertargetcount = 0","end)","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tfor k, v in pairs( instance.data.render.rendertargets ) do","\t\tglobalRTs[ v ][ 2 ] = true -- mark as available","\tend","end )",""],"class":"table","classForced":true,"name":"Vertex Format","summary":"\nVertex format ","field":{"1":"x","2":"y","3":"u","4":"v","y":"Y coordinate","x":"X coordinate","u":"U coordinate (optional, default is 0)","v":"V coordinate (optional, default is 0)"},"comment":["--- Vertex format","-- @name Vertex Format","-- @class table","-- @field x X coordinate","-- @field y Y coordinate","-- @field u U coordinate (optional, default is 0)","-- @field v V coordinate (optional, default is 0)"],"param":[]},"Screen information table":{"classForced":true,"summary":"\n ","comment":["---","-- @name Screen information table","-- @class table","-- @field Name Pretty name of model","-- @field offset Offset of screen from prop","-- @field RS Resolution/scale","-- @field RatioX Inverted Aspect ratio (height divided by width)","-- @field x1 Corner of screen in local coordinates (relative to offset?)","-- @field x2 Corner of screen in local coordinates (relative to offset?)","-- @field y1 Corner of screen in local coordinates (relative to offset?)","-- @field y2 Corner of screen in local coordinates (relative to offset?)","-- @field z Screen plane offset in local coordinates (relative to offset?)","-- @field rot Screen rotation"],"code":[],"description":"\n","class":"table","name":"Screen information table","field":{"1":"Name","2":"offset","3":"RS","4":"RatioX","5":"x1","6":"x2","7":"y1","8":"y2","9":"z","10":"rot","offset":"Offset of screen from prop","x2":"Corner of screen in local coordinates (relative to offset?)","y2":"Corner of screen in local coordinates (relative to offset?)","y1":"Corner of screen in local coordinates (relative to offset?)","RS":"Resolution/scale","Name":"Pretty name of model","z":"Screen plane offset in local coordinates (relative to offset?)","RatioX":"Inverted Aspect ratio (height divided by width)","rot":"Screen rotation","x1":"Corner of screen in local coordinates (relative to offset?)"}}},"description":"\n \nRender library \n","summary":"\n \nRender library \n "},"libs_sv/entities.lua":{"libraries":[],"type":"file","name":"libs_sv/entities.lua","functions":{"1":"SF.Entities.GetOwner","2":"ents_methods:addCollisionListener","3":"ents_methods:applyAngForce","4":"ents_methods:applyDamage","5":"ents_methods:applyForceCenter","6":"ents_methods:applyForceOffset","7":"ents_methods:applyTorque","8":"ents_methods:breakEnt","9":"ents_methods:emitSound","10":"ents_methods:enableDrag","11":"ents_methods:enableGravity","12":"ents_methods:enableMotion","13":"ents_methods:enableSphere","14":"ents_methods:extinguish","15":"ents_methods:getOwner","16":"ents_methods:ignite","17":"ents_methods:isFrozen","18":"ents_methods:isWeldedTo","19":"ents_methods:linkComponent","20":"ents_methods:remove","21":"ents_methods:removeTrails","22":"ents_methods:setAngles","23":"ents_methods:setBodygroup","24":"ents_methods:setColor","25":"ents_methods:setFrozen","26":"ents_methods:setMass","27":"ents_methods:setMaterial","28":"ents_methods:setNoDraw","29":"ents_methods:setNocollideAll","30":"ents_methods:setParent","31":"ents_methods:setPhysMaterial","32":"ents_methods:setPos","33":"ents_methods:setRenderFX","34":"ents_methods:setRenderMode","35":"ents_methods:setSkin","36":"ents_methods:setSolid","37":"ents_methods:setSubMaterial","38":"ents_methods:setTrails","39":"ents_methods:setVelocity","40":"ents_methods:unparent","ents_methods:isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end","",""],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"ents_methods:getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v[1] and v[1] < math.huge and","\t\t\t-math.huge < v[2] and v[2] < math.huge and","\t\t\t-math.huge < v[3] and v[3] < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"ents_methods:applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\t","\tlocal ang = SF.UnwrapObject( ang )","\tlocal ent = unwrap( self )","\t","\tif not check( ang ) then SF.throw( \"infinite angle\", 2) end","\t","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"ents_methods:extinguish":{"comment":["--- Extinguishes an entity"],"code":["function ents_methods:extinguish()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Extinguish()","end",""],"class":"function","name":"ents_methods:extinguish","summary":"\nExtinguishes an entity ","private":false,"classlib":"Entity","description":"\nExtinguishes an entity","param":[]},"ents_methods:removeTrails":{"comment":["--- Removes trails from the entity"],"code":["function ents_methods:removeTrails()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, nil)","end",""],"class":"function","name":"ents_methods:removeTrails","summary":"\nRemoves trails from the entity ","private":false,"classlib":"Entity","description":"\nRemoves trails from the entity","param":[]},"ents_methods:enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"ents_methods:setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"ents_methods:setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"ents_methods:setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tlocal rendermode = ( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { Color = clr, RenderMode = rendermode } )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"SF.Entities.GetOwner":{"ret":"The entities owner, or nil if not found","comment":["--- Gets the entity's owner","-- TODO: Optimize this!","-- @return The entities owner, or nil if not found"],"code":["function SF.Entities.GetOwner ( entity )","\tif not isValid( entity ) then return end","","\tif entity.IsPlayer and entity:IsPlayer() then","\t\treturn entity","\tend","","\tif CPPI then","\t\tlocal owner = entity:CPPIGetOwner()","\t\tif isValid( owner ) then return owner end","\tend","","\tif entity.GetPlayer then","\t\tlocal ply = entity:GetPlayer()","\t\tif isValid( ply ) then return ply end","\tend","","\tif entity.owner and isValid( entity.owner ) and entity.owner:IsPlayer() then","\t\treturn entity.owner","\tend","","\tlocal OnDieFunctions = entity.OnDieFunctions","\tif OnDieFunctions then","\t\tif OnDieFunctions.GetCountUpdate and OnDieFunctions.GetCountUpdate.Args and OnDieFunctions.GetCountUpdate.Args[ 1 ] then","\t\t\treturn OnDieFunctions.GetCountUpdate.Args[ 1 ]","\t\telseif OnDieFunctions.undo1 and OnDieFunctions.undo1.Args and OnDieFunctions.undo1.Args[2] then","\t\t\treturn OnDieFunctions.undo1.Args[ 2 ]","\t\tend","\tend","","\tif entity.GetOwner then","\t\tlocal ply = entity:GetOwner()","\t\tif isValid( ply ) then return ply end","\tend","","\treturn nil","end","","local getPhysObject = SF.Entities.GetPhysObject","local getOwner = SF.Entities.GetOwner",""],"class":"function","name":"SF.Entities.GetOwner","private":false,"summary":"\nGets the entity's owner \nTODO: Optimize this! ","description":"\nGets the entity's owner \nTODO: Optimize this!","param":["entity"]},"ents_methods:setRenderMode":{"comment":["--- Sets the rende mode of the entity","-- @server","-- @class function","-- @param rendermode Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderMode ( rendermode, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( rendermode, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 7, rendermode )","\telse","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderMode = rendermode } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the rende mode of the entity ","name":"ents_methods:setRenderMode","classlib":"Entity","private":false,"server":true,"description":"\nSets the rende mode of the entity","param":{"1":"rendermode","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","rendermode":"Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE"}},"ents_methods:setRenderFX":{"comment":["--- Sets the renderfx of the entity","-- @server","-- @class function","-- @param renderfx Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderFX ( renderfx, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( renderfx, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 8, renderfx )","\telse","\t\tent:SetRenderFX( renderfx )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderFX = renderfx } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the renderfx of the entity ","name":"ents_methods:setRenderFX","classlib":"Entity","private":false,"server":true,"description":"\nSets the renderfx of the entity","param":{"1":"renderfx","2":"ply","renderfx":"Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"ents_methods:unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"ents_methods:setNocollideAll":{"comment":["--- Set's the entity to collide with nothing but the world","-- @param nocollide Whether to collide with nothing except world or not."],"code":["function ents_methods:setNocollideAll ( nocollide )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tent:SetCollisionGroup ( nocollide and COLLISION_GROUP_WORLD or COLLISION_GROUP_NONE )","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend,","\t[7] = function( mode ) --Rendermode","\t\tnet.WriteUInt( mode, 8 )","\tend,","\t[8] = function( fx ) --Renderfx","\t\tnet.WriteUInt( fx, 8 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tlocal meta = debug.getmetatable( ply )","\tif meta == SF.Types[ \"Player\" ] then ","\t\tply = unwrap( ply )","\t\tif not ( IsValid( ply ) and ply:IsPlayer() ) then","\t\t\tSF.throw( \"Tried to use invalid player\", 3 )","\t\tend","\telseif meta == nil and type( ply ) == \"table\" then","\t\tlocal ply2 = ply","\t\tply = {}","\t\tfor k, v in pairs( ply2 ) do","\t\t\tlocal p = unwrap( v )","\t\t\tif IsValid( p ) and p:IsPlayer() then","\t\t\t\tply[k] = p","\t\t\telse","\t\t\t\tSF.throw ( \"Invalid player object in table of players\", 3 )","\t\t\tend","\t\tend","\telse","\t\tSF.throw( \"Expected player or table of players.\", 3 )","\tend","\t","\tnet.Start( \"sf_setentityrenderproperty\" )","\tnet.WriteEntity( ent )","\tnet.WriteUInt( func, 4 )","\trenderProperties[ func ]( ... )","\tnet.Send( ply )","end",""],"class":"function","name":"ents_methods:setNocollideAll","summary":"\nSet's the entity to collide with nothing but the world ","private":false,"classlib":"Entity","description":"\nSet's the entity to collide with nothing but the world","param":{"1":"nocollide","nocollide":"Whether to collide with nothing except world or not."}},"ents_methods:setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"ents_methods:setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to","-- @param attachment Optional string attachment name to parent to"],"code":["function ents_methods:setParent ( ent, attachment )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ent, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) and not ent:IsPlayer() then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","\tif attachment then","\t\tSF.CheckType(attachment, \"string\")","\t\tthis:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\tend","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","2":"attachment","ent":"Entity to parent to","attachment":"Optional string attachment name to parent to"}},"ents_methods:ignite":{"comment":["--- Ignites an entity","-- @param length How long the fire lasts","-- @param radius (optional) How large the fire hitbox is (entity obb is the max)"],"code":["function ents_methods:ignite( length, radius )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( length, \"number\" )","","\tlocal ent = unwrap( self )","","\tif radius then","\t\tSF.CheckType( radius, \"number\" )","\t\tlocal obbmins, obbmaxs = ent:OBBMins(), ent:OBBMaxs()","\t\tradius = math.Clamp( radius, 0, (obbmaxs.x - obbmins.x + obbmaxs.y - obbmins.y) / 2 )","\tend","","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Ignite( length, radius )","end",""],"class":"function","name":"ents_methods:ignite","summary":"\nIgnites an entity ","private":false,"classlib":"Entity","description":"\nIgnites an entity","param":{"1":"length","2":"radius","radius":"(optional) How large the fire hitbox is (entity obb is the max)","length":"How long the fire lasts"}},"ents_methods:linkComponent":{"comment":["--- Links starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","-- @param e Entity to link the component to. nil to clear links."],"code":["function ents_methods:linkComponent ( e )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif e then","\t\tSF.CheckType( e, ents_metatable )","\t\tlocal link = unwrap( e )","\t\tif not isValid( link ) then SF.throw( \"Entity is not valid\", 2 ) end","\t\tif not SF.Permissions.check( SF.instance.player, link, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\tif link:GetClass()==\"starfall_processor\" and ( ent:GetClass()==\"starfall_screen\" or ent:GetClass()==\"starfall_hud\" ) then","\t\t\tent:LinkEnt( link )","\t\telseif link:IsVehicle() and ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkVehicle( link )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\telse","\t\tif ent:GetClass()==\"starfall_screen\" then","\t\t\tent:LinkEnt( nil )","\t\telseif ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkEnt( nil )","\t\t\tent:LinkVehicle( nil )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\tend","end","",""],"class":"function","name":"ents_methods:linkComponent","summary":"\nLinks starfall components to a starfall processor or vehicle.","private":false,"classlib":"Entity","description":"\nLinks starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","param":{"1":"e","e":"Entity to link the component to. nil to clear links."}},"ents_methods:applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"ents_methods:setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"ents_methods:enableSphere":{"comment":["--- Sets the physics of an entity to be a sphere","-- @param enabled Bool should the entity be spherical?"],"code":["function ents_methods:enableSphere ( enabled )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\t","\tif ent:GetClass() ~= \"prop_physics\" then SF.throw( \"This function only works for prop_physics\", 2 ) end","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal ismove = phys:IsMoveable()","\tlocal mass = phys:GetMass()","\t","\tif enabled then","\t\tif ent:GetMoveType() == MOVETYPE_VPHYSICS then","\t\t\tlocal OBB = ent:OBBMaxs() - ent:OBBMins()","\t\t\tlocal radius = math.max( OBB.x, OBB.y, OBB.z) / 2 ","\t\t\tent:PhysicsInitSphere( radius, phys:GetMaterial() )","\t\t\tent:SetCollisionBounds( Vector( -radius, -radius, -radius ) , Vector( radius, radius, radius ) )","\t\tend","\telse","\t\tif ent:GetMoveType() ~= MOVETYPE_VPHYSICS then","\t\t\tent:PhysicsInit( SOLID_VPHYSICS )","\t\t\tent:SetMoveType( MOVETYPE_VPHYSICS )","\t\t\tent:SetSolid( SOLID_VPHYSICS )","\t\tend","\tend","\t","\t-- New physobject after applying spherical collisions","\tlocal phys = ent:GetPhysicsObject()","\tphys:SetMass( mass )","\tphys:EnableMotion( ismove )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableSphere","summary":"\nSets the physics of an entity to be a sphere ","private":false,"classlib":"Entity","description":"\nSets the physics of an entity to be a sphere","param":{"1":"enabled","enabled":"Bool should the entity be spherical?"}},"ents_methods:addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"ents_methods:setTrails":{"comment":["--- Adds a trail to the entity with the specified attributes.","-- @param startSize The start size of the trail","-- @param endSize The end size of the trail","-- @param length The length size of the trail","-- @param material The material of the trail","-- @param color The color of the trail","-- @param attachmentID Optional attachmentid the trail should attach to","-- @param additive If the trail's rendering is additive"],"code":["function ents_methods:setTrails(startSize, endSize, length, material, color, attachmentID, additive)","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( material, \"string\" )","\t","\tlocal ent = unwrap( self )","","\tif string.find(material, '\"', 1, true) then SF.throw( \"Invalid Material\", 2 ) end","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal Data = {","\t\tColor = SF.Color.Unwrap( color ),","\t\tLength = length,","\t\tStartSize = math.Clamp( startSize, 0, 128 ),","\t\tEndSize = math.Clamp( endSize, 0, 128 ),","\t\tMaterial = material,","\t\tAttachmentID = attachmentID,","\t\tAdditive = additive,","\t}","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, Data)","end",""],"class":"function","name":"ents_methods:setTrails","summary":"\nAdds a trail to the entity with the specified attributes.","private":false,"classlib":"Entity","description":"\nAdds a trail to the entity with the specified attributes.","param":{"1":"startSize","2":"endSize","3":"length","4":"material","5":"color","6":"attachmentID","7":"additive","startSize":"The start size of the trail","length":"The length size of the trail","attachmentID":"Optional attachmentid the trail should attach to","color":"The color of the trail","material":"The material of the trail","endSize":"The end size of the trail","additive":"If the trail's rendering is additive"}},"ents_methods:enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"ents_methods:enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"ents_methods:setPhysMaterial":{"comment":["--- Sets the physical material of the entity","-- @param mat Material to use"],"code":["function ents_methods:setPhysMaterial( mat )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( mat, \"string\" )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tconstruct.SetPhysProp( nil, ent, 0, phys, {Material = mat} ) ","end",""],"class":"function","name":"ents_methods:setPhysMaterial","summary":"\nSets the physical material of the entity ","private":false,"classlib":"Entity","description":"\nSets the physical material of the entity","param":{"1":"mat","mat":"Material to use"}},"ents_methods:setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"ents_methods:setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set only for that player. Can also be table of players.","bodygroup":"Number, The ID of the bodygroup you're setting."}},"ents_methods:setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"ents_methods:isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"ents_methods:applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"ents_methods:applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"ents_methods:setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"ents_methods:breakEnt":{"comment":["--- Invokes the entity's breaking animation and removes it."],"code":["function ents_methods:breakEnt ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() or ent:IsFlagSet( FL_KILLME ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:AddFlags( FL_KILLME )","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:breakEnt","summary":"\nInvokes the entity's breaking animation and removes it.","private":false,"classlib":"Entity","description":"\nInvokes the entity's breaking animation and removes it.","param":[]},"ents_methods:setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\t\tduplicator.StoreEntityModifier( ent, \"material\", { MaterialOverride = material } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","material":", string, New material name."}},"ents_methods:emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"ents_methods:remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"ents_methods:setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local shaderBlacklist = {","\t[ \"LightmappedGeneric\" ] = true,","}","local function invalidMaterial( material )","\tif string.find( string.lower( material ) , \"pp[%./\\\\]+copy\" ) then return true end","\tlocal mat = Material( material )","\tif mat and shaderBlacklist[ mat:GetShader() ] then return true end","end",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"ents_methods:setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","\t","\tif not check( vel ) then SF.throw( \"infinite vector\", 2) end","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"ents_methods:applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Serverside Entity functions","-------------------------------------------------------------------------------"],"code":["","assert( SF.Entities )","","local huge = math.huge","local abs = math.abs","","local ents_lib = SF.Entities.Library","local ents_metatable = SF.Entities.Metatable",""],"summary":"\n \nServerside Entity functions \n ","description":"\n \nServerside Entity functions \n","param":[]},{"description":"\nEntity type","code":["local ents_methods = SF.Entities.Methods","local wrap, unwrap = SF.Entities.Wrap, SF.Entities.Unwrap","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"entities.parent\", \"Parent\", \"Allows the user to parent an entity to another entity\" )","\tP.registerPrivilege( \"entities.unparent\", \"Unparent\", \"Allows the user to remove the parent of an entity\" ) -- TODO: maybe merge with entities.parent?","\tP.registerPrivilege( \"entities.applyForce\", \"Apply force\", \"Allows the user to apply force to an entity\" )","\tP.registerPrivilege( \"entities.applyDamage\", \"Apply damage\", \"Allows the user to apply damage to an entity\" )","\tP.registerPrivilege( \"entities.setPos\", \"Set Position\", \"Allows the user to teleport an entity to another location\" )","\tP.registerPrivilege( \"entities.setAngles\", \"Set Angles\", \"Allows the user to teleport an entity to another orientation\" )","\tP.registerPrivilege( \"entities.setVelocity\", \"Set Velocity\", \"Allows the user to change the velocity of an entity\" )","\tP.registerPrivilege( \"entities.setFrozen\", \"Set Frozen\", \"Allows the user to freeze and unfreeze an entity\" )","\tP.registerPrivilege( \"entities.setSolid\", \"Set Solid\", \"Allows the user to change the solidity of an entity\" )","\tP.registerPrivilege( \"entities.setMass\", \"Set Mass\", \"Allows the user to change the mass of an entity\" )","\tP.registerPrivilege( \"entities.enableGravity\", \"Enable gravity\", \"Allows the user to change whether an entity is affected by gravity\" )","\tP.registerPrivilege( \"entities.enableMotion\", \"Set Motion\", \"Allows the user to disable an entity's motion\" )","\tP.registerPrivilege( \"entities.enableDrag\", \"Set Drag\", \"Allows the user to disable an entity's air resistence\" )","\tP.registerPrivilege( \"entities.remove\", \"Remove\", \"Allows the user to remove entities\" )","\tP.registerPrivilege( \"entities.ignite\", \"Ignite\", \"Allows the user to ignite entities\" )","\tP.registerPrivilege( \"entities.emitSound\", \"Emitsound\", \"Allows the user to play sounds on entities\" )","\tP.registerPrivilege( \"entities.setRenderPropery\", \"RenderProperty\", \"Allows the user to change the rendering of an entity\" )","\tP.registerPrivilege( \"entities.canTool\", \"CanTool\", \"Whether or not the user can use the toolgun on the entity\" )","end","","local function fix_nan ( v )","\tif v < huge and v > -huge then return v else return 0 end","end","","local isValid = IsValid","","-- ------------------------- Internal Library ------------------------- --",""],"class":"class","classForced":true,"fields":[],"name":"Entity","summary":"\nEntity type ","methods":{"1":"getOwner","2":"setParent","3":"unparent","4":"linkComponent","5":"emitSound","6":"applyDamage","7":"applyForceCenter","8":"applyForceOffset","9":"applyAngForce","10":"applyTorque","11":"addCollisionListener","12":"setNocollideAll","13":"setColor","14":"setNoDraw","15":"setMaterial","16":"setSubMaterial","17":"setBodygroup","18":"setSkin","19":"setRenderMode","20":"setRenderFX","21":"setPos","22":"setAngles","23":"setVelocity","24":"remove","25":"breakEnt","26":"ignite","27":"extinguish","28":"setFrozen","29":"isFrozen","30":"setSolid","31":"setMass","32":"setPhysMaterial","33":"enableGravity","34":"enableDrag","35":"enableMotion","36":"enableSphere","37":"isWeldedTo","38":"setTrails","39":"removeTrails","applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"setNocollideAll":{"comment":["--- Set's the entity to collide with nothing but the world","-- @param nocollide Whether to collide with nothing except world or not."],"code":["function ents_methods:setNocollideAll ( nocollide )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tent:SetCollisionGroup ( nocollide and COLLISION_GROUP_WORLD or COLLISION_GROUP_NONE )","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend,","\t[7] = function( mode ) --Rendermode","\t\tnet.WriteUInt( mode, 8 )","\tend,","\t[8] = function( fx ) --Renderfx","\t\tnet.WriteUInt( fx, 8 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tlocal meta = debug.getmetatable( ply )","\tif meta == SF.Types[ \"Player\" ] then ","\t\tply = unwrap( ply )","\t\tif not ( IsValid( ply ) and ply:IsPlayer() ) then","\t\t\tSF.throw( \"Tried to use invalid player\", 3 )","\t\tend","\telseif meta == nil and type( ply ) == \"table\" then","\t\tlocal ply2 = ply","\t\tply = {}","\t\tfor k, v in pairs( ply2 ) do","\t\t\tlocal p = unwrap( v )","\t\t\tif IsValid( p ) and p:IsPlayer() then","\t\t\t\tply[k] = p","\t\t\telse","\t\t\t\tSF.throw ( \"Invalid player object in table of players\", 3 )","\t\t\tend","\t\tend","\telse","\t\tSF.throw( \"Expected player or table of players.\", 3 )","\tend","\t","\tnet.Start( \"sf_setentityrenderproperty\" )","\tnet.WriteEntity( ent )","\tnet.WriteUInt( func, 4 )","\trenderProperties[ func ]( ... )","\tnet.Send( ply )","end",""],"class":"function","name":"ents_methods:setNocollideAll","summary":"\nSet's the entity to collide with nothing but the world ","private":false,"classlib":"Entity","description":"\nSet's the entity to collide with nothing but the world","param":{"1":"nocollide","nocollide":"Whether to collide with nothing except world or not."}},"applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"setTrails":{"comment":["--- Adds a trail to the entity with the specified attributes.","-- @param startSize The start size of the trail","-- @param endSize The end size of the trail","-- @param length The length size of the trail","-- @param material The material of the trail","-- @param color The color of the trail","-- @param attachmentID Optional attachmentid the trail should attach to","-- @param additive If the trail's rendering is additive"],"code":["function ents_methods:setTrails(startSize, endSize, length, material, color, attachmentID, additive)","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( material, \"string\" )","\t","\tlocal ent = unwrap( self )","","\tif string.find(material, '\"', 1, true) then SF.throw( \"Invalid Material\", 2 ) end","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal Data = {","\t\tColor = SF.Color.Unwrap( color ),","\t\tLength = length,","\t\tStartSize = math.Clamp( startSize, 0, 128 ),","\t\tEndSize = math.Clamp( endSize, 0, 128 ),","\t\tMaterial = material,","\t\tAttachmentID = attachmentID,","\t\tAdditive = additive,","\t}","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, Data)","end",""],"class":"function","name":"ents_methods:setTrails","summary":"\nAdds a trail to the entity with the specified attributes.","private":false,"classlib":"Entity","description":"\nAdds a trail to the entity with the specified attributes.","param":{"1":"startSize","2":"endSize","3":"length","4":"material","5":"color","6":"attachmentID","7":"additive","startSize":"The start size of the trail","length":"The length size of the trail","attachmentID":"Optional attachmentid the trail should attach to","color":"The color of the trail","material":"The material of the trail","endSize":"The end size of the trail","additive":"If the trail's rendering is additive"}},"setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","\t","\tif not check( vel ) then SF.throw( \"infinite vector\", 2) end","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local shaderBlacklist = {","\t[ \"LightmappedGeneric\" ] = true,","}","local function invalidMaterial( material )","\tif string.find( string.lower( material ) , \"pp[%./\\\\]+copy\" ) then return true end","\tlocal mat = Material( material )","\tif mat and shaderBlacklist[ mat:GetShader() ] then return true end","end",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"extinguish":{"comment":["--- Extinguishes an entity"],"code":["function ents_methods:extinguish()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Extinguish()","end",""],"class":"function","name":"ents_methods:extinguish","summary":"\nExtinguishes an entity ","private":false,"classlib":"Entity","description":"\nExtinguishes an entity","param":[]},"applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\t","\tlocal ang = SF.UnwrapObject( ang )","\tlocal ent = unwrap( self )","\t","\tif not check( ang ) then SF.throw( \"infinite angle\", 2) end","\t","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tlocal rendermode = ( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { Color = clr, RenderMode = rendermode } )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v[1] and v[1] < math.huge and","\t\t\t-math.huge < v[2] and v[2] < math.huge and","\t\t\t-math.huge < v[3] and v[3] < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end","",""],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\t\tduplicator.StoreEntityModifier( ent, \"material\", { MaterialOverride = material } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","material":", string, New material name."}},"setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set only for that player. Can also be table of players.","bodygroup":"Number, The ID of the bodygroup you're setting."}},"enableSphere":{"comment":["--- Sets the physics of an entity to be a sphere","-- @param enabled Bool should the entity be spherical?"],"code":["function ents_methods:enableSphere ( enabled )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\t","\tif ent:GetClass() ~= \"prop_physics\" then SF.throw( \"This function only works for prop_physics\", 2 ) end","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal ismove = phys:IsMoveable()","\tlocal mass = phys:GetMass()","\t","\tif enabled then","\t\tif ent:GetMoveType() == MOVETYPE_VPHYSICS then","\t\t\tlocal OBB = ent:OBBMaxs() - ent:OBBMins()","\t\t\tlocal radius = math.max( OBB.x, OBB.y, OBB.z) / 2 ","\t\t\tent:PhysicsInitSphere( radius, phys:GetMaterial() )","\t\t\tent:SetCollisionBounds( Vector( -radius, -radius, -radius ) , Vector( radius, radius, radius ) )","\t\tend","\telse","\t\tif ent:GetMoveType() ~= MOVETYPE_VPHYSICS then","\t\t\tent:PhysicsInit( SOLID_VPHYSICS )","\t\t\tent:SetMoveType( MOVETYPE_VPHYSICS )","\t\t\tent:SetSolid( SOLID_VPHYSICS )","\t\tend","\tend","\t","\t-- New physobject after applying spherical collisions","\tlocal phys = ent:GetPhysicsObject()","\tphys:SetMass( mass )","\tphys:EnableMotion( ismove )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableSphere","summary":"\nSets the physics of an entity to be a sphere ","private":false,"classlib":"Entity","description":"\nSets the physics of an entity to be a sphere","param":{"1":"enabled","enabled":"Bool should the entity be spherical?"}},"enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"setPhysMaterial":{"comment":["--- Sets the physical material of the entity","-- @param mat Material to use"],"code":["function ents_methods:setPhysMaterial( mat )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( mat, \"string\" )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tconstruct.SetPhysProp( nil, ent, 0, phys, {Material = mat} ) ","end",""],"class":"function","name":"ents_methods:setPhysMaterial","summary":"\nSets the physical material of the entity ","private":false,"classlib":"Entity","description":"\nSets the physical material of the entity","param":{"1":"mat","mat":"Material to use"}},"enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"linkComponent":{"comment":["--- Links starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","-- @param e Entity to link the component to. nil to clear links."],"code":["function ents_methods:linkComponent ( e )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif e then","\t\tSF.CheckType( e, ents_metatable )","\t\tlocal link = unwrap( e )","\t\tif not isValid( link ) then SF.throw( \"Entity is not valid\", 2 ) end","\t\tif not SF.Permissions.check( SF.instance.player, link, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\tif link:GetClass()==\"starfall_processor\" and ( ent:GetClass()==\"starfall_screen\" or ent:GetClass()==\"starfall_hud\" ) then","\t\t\tent:LinkEnt( link )","\t\telseif link:IsVehicle() and ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkVehicle( link )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\telse","\t\tif ent:GetClass()==\"starfall_screen\" then","\t\t\tent:LinkEnt( nil )","\t\telseif ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkEnt( nil )","\t\t\tent:LinkVehicle( nil )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\tend","end","",""],"class":"function","name":"ents_methods:linkComponent","summary":"\nLinks starfall components to a starfall processor or vehicle.","private":false,"classlib":"Entity","description":"\nLinks starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","param":{"1":"e","e":"Entity to link the component to. nil to clear links."}},"setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"removeTrails":{"comment":["--- Removes trails from the entity"],"code":["function ents_methods:removeTrails()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, nil)","end",""],"class":"function","name":"ents_methods:removeTrails","summary":"\nRemoves trails from the entity ","private":false,"classlib":"Entity","description":"\nRemoves trails from the entity","param":[]},"isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to","-- @param attachment Optional string attachment name to parent to"],"code":["function ents_methods:setParent ( ent, attachment )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ent, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) and not ent:IsPlayer() then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","\tif attachment then","\t\tSF.CheckType(attachment, \"string\")","\t\tthis:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\tend","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","2":"attachment","ent":"Entity to parent to","attachment":"Optional string attachment name to parent to"}},"applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},"setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"ignite":{"comment":["--- Ignites an entity","-- @param length How long the fire lasts","-- @param radius (optional) How large the fire hitbox is (entity obb is the max)"],"code":["function ents_methods:ignite( length, radius )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( length, \"number\" )","","\tlocal ent = unwrap( self )","","\tif radius then","\t\tSF.CheckType( radius, \"number\" )","\t\tlocal obbmins, obbmaxs = ent:OBBMins(), ent:OBBMaxs()","\t\tradius = math.Clamp( radius, 0, (obbmaxs.x - obbmins.x + obbmaxs.y - obbmins.y) / 2 )","\tend","","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Ignite( length, radius )","end",""],"class":"function","name":"ents_methods:ignite","summary":"\nIgnites an entity ","private":false,"classlib":"Entity","description":"\nIgnites an entity","param":{"1":"length","2":"radius","radius":"(optional) How large the fire hitbox is (entity obb is the max)","length":"How long the fire lasts"}},"breakEnt":{"comment":["--- Invokes the entity's breaking animation and removes it."],"code":["function ents_methods:breakEnt ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() or ent:IsFlagSet( FL_KILLME ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:AddFlags( FL_KILLME )","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:breakEnt","summary":"\nInvokes the entity's breaking animation and removes it.","private":false,"classlib":"Entity","description":"\nInvokes the entity's breaking animation and removes it.","param":[]},"setRenderMode":{"comment":["--- Sets the rende mode of the entity","-- @server","-- @class function","-- @param rendermode Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderMode ( rendermode, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( rendermode, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 7, rendermode )","\telse","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderMode = rendermode } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the rende mode of the entity ","name":"ents_methods:setRenderMode","classlib":"Entity","private":false,"server":true,"description":"\nSets the rende mode of the entity","param":{"1":"rendermode","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","rendermode":"Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE"}},"setRenderFX":{"comment":["--- Sets the renderfx of the entity","-- @server","-- @class function","-- @param renderfx Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderFX ( renderfx, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( renderfx, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 8, renderfx )","\telse","\t\tent:SetRenderFX( renderfx )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderFX = renderfx } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the renderfx of the entity ","name":"ents_methods:setRenderFX","classlib":"Entity","private":false,"server":true,"description":"\nSets the renderfx of the entity","param":{"1":"renderfx","2":"ply","renderfx":"Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","ply":"Optional player arguement to set only for that player. Can also be table of players."}}},"comment":["--- Entity type","--@class class","--@name Entity"],"typtbl":"ents_methods","param":[]},{"ret":"The entities owner, or nil if not found","comment":["--- Gets the entity's owner","-- TODO: Optimize this!","-- @return The entities owner, or nil if not found"],"code":["function SF.Entities.GetOwner ( entity )","\tif not isValid( entity ) then return end","","\tif entity.IsPlayer and entity:IsPlayer() then","\t\treturn entity","\tend","","\tif CPPI then","\t\tlocal owner = entity:CPPIGetOwner()","\t\tif isValid( owner ) then return owner end","\tend","","\tif entity.GetPlayer then","\t\tlocal ply = entity:GetPlayer()","\t\tif isValid( ply ) then return ply end","\tend","","\tif entity.owner and isValid( entity.owner ) and entity.owner:IsPlayer() then","\t\treturn entity.owner","\tend","","\tlocal OnDieFunctions = entity.OnDieFunctions","\tif OnDieFunctions then","\t\tif OnDieFunctions.GetCountUpdate and OnDieFunctions.GetCountUpdate.Args and OnDieFunctions.GetCountUpdate.Args[ 1 ] then","\t\t\treturn OnDieFunctions.GetCountUpdate.Args[ 1 ]","\t\telseif OnDieFunctions.undo1 and OnDieFunctions.undo1.Args and OnDieFunctions.undo1.Args[2] then","\t\t\treturn OnDieFunctions.undo1.Args[ 2 ]","\t\tend","\tend","","\tif entity.GetOwner then","\t\tlocal ply = entity:GetOwner()","\t\tif isValid( ply ) then return ply end","\tend","","\treturn nil","end","","local getPhysObject = SF.Entities.GetPhysObject","local getOwner = SF.Entities.GetOwner",""],"class":"function","name":"SF.Entities.GetOwner","private":false,"summary":"\nGets the entity's owner \nTODO: Optimize this! ","description":"\nGets the entity's owner \nTODO: Optimize this!","param":["entity"]},{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v[1] and v[1] < math.huge and","\t\t\t-math.huge < v[2] and v[2] < math.huge and","\t\t\t-math.huge < v[3] and v[3] < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to","-- @param attachment Optional string attachment name to parent to"],"code":["function ents_methods:setParent ( ent, attachment )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ent, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) and not ent:IsPlayer() then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","\tif attachment then","\t\tSF.CheckType(attachment, \"string\")","\t\tthis:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\tend","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","2":"attachment","ent":"Entity to parent to","attachment":"Optional string attachment name to parent to"}},{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},{"comment":["--- Links starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","-- @param e Entity to link the component to. nil to clear links."],"code":["function ents_methods:linkComponent ( e )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif e then","\t\tSF.CheckType( e, ents_metatable )","\t\tlocal link = unwrap( e )","\t\tif not isValid( link ) then SF.throw( \"Entity is not valid\", 2 ) end","\t\tif not SF.Permissions.check( SF.instance.player, link, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\tif link:GetClass()==\"starfall_processor\" and ( ent:GetClass()==\"starfall_screen\" or ent:GetClass()==\"starfall_hud\" ) then","\t\t\tent:LinkEnt( link )","\t\telseif link:IsVehicle() and ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkVehicle( link )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\telse","\t\tif ent:GetClass()==\"starfall_screen\" then","\t\t\tent:LinkEnt( nil )","\t\telseif ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkEnt( nil )","\t\t\tent:LinkVehicle( nil )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\tend","end","",""],"class":"function","name":"ents_methods:linkComponent","summary":"\nLinks starfall components to a starfall processor or vehicle.","private":false,"classlib":"Entity","description":"\nLinks starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","param":{"1":"e","e":"Entity to link the component to. nil to clear links."}},{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\t","\tlocal ang = SF.UnwrapObject( ang )","\tlocal ent = unwrap( self )","\t","\tif not check( ang ) then SF.throw( \"infinite angle\", 2) end","\t","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},{"comment":["--- Set's the entity to collide with nothing but the world","-- @param nocollide Whether to collide with nothing except world or not."],"code":["function ents_methods:setNocollideAll ( nocollide )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tent:SetCollisionGroup ( nocollide and COLLISION_GROUP_WORLD or COLLISION_GROUP_NONE )","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend,","\t[7] = function( mode ) --Rendermode","\t\tnet.WriteUInt( mode, 8 )","\tend,","\t[8] = function( fx ) --Renderfx","\t\tnet.WriteUInt( fx, 8 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tlocal meta = debug.getmetatable( ply )","\tif meta == SF.Types[ \"Player\" ] then ","\t\tply = unwrap( ply )","\t\tif not ( IsValid( ply ) and ply:IsPlayer() ) then","\t\t\tSF.throw( \"Tried to use invalid player\", 3 )","\t\tend","\telseif meta == nil and type( ply ) == \"table\" then","\t\tlocal ply2 = ply","\t\tply = {}","\t\tfor k, v in pairs( ply2 ) do","\t\t\tlocal p = unwrap( v )","\t\t\tif IsValid( p ) and p:IsPlayer() then","\t\t\t\tply[k] = p","\t\t\telse","\t\t\t\tSF.throw ( \"Invalid player object in table of players\", 3 )","\t\t\tend","\t\tend","\telse","\t\tSF.throw( \"Expected player or table of players.\", 3 )","\tend","\t","\tnet.Start( \"sf_setentityrenderproperty\" )","\tnet.WriteEntity( ent )","\tnet.WriteUInt( func, 4 )","\trenderProperties[ func ]( ... )","\tnet.Send( ply )","end",""],"class":"function","name":"ents_methods:setNocollideAll","summary":"\nSet's the entity to collide with nothing but the world ","private":false,"classlib":"Entity","description":"\nSet's the entity to collide with nothing but the world","param":{"1":"nocollide","nocollide":"Whether to collide with nothing except world or not."}},{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tlocal rendermode = ( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { Color = clr, RenderMode = rendermode } )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set only for that player. Can also be table of players."}},{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local shaderBlacklist = {","\t[ \"LightmappedGeneric\" ] = true,","}","local function invalidMaterial( material )","\tif string.find( string.lower( material ) , \"pp[%./\\\\]+copy\" ) then return true end","\tlocal mat = Material( material )","\tif mat and shaderBlacklist[ mat:GetShader() ] then return true end","end",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\t\tduplicator.StoreEntityModifier( ent, \"material\", { MaterialOverride = material } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","material":", string, New material name."}},{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set only for that player. Can also be table of players.","bodygroup":"Number, The ID of the bodygroup you're setting."}},{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},{"comment":["--- Sets the rende mode of the entity","-- @server","-- @class function","-- @param rendermode Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderMode ( rendermode, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( rendermode, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 7, rendermode )","\telse","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderMode = rendermode } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the rende mode of the entity ","name":"ents_methods:setRenderMode","classlib":"Entity","private":false,"server":true,"description":"\nSets the rende mode of the entity","param":{"1":"rendermode","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","rendermode":"Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE"}},{"comment":["--- Sets the renderfx of the entity","-- @server","-- @class function","-- @param renderfx Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderFX ( renderfx, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( renderfx, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 8, renderfx )","\telse","\t\tent:SetRenderFX( renderfx )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderFX = renderfx } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the renderfx of the entity ","name":"ents_methods:setRenderFX","classlib":"Entity","private":false,"server":true,"description":"\nSets the renderfx of the entity","param":{"1":"renderfx","2":"ply","renderfx":"Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","ply":"Optional player arguement to set only for that player. Can also be table of players."}},{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","\t","\tif not check( vel ) then SF.throw( \"infinite vector\", 2) end","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},{"comment":["--- Invokes the entity's breaking animation and removes it."],"code":["function ents_methods:breakEnt ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() or ent:IsFlagSet( FL_KILLME ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:AddFlags( FL_KILLME )","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:breakEnt","summary":"\nInvokes the entity's breaking animation and removes it.","private":false,"classlib":"Entity","description":"\nInvokes the entity's breaking animation and removes it.","param":[]},{"comment":["--- Ignites an entity","-- @param length How long the fire lasts","-- @param radius (optional) How large the fire hitbox is (entity obb is the max)"],"code":["function ents_methods:ignite( length, radius )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( length, \"number\" )","","\tlocal ent = unwrap( self )","","\tif radius then","\t\tSF.CheckType( radius, \"number\" )","\t\tlocal obbmins, obbmaxs = ent:OBBMins(), ent:OBBMaxs()","\t\tradius = math.Clamp( radius, 0, (obbmaxs.x - obbmins.x + obbmaxs.y - obbmins.y) / 2 )","\tend","","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Ignite( length, radius )","end",""],"class":"function","name":"ents_methods:ignite","summary":"\nIgnites an entity ","private":false,"classlib":"Entity","description":"\nIgnites an entity","param":{"1":"length","2":"radius","radius":"(optional) How large the fire hitbox is (entity obb is the max)","length":"How long the fire lasts"}},{"comment":["--- Extinguishes an entity"],"code":["function ents_methods:extinguish()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Extinguish()","end",""],"class":"function","name":"ents_methods:extinguish","summary":"\nExtinguishes an entity ","private":false,"classlib":"Entity","description":"\nExtinguishes an entity","param":[]},{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},{"comment":["--- Sets the physical material of the entity","-- @param mat Material to use"],"code":["function ents_methods:setPhysMaterial( mat )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( mat, \"string\" )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tconstruct.SetPhysProp( nil, ent, 0, phys, {Material = mat} ) ","end",""],"class":"function","name":"ents_methods:setPhysMaterial","summary":"\nSets the physical material of the entity ","private":false,"classlib":"Entity","description":"\nSets the physical material of the entity","param":{"1":"mat","mat":"Material to use"}},{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},{"comment":["--- Sets the physics of an entity to be a sphere","-- @param enabled Bool should the entity be spherical?"],"code":["function ents_methods:enableSphere ( enabled )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\t","\tif ent:GetClass() ~= \"prop_physics\" then SF.throw( \"This function only works for prop_physics\", 2 ) end","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal ismove = phys:IsMoveable()","\tlocal mass = phys:GetMass()","\t","\tif enabled then","\t\tif ent:GetMoveType() == MOVETYPE_VPHYSICS then","\t\t\tlocal OBB = ent:OBBMaxs() - ent:OBBMins()","\t\t\tlocal radius = math.max( OBB.x, OBB.y, OBB.z) / 2 ","\t\t\tent:PhysicsInitSphere( radius, phys:GetMaterial() )","\t\t\tent:SetCollisionBounds( Vector( -radius, -radius, -radius ) , Vector( radius, radius, radius ) )","\t\tend","\telse","\t\tif ent:GetMoveType() ~= MOVETYPE_VPHYSICS then","\t\t\tent:PhysicsInit( SOLID_VPHYSICS )","\t\t\tent:SetMoveType( MOVETYPE_VPHYSICS )","\t\t\tent:SetSolid( SOLID_VPHYSICS )","\t\tend","\tend","\t","\t-- New physobject after applying spherical collisions","\tlocal phys = ent:GetPhysicsObject()","\tphys:SetMass( mass )","\tphys:EnableMotion( ismove )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableSphere","summary":"\nSets the physics of an entity to be a sphere ","private":false,"classlib":"Entity","description":"\nSets the physics of an entity to be a sphere","param":{"1":"enabled","enabled":"Bool should the entity be spherical?"}},{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end","",""],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},{"comment":["--- Adds a trail to the entity with the specified attributes.","-- @param startSize The start size of the trail","-- @param endSize The end size of the trail","-- @param length The length size of the trail","-- @param material The material of the trail","-- @param color The color of the trail","-- @param attachmentID Optional attachmentid the trail should attach to","-- @param additive If the trail's rendering is additive"],"code":["function ents_methods:setTrails(startSize, endSize, length, material, color, attachmentID, additive)","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( material, \"string\" )","\t","\tlocal ent = unwrap( self )","","\tif string.find(material, '\"', 1, true) then SF.throw( \"Invalid Material\", 2 ) end","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal Data = {","\t\tColor = SF.Color.Unwrap( color ),","\t\tLength = length,","\t\tStartSize = math.Clamp( startSize, 0, 128 ),","\t\tEndSize = math.Clamp( endSize, 0, 128 ),","\t\tMaterial = material,","\t\tAttachmentID = attachmentID,","\t\tAdditive = additive,","\t}","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, Data)","end",""],"class":"function","name":"ents_methods:setTrails","summary":"\nAdds a trail to the entity with the specified attributes.","private":false,"classlib":"Entity","description":"\nAdds a trail to the entity with the specified attributes.","param":{"1":"startSize","2":"endSize","3":"length","4":"material","5":"color","6":"attachmentID","7":"additive","startSize":"The start size of the trail","length":"The length size of the trail","attachmentID":"Optional attachmentid the trail should attach to","color":"The color of the trail","material":"The material of the trail","endSize":"The end size of the trail","additive":"If the trail's rendering is additive"}},{"comment":["--- Removes trails from the entity"],"code":["function ents_methods:removeTrails()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, nil)","end",""],"class":"function","name":"ents_methods:removeTrails","summary":"\nRemoves trails from the entity ","private":false,"classlib":"Entity","description":"\nRemoves trails from the entity","param":[]}],"tables":[],"description":"\n \nServerside Entity functions \n","summary":"\n \nServerside Entity functions \n "},"libs_sh/json.lua":{"libraries":{"1":"json","json":{"comment":["--- JSON library","-- @shared"],"functions":{"1":"decode","2":"encode","encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"class":"library","summary":"\nJSON library ","code":["local json_library, _ = SF.Libraries.Register( \"json\" )","local util = util",""],"fields":[],"name":"json","client":true,"description":"\nJSON library","libtbl":"json_library","tables":[],"server":true}},"type":"file","name":"libs_sh/json.lua","functions":{"1":"json_library.decode","2":"json_library.encode","json_library.encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"json_library.decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"doc":[{"summary":"\nJSON library ","description":"\nJSON library","comment":["--- JSON library"],"code":[""]},{"comment":["--- JSON library","-- @shared"],"functions":{"1":"decode","2":"encode","encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"class":"library","summary":"\nJSON library ","code":["local json_library, _ = SF.Libraries.Register( \"json\" )","local util = util",""],"fields":[],"name":"json","client":true,"description":"\nJSON library","libtbl":"json_library","tables":[],"server":true},{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}],"tables":[],"description":"\nJSON library","summary":"\nJSON library "},"instance.lua":{"libraries":[],"type":"file","name":"instance.lua","functions":{"1":"SF.Instance:Error","2":"SF.Instance:cleanup","3":"SF.Instance:deinitialize","4":"SF.Instance:initialize","5":"SF.Instance:iterScriptHook","6":"SF.Instance:iterTblScriptHook","7":"SF.Instance:prepare","8":"SF.Instance:runFunction","9":"SF.Instance:runFunctionT","10":"SF.Instance:runLibraryHook","11":"SF.Instance:runScriptHook","12":"SF.Instance:runScriptHookForResult","13":"SF.Instance:runWithOps","SF.Instance:runScriptHook":{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered"],"comment":["--- Runs a script hook. This calls script code.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered"],"code":["function SF.Instance:runScriptHook(hook, ...)","\tfor ok,err,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false,err,traceback end","\tend","\treturn true","end",""],"class":"function","name":"SF.Instance:runScriptHook","private":false,"summary":"\nRuns a script hook.","description":"\nRuns a script hook. This calls script code.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},"SF.Instance:runWithOps":{"ret":["True if ok","A table of values that the hook returned"],"comment":["--- Internal function - do not call.","-- Runs a function while incrementing the instance ops coutner.","-- This does no setup work and shouldn't be called by client code","-- @param func The function to run","-- @param ... Arguments to func","-- @return True if ok","-- @return A table of values that the hook returned"],"code":["function SF.Instance:runWithOps(func,...)","","\tlocal args = { ... }","\tlocal nargs = select( \"#\", ... )","\tlocal traceback","","\tlocal wrapperfunc = function ()","\t\treturn { func( unpack( args, 1, nargs ) ) }","\tend","","\tlocal function xpcall_callback ( err )","\t\tif type( err ) == \"table\" then","\t\t\tif type( err.message ) == \"string\" then","\t\t\t\tlocal line= err.line","\t\t\t\tlocal file = err.file","","\t\t\t\terr = ( file and ( file .. \":\" ) or \"\" ) .. ( line and ( line .. \": \" ) or \"\" ) .. err.message","\t\t\tend","\t\tend","\t\terr = tostring( err )","\t\ttraceback = debug.traceback( err, 2 )","\t\treturn err","\tend","","\tlocal ok, rt","\tif self.instanceStack then","\t\t--Already measuring cpu time. Just call it","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\telse","\t\t--Start measuring cpu time","\t\tlocal oldSysTime = SysTime() - self.cpu_total","\t\tlocal function cpuCheck ()","\t\t\tself.cpu_total = SysTime() - oldSysTime","\t\t\tlocal usedRatio = self:movingCPUAverage()/self.context.cpuTime:getMax()","\t\t\tif usedRatio>1 then","\t\t\t\tdebug.sethook( nil )","\t\t\t\tSF.throw( \"CPU Quota exceeded.\", 0, true )","\t\t\telseif usedRatio > self.cpu_softquota then","\t\t\t\tSF.throw( \"CPU Quota warning.\", 0 )","\t\t\tend","\t\tend","\t\tdebug.sethook( cpuCheck, \"\", 500 )","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\t\tdebug.sethook( nil )","\tend","\t","\t","\tif ok then","\t\treturn true, rt","\telse","\t\treturn false, rt, traceback","\tend","end",""],"class":"function","name":"SF.Instance:runWithOps","private":false,"summary":"\nInternal function - do not call.","description":"\nInternal function - do not call. \nRuns a function while incrementing the instance ops coutner. \nThis does no setup work and shouldn't be called by client code","param":{"1":"func","2":"...","func":"The function to run","...":"Arguments to func"}},"SF.Instance:runFunctionT":{"summary":"\nExactly the same as runFunction except doesn't unpack the return values ","description":"\nExactly the same as runFunction except doesn't unpack the return values","comment":["--- Exactly the same as runFunction except doesn't unpack the return values","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunctionT(func,...)","\tif self:prepare(\"_runFunction\",func) then return true end","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, tbl","end",""],"private":false,"class":"function","name":"SF.Instance:runFunctionT","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},"SF.Instance:deinitialize":{"summary":"\nDeinitializes the instance.","description":"\nDeinitializes the instance. After this, the instance should be discarded.","comment":["--- Deinitializes the instance. After this, the instance should be discarded."],"code":["function SF.Instance:deinitialize()","\tself:runLibraryHook(\"deinitialize\")","\tSF.allInstances[self] = nil","\tself.error = true","end",""],"private":false,"class":"function","name":"SF.Instance:deinitialize","param":[]},"SF.Instance:Error":{"summary":"\nErrors the instance.","description":"\nErrors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)","comment":["--- Errors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)"],"code":["function SF.Instance:Error(msg,traceback)","\t","\tif self.runOnError then -- We have a custom error function, use that instead","\t\tself:runOnError( msg, traceback )","\t\treturn","\tend","\t","\t-- Default behavior","\tself:deinitialize()","end","","function SF.Instance:movingCPUAverage()","\tlocal n = self.context.cpuTime:getBufferN()","\treturn (self.cpu_average * (n - 1) + self.cpu_total) / n","end"],"private":false,"class":"function","name":"SF.Instance:Error","param":["msg","traceback"]},"SF.Instance:iterTblScriptHook":{"ret":"An iterator function returning the ok status, then either the table of \nhook results or the error message and traceback","comment":["--- Like SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, then either the table of","-- hook results or the error message and traceback"],"code":["function SF.Instance:iterTblScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tif self:prepare(hook,name) then return true end","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, tbl","\tend","end",""],"class":"function","name":"SF.Instance:iterTblScriptHook","private":false,"summary":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","description":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function."}},"SF.Instance:iterScriptHook":{"ret":"An iterator function returning the ok status, and then either the hook \nresults or the error message and traceback","comment":["--- Creates an iterator that calls each registered function for a hook.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, and then either the hook","-- results or the error message and traceback"],"code":["function SF.Instance:iterScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tif self:prepare(hook,name) then return true end","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, unpack(tbl)","\tend","end",""],"class":"function","name":"SF.Instance:iterScriptHook","private":false,"summary":"\nCreates an iterator that calls each registered function for a hook.","description":"\nCreates an iterator that calls each registered function for a hook.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},"SF.Instance:prepare":{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Prepares the script to be executed. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Prepares the script to be executed.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:prepare(hook, name)","\tassert(self.initialized, \"Instance not initialized!\")","\t--Functions calling this one will silently halt.","\tif self.error then return true end","\t","\tif SF.instance ~= nil then","\t\tself.instanceStack = self.instanceStack or {}","\t\tself.instanceStack[#self.instanceStack + 1] = SF.instance","\t\tSF.instance = nil","\tend","\t","\tself:runLibraryHook(\"prepare\",hook, name)","\tSF.instance = self","end",""],"private":false,"class":"function","name":"SF.Instance:prepare","param":["hook","name"]},"SF.Instance:cleanup":{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Cleans up the script. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Cleans up the script.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:cleanup(hook, name, ok, errmsg)","\tassert(SF.instance == self)","\tself:runLibraryHook(\"cleanup\",hook, name, ok, errmsg)","\t","\tif self.instanceStack then","\t\tSF.instance = self.instanceStack[#self.instanceStack]","\t\tif #self.instanceStack == 1 then self.instanceStack = nil","\t\telse self.instanceStack[#self.instanceStack] = nil","\t\tend","\telse","\t\tSF.instance = nil","\tend","\t","end",""],"private":false,"class":"function","name":"SF.Instance:cleanup","param":["hook","name","ok","errmsg"]},"SF.Instance:runFunction":{"summary":"\nRuns an arbitrary function under the SF instance.","description":"\nRuns an arbitrary function under the SF instance. This can be used \nto run your own hooks when using the integrated hook system doesn't \nmake sense (ex timers).","comment":["--- Runs an arbitrary function under the SF instance. This can be used","-- to run your own hooks when using the integrated hook system doesn't","-- make sense (ex timers).","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunction(func,...)","\tif self:prepare(\"_runFunction\",func) then return true end","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, unpack(tbl)","end",""],"private":false,"class":"function","name":"SF.Instance:runFunction","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},"SF.Instance:runLibraryHook":{"summary":"\nRuns a library hook.","description":"\nRuns a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","comment":["--- Runs a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","-- @param hook Hook to run.","-- @param ... Additional arguments."],"code":["function SF.Instance:runLibraryHook(hook, ...)","\treturn SF.Libraries.CallHook(hook,self,...)","end",""],"private":false,"class":"function","name":"SF.Instance:runLibraryHook","param":{"1":"hook","2":"...","...":"Additional arguments.","hook":"Hook to run."}},"SF.Instance:runScriptHookForResult":{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","The traceback if the instance errored"],"comment":["--- Runs a script hook until one of them returns a true value. Returns those values.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","-- @return The traceback if the instance errored"],"code":["function SF.Instance:runScriptHookForResult(hook,...)","\tfor ok,tbl,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false, tbl, traceback","\t\telseif tbl and tbl[1] then","\t\t\treturn true, unpack(tbl)","\t\tend","\tend","\treturn true","end","","-- Some small efficiency thing","local noop = function() end",""],"class":"function","name":"SF.Instance:runScriptHookForResult","private":false,"summary":"\nRuns a script hook until one of them returns a true value.","description":"\nRuns a script hook until one of them returns a true value. Returns those values.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},"SF.Instance:initialize":{"ret":["True if no script errors occured","The error message, if applicable","The error traceback, if applicable"],"comment":["--- Runs the scripts inside of the instance. This should be called once after","-- compiling/unpacking so that scripts can register hooks and such. It should","-- not be called more than once.","-- @return True if no script errors occured","-- @return The error message, if applicable","-- @return The error traceback, if applicable"],"code":["function SF.Instance:initialize()","\tassert(not self.initialized, \"Already initialized!\")","\tself.initialized = true","","\tself.cpu_total = 0","\tself.cpu_average = 0","\tself.cpu_softquota = 1","","\tself:runLibraryHook(\"initialize\")","\tself:prepare(\"_initialize\",\"_initialize\")","\t","\tlocal func = self.scripts[self.mainfile]","\tlocal ok, err, traceback = self:runWithOps(func)","\tif not ok then","\t\tself:cleanup(\"_initialize\", true, err, traceback)","\t\tself.error = true","\t\treturn false, err, traceback","\tend","\t","\tSF.allInstances[self] = self","\t","\tself:cleanup(\"_initialize\",\"_initialize\",false)","\treturn true","end",""],"class":"function","name":"SF.Instance:initialize","private":false,"summary":"\nRuns the scripts inside of the instance.","description":"\nRuns the scripts inside of the instance. This should be called once after \ncompiling/unpacking so that scripts can register hooks and such. It should \nnot be called more than once.","param":[]}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Instance class.","-- Contains the compiled SF script and essential data. Essentially","-- the execution context.","---------------------------------------------------------------------"],"code":["","SF.Instance = {}","SF.Instance.__index = SF.Instance",""],"summary":"\n \nSF Instance class.","description":"\n \nSF Instance class. \nContains the compiled SF script and essential data. Essentially \nthe execution context. \n","param":[]},{"classForced":true,"summary":"\nInstance fields ","comment":["--- Instance fields","-- @name Instance","-- @class table","-- @field env Environment table for the script","-- @field data Data that libraries can store.","-- @field ppdata Preprocessor data","-- @field ops Currently used ops.","-- @field hooks Registered hooks","-- @field scripts The compiled script functions.","-- @field initialized True if initialized, nil if not.","-- @field error True if instance is errored and should not be executed","-- @field mainfile The main file","-- @field player The \"owner\" of the instance"],"code":[""],"description":"\nInstance fields","class":"table","name":"Instance","field":{"1":"env","2":"data","3":"ppdata","4":"ops","5":"hooks","6":"scripts","7":"initialized","8":"error","9":"mainfile","10":"player","initialized":"True if initialized, nil if not.","ppdata":"Preprocessor data","data":"Data that libraries can store.","ops":"Currently used ops.","player":"The \"owner\" of the instance","scripts":"The compiled script functions.","env":"Environment table for the script","mainfile":"The main file","error":"True if instance is errored and should not be executed","hooks":"Registered hooks"}},{"ret":["True if ok","A table of values that the hook returned"],"comment":["--- Internal function - do not call.","-- Runs a function while incrementing the instance ops coutner.","-- This does no setup work and shouldn't be called by client code","-- @param func The function to run","-- @param ... Arguments to func","-- @return True if ok","-- @return A table of values that the hook returned"],"code":["function SF.Instance:runWithOps(func,...)","","\tlocal args = { ... }","\tlocal nargs = select( \"#\", ... )","\tlocal traceback","","\tlocal wrapperfunc = function ()","\t\treturn { func( unpack( args, 1, nargs ) ) }","\tend","","\tlocal function xpcall_callback ( err )","\t\tif type( err ) == \"table\" then","\t\t\tif type( err.message ) == \"string\" then","\t\t\t\tlocal line= err.line","\t\t\t\tlocal file = err.file","","\t\t\t\terr = ( file and ( file .. \":\" ) or \"\" ) .. ( line and ( line .. \": \" ) or \"\" ) .. err.message","\t\t\tend","\t\tend","\t\terr = tostring( err )","\t\ttraceback = debug.traceback( err, 2 )","\t\treturn err","\tend","","\tlocal ok, rt","\tif self.instanceStack then","\t\t--Already measuring cpu time. Just call it","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\telse","\t\t--Start measuring cpu time","\t\tlocal oldSysTime = SysTime() - self.cpu_total","\t\tlocal function cpuCheck ()","\t\t\tself.cpu_total = SysTime() - oldSysTime","\t\t\tlocal usedRatio = self:movingCPUAverage()/self.context.cpuTime:getMax()","\t\t\tif usedRatio>1 then","\t\t\t\tdebug.sethook( nil )","\t\t\t\tSF.throw( \"CPU Quota exceeded.\", 0, true )","\t\t\telseif usedRatio > self.cpu_softquota then","\t\t\t\tSF.throw( \"CPU Quota warning.\", 0 )","\t\t\tend","\t\tend","\t\tdebug.sethook( cpuCheck, \"\", 500 )","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\t\tdebug.sethook( nil )","\tend","\t","\t","\tif ok then","\t\treturn true, rt","\telse","\t\treturn false, rt, traceback","\tend","end",""],"class":"function","name":"SF.Instance:runWithOps","private":false,"summary":"\nInternal function - do not call.","description":"\nInternal function - do not call. \nRuns a function while incrementing the instance ops coutner. \nThis does no setup work and shouldn't be called by client code","param":{"1":"func","2":"...","func":"The function to run","...":"Arguments to func"}},{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Prepares the script to be executed. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Prepares the script to be executed.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:prepare(hook, name)","\tassert(self.initialized, \"Instance not initialized!\")","\t--Functions calling this one will silently halt.","\tif self.error then return true end","\t","\tif SF.instance ~= nil then","\t\tself.instanceStack = self.instanceStack or {}","\t\tself.instanceStack[#self.instanceStack + 1] = SF.instance","\t\tSF.instance = nil","\tend","\t","\tself:runLibraryHook(\"prepare\",hook, name)","\tSF.instance = self","end",""],"private":false,"class":"function","name":"SF.Instance:prepare","param":["hook","name"]},{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Cleans up the script. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Cleans up the script.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:cleanup(hook, name, ok, errmsg)","\tassert(SF.instance == self)","\tself:runLibraryHook(\"cleanup\",hook, name, ok, errmsg)","\t","\tif self.instanceStack then","\t\tSF.instance = self.instanceStack[#self.instanceStack]","\t\tif #self.instanceStack == 1 then self.instanceStack = nil","\t\telse self.instanceStack[#self.instanceStack] = nil","\t\tend","\telse","\t\tSF.instance = nil","\tend","\t","end",""],"private":false,"class":"function","name":"SF.Instance:cleanup","param":["hook","name","ok","errmsg"]},{"ret":["True if no script errors occured","The error message, if applicable","The error traceback, if applicable"],"comment":["--- Runs the scripts inside of the instance. This should be called once after","-- compiling/unpacking so that scripts can register hooks and such. It should","-- not be called more than once.","-- @return True if no script errors occured","-- @return The error message, if applicable","-- @return The error traceback, if applicable"],"code":["function SF.Instance:initialize()","\tassert(not self.initialized, \"Already initialized!\")","\tself.initialized = true","","\tself.cpu_total = 0","\tself.cpu_average = 0","\tself.cpu_softquota = 1","","\tself:runLibraryHook(\"initialize\")","\tself:prepare(\"_initialize\",\"_initialize\")","\t","\tlocal func = self.scripts[self.mainfile]","\tlocal ok, err, traceback = self:runWithOps(func)","\tif not ok then","\t\tself:cleanup(\"_initialize\", true, err, traceback)","\t\tself.error = true","\t\treturn false, err, traceback","\tend","\t","\tSF.allInstances[self] = self","\t","\tself:cleanup(\"_initialize\",\"_initialize\",false)","\treturn true","end",""],"class":"function","name":"SF.Instance:initialize","private":false,"summary":"\nRuns the scripts inside of the instance.","description":"\nRuns the scripts inside of the instance. This should be called once after \ncompiling/unpacking so that scripts can register hooks and such. It should \nnot be called more than once.","param":[]},{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered"],"comment":["--- Runs a script hook. This calls script code.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered"],"code":["function SF.Instance:runScriptHook(hook, ...)","\tfor ok,err,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false,err,traceback end","\tend","\treturn true","end",""],"class":"function","name":"SF.Instance:runScriptHook","private":false,"summary":"\nRuns a script hook.","description":"\nRuns a script hook. This calls script code.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","The traceback if the instance errored"],"comment":["--- Runs a script hook until one of them returns a true value. Returns those values.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","-- @return The traceback if the instance errored"],"code":["function SF.Instance:runScriptHookForResult(hook,...)","\tfor ok,tbl,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false, tbl, traceback","\t\telseif tbl and tbl[1] then","\t\t\treturn true, unpack(tbl)","\t\tend","\tend","\treturn true","end","","-- Some small efficiency thing","local noop = function() end",""],"class":"function","name":"SF.Instance:runScriptHookForResult","private":false,"summary":"\nRuns a script hook until one of them returns a true value.","description":"\nRuns a script hook until one of them returns a true value. Returns those values.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},{"ret":"An iterator function returning the ok status, and then either the hook \nresults or the error message and traceback","comment":["--- Creates an iterator that calls each registered function for a hook.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, and then either the hook","-- results or the error message and traceback"],"code":["function SF.Instance:iterScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tif self:prepare(hook,name) then return true end","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, unpack(tbl)","\tend","end",""],"class":"function","name":"SF.Instance:iterScriptHook","private":false,"summary":"\nCreates an iterator that calls each registered function for a hook.","description":"\nCreates an iterator that calls each registered function for a hook.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},{"ret":"An iterator function returning the ok status, then either the table of \nhook results or the error message and traceback","comment":["--- Like SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, then either the table of","-- hook results or the error message and traceback"],"code":["function SF.Instance:iterTblScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tif self:prepare(hook,name) then return true end","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, tbl","\tend","end",""],"class":"function","name":"SF.Instance:iterTblScriptHook","private":false,"summary":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","description":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function."}},{"summary":"\nRuns a library hook.","description":"\nRuns a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","comment":["--- Runs a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","-- @param hook Hook to run.","-- @param ... Additional arguments."],"code":["function SF.Instance:runLibraryHook(hook, ...)","\treturn SF.Libraries.CallHook(hook,self,...)","end",""],"private":false,"class":"function","name":"SF.Instance:runLibraryHook","param":{"1":"hook","2":"...","...":"Additional arguments.","hook":"Hook to run."}},{"summary":"\nRuns an arbitrary function under the SF instance.","description":"\nRuns an arbitrary function under the SF instance. This can be used \nto run your own hooks when using the integrated hook system doesn't \nmake sense (ex timers).","comment":["--- Runs an arbitrary function under the SF instance. This can be used","-- to run your own hooks when using the integrated hook system doesn't","-- make sense (ex timers).","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunction(func,...)","\tif self:prepare(\"_runFunction\",func) then return true end","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, unpack(tbl)","end",""],"private":false,"class":"function","name":"SF.Instance:runFunction","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},{"summary":"\nExactly the same as runFunction except doesn't unpack the return values ","description":"\nExactly the same as runFunction except doesn't unpack the return values","comment":["--- Exactly the same as runFunction except doesn't unpack the return values","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunctionT(func,...)","\tif self:prepare(\"_runFunction\",func) then return true end","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, tbl","end",""],"private":false,"class":"function","name":"SF.Instance:runFunctionT","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},{"summary":"\nDeinitializes the instance.","description":"\nDeinitializes the instance. After this, the instance should be discarded.","comment":["--- Deinitializes the instance. After this, the instance should be discarded."],"code":["function SF.Instance:deinitialize()","\tself:runLibraryHook(\"deinitialize\")","\tSF.allInstances[self] = nil","\tself.error = true","end",""],"private":false,"class":"function","name":"SF.Instance:deinitialize","param":[]},{"summary":"\nErrors the instance.","description":"\nErrors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)","comment":["--- Errors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)"],"code":["function SF.Instance:Error(msg,traceback)","\t","\tif self.runOnError then -- We have a custom error function, use that instead","\t\tself:runOnError( msg, traceback )","\t\treturn","\tend","\t","\t-- Default behavior","\tself:deinitialize()","end","","function SF.Instance:movingCPUAverage()","\tlocal n = self.context.cpuTime:getBufferN()","\treturn (self.cpu_average * (n - 1) + self.cpu_total) / n","end"],"private":false,"class":"function","name":"SF.Instance:Error","param":["msg","traceback"]}],"tables":{"1":"Instance","Instance":{"classForced":true,"summary":"\nInstance fields ","comment":["--- Instance fields","-- @name Instance","-- @class table","-- @field env Environment table for the script","-- @field data Data that libraries can store.","-- @field ppdata Preprocessor data","-- @field ops Currently used ops.","-- @field hooks Registered hooks","-- @field scripts The compiled script functions.","-- @field initialized True if initialized, nil if not.","-- @field error True if instance is errored and should not be executed","-- @field mainfile The main file","-- @field player The \"owner\" of the instance"],"code":[""],"description":"\nInstance fields","class":"table","name":"Instance","field":{"1":"env","2":"data","3":"ppdata","4":"ops","5":"hooks","6":"scripts","7":"initialized","8":"error","9":"mainfile","10":"player","initialized":"True if initialized, nil if not.","ppdata":"Preprocessor data","data":"Data that libraries can store.","ops":"Currently used ops.","player":"The \"owner\" of the instance","scripts":"The compiled script functions.","env":"Environment table for the script","mainfile":"The main file","error":"True if instance is errored and should not be executed","hooks":"Registered hooks"}}},"description":"\n \nSF Instance class. \nContains the compiled SF script and essential data. Essentially \nthe execution context. \n","summary":"\n \nSF Instance class."},"libraries.lua":{"libraries":[],"type":"file","name":"libraries.lua","functions":{"1":"SF.Libraries.AddHook","2":"SF.Libraries.CallHook","3":"SF.Libraries.CreateLocalTbl","4":"SF.Libraries.Get","5":"SF.Libraries.GetLocal","6":"SF.Libraries.Register","7":"SF.Libraries.RegisterLocal","SF.Libraries.CallHook":{"summary":"\nCalls a library hook.","description":"\nCalls a library hook.","comment":["--- Calls a library hook.","-- @param hookname The name of the hook.","-- @param ... The arguments to the functions that are called."],"code":["function SF.Libraries.CallHook(hookname, ...)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then return end","\t","\tfor i=1,#hook do","\t\thook[i](...)","\tend","end"],"private":false,"class":"function","name":"SF.Libraries.CallHook","param":{"1":"hookname","2":"...","...":"The arguments to the functions that are called.","hookname":"The name of the hook."}},"SF.Libraries.Get":{"ret":"A metatable proxy of the library","comment":["--- Gets a global library by name","-- @param name The name of the library","-- @return A metatable proxy of the library"],"code":["function SF.Libraries.Get(name)","\treturn SF.Libraries.libraries[name] and setmetatable({},SF.Libraries.libraries[name])","end",""],"class":"function","name":"SF.Libraries.Get","private":false,"summary":"\nGets a global library by name ","description":"\nGets a global library by name","param":{"1":"name","name":"The name of the library"}},"SF.Libraries.AddHook":{"summary":"\nRegisters a library hook.","description":"\nRegisters a library hook. These hooks are only available to SF libraries, \nand are called by Libraries.CallHook.","comment":["--- Registers a library hook. These hooks are only available to SF libraries,","-- and are called by Libraries.CallHook.","-- @param hookname The name of the hook.","-- @param func The function to call"],"code":["function SF.Libraries.AddHook(hookname, func)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then","\t\thook = {}","\t\tSF.Libraries.hooks[hookname] = hook","\tend","\t","\thook[#hook+1] = func","end",""],"private":false,"class":"function","name":"SF.Libraries.AddHook","param":{"1":"hookname","2":"func","func":"The function to call","hookname":"The name of the hook."}},"SF.Libraries.CreateLocalTbl":{"summary":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","description":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","comment":["--- Creates a table for use in SF.CreateContext containing all of the","-- local libraries in arr.","-- @param arr Array of local libraries to load"],"code":["function SF.Libraries.CreateLocalTbl(arr)","\tlocal tbl = {}","\tfor i=1,#arr do","\t\tlocal lib = arr[i]","\t\ttbl[lib] = SF.Libraries.Local[lib] or SF.throw( string.format( \"Requested nonexistant library '%s'\", lib ), 2 )","\tend","\treturn tbl","end",""],"private":false,"class":"function","name":"SF.Libraries.CreateLocalTbl","param":{"1":"arr","arr":"Array of local libraries to load"}},"SF.Libraries.Register":{"summary":"\nCreates and registers a global library.","description":"\nCreates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context. \nThis will automatically set __index and __metatable.","comment":["--- Creates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context.","-- This will automatically set __index and __metatable.","-- @param name The library name"],"code":["function SF.Libraries.Register ( name )","\tlocal methods, metamethods = SF.Typedef( \"Library: \" .. name )","\tSF.Libraries.libraries[ name ] = metamethods","\tSF.DefaultEnvironment[ name ] = setmetatable( {}, metamethods )","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.Register","param":{"1":"name","name":"The library name"}},"SF.Libraries.RegisterLocal":{"summary":"\nCreates and registers a local library.","description":"\nCreates and registers a local library. The library must be added to the context's \nlocal libraries field.","comment":["--- Creates and registers a local library. The library must be added to the context's","-- local libraries field."],"code":["function SF.Libraries.RegisterLocal(name)","\tlocal methods, metamethods = SF.Typedef(\"Library: \"..name)","\tSF.Libraries.Local[name] = metamethods","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.RegisterLocal","param":["name"]},"SF.Libraries.GetLocal":{"ret":"The library (not a metatable proxy!)","comment":["--- Gets a local library by name","-- @param name The name of the library","-- @return The library (not a metatable proxy!)"],"code":["function SF.Libraries.GetLocal(name)","\treturn SF.Libraries.Local[name]","end",""],"class":"function","name":"SF.Libraries.GetLocal","private":false,"summary":"\nGets a local library by name ","description":"\nGets a local library by name","param":{"1":"name","name":"The name of the library"}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Global Library management","---------------------------------------------------------------------"],"code":["","SF.Libraries = {}","","SF.Libraries.libraries = {}","SF.Libraries.hooks = {}",""],"summary":"\n \nSF Global Library management \n ","description":"\n \nSF Global Library management \n","param":[]},{"classForced":true,"summary":"\nPlace to store local libraries ","comment":["--- Place to store local libraries","-- @name SF.Libraries.Local","-- @class table"],"code":["SF.Libraries.Local = {}",""],"name":"SF.Libraries.Local","class":"table","description":"\nPlace to store local libraries","param":[]},{"summary":"\nCreates and registers a global library.","description":"\nCreates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context. \nThis will automatically set __index and __metatable.","comment":["--- Creates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context.","-- This will automatically set __index and __metatable.","-- @param name The library name"],"code":["function SF.Libraries.Register ( name )","\tlocal methods, metamethods = SF.Typedef( \"Library: \" .. name )","\tSF.Libraries.libraries[ name ] = metamethods","\tSF.DefaultEnvironment[ name ] = setmetatable( {}, metamethods )","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.Register","param":{"1":"name","name":"The library name"}},{"summary":"\nCreates and registers a local library.","description":"\nCreates and registers a local library. The library must be added to the context's \nlocal libraries field.","comment":["--- Creates and registers a local library. The library must be added to the context's","-- local libraries field."],"code":["function SF.Libraries.RegisterLocal(name)","\tlocal methods, metamethods = SF.Typedef(\"Library: \"..name)","\tSF.Libraries.Local[name] = metamethods","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.RegisterLocal","param":["name"]},{"ret":"A metatable proxy of the library","comment":["--- Gets a global library by name","-- @param name The name of the library","-- @return A metatable proxy of the library"],"code":["function SF.Libraries.Get(name)","\treturn SF.Libraries.libraries[name] and setmetatable({},SF.Libraries.libraries[name])","end",""],"class":"function","name":"SF.Libraries.Get","private":false,"summary":"\nGets a global library by name ","description":"\nGets a global library by name","param":{"1":"name","name":"The name of the library"}},{"ret":"The library (not a metatable proxy!)","comment":["--- Gets a local library by name","-- @param name The name of the library","-- @return The library (not a metatable proxy!)"],"code":["function SF.Libraries.GetLocal(name)","\treturn SF.Libraries.Local[name]","end",""],"class":"function","name":"SF.Libraries.GetLocal","private":false,"summary":"\nGets a local library by name ","description":"\nGets a local library by name","param":{"1":"name","name":"The name of the library"}},{"summary":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","description":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","comment":["--- Creates a table for use in SF.CreateContext containing all of the","-- local libraries in arr.","-- @param arr Array of local libraries to load"],"code":["function SF.Libraries.CreateLocalTbl(arr)","\tlocal tbl = {}","\tfor i=1,#arr do","\t\tlocal lib = arr[i]","\t\ttbl[lib] = SF.Libraries.Local[lib] or SF.throw( string.format( \"Requested nonexistant library '%s'\", lib ), 2 )","\tend","\treturn tbl","end",""],"private":false,"class":"function","name":"SF.Libraries.CreateLocalTbl","param":{"1":"arr","arr":"Array of local libraries to load"}},{"summary":"\nRegisters a library hook.","description":"\nRegisters a library hook. These hooks are only available to SF libraries, \nand are called by Libraries.CallHook.","comment":["--- Registers a library hook. These hooks are only available to SF libraries,","-- and are called by Libraries.CallHook.","-- @param hookname The name of the hook.","-- @param func The function to call"],"code":["function SF.Libraries.AddHook(hookname, func)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then","\t\thook = {}","\t\tSF.Libraries.hooks[hookname] = hook","\tend","\t","\thook[#hook+1] = func","end",""],"private":false,"class":"function","name":"SF.Libraries.AddHook","param":{"1":"hookname","2":"func","func":"The function to call","hookname":"The name of the hook."}},{"summary":"\nCalls a library hook.","description":"\nCalls a library hook.","comment":["--- Calls a library hook.","-- @param hookname The name of the hook.","-- @param ... The arguments to the functions that are called."],"code":["function SF.Libraries.CallHook(hookname, ...)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then return end","\t","\tfor i=1,#hook do","\t\thook[i](...)","\tend","end"],"private":false,"class":"function","name":"SF.Libraries.CallHook","param":{"1":"hookname","2":"...","...":"The arguments to the functions that are called.","hookname":"The name of the hook."}}],"tables":{"1":"SF.Libraries.Local","SF.Libraries.Local":{"classForced":true,"summary":"\nPlace to store local libraries ","comment":["--- Place to store local libraries","-- @name SF.Libraries.Local","-- @class table"],"code":["SF.Libraries.Local = {}",""],"name":"SF.Libraries.Local","class":"table","description":"\nPlace to store local libraries","param":[]}},"description":"\n \nSF Global Library management \n","summary":"\n \nSF Global Library management \n "},"libs_sh/entities.lua":{"libraries":[],"type":"file","name":"libs_sh/entities.lua","functions":{"1":"SF.Entities.GetPhysObject","2":"ents_metamethods:__tostring","3":"ents_methods:entIndex","4":"ents_methods:getAngleVelocity","5":"ents_methods:getAngles","6":"ents_methods:getAttachment","7":"ents_methods:getAttachmentParent","8":"ents_methods:getClass","9":"ents_methods:getColor","10":"ents_methods:getEyeAngles","11":"ents_methods:getEyePos","12":"ents_methods:getForward","13":"ents_methods:getHealth","14":"ents_methods:getInertia","15":"ents_methods:getMass","16":"ents_methods:getMassCenter","17":"ents_methods:getMassCenterW","18":"ents_methods:getMaterial","19":"ents_methods:getMaterials","20":"ents_methods:getMatrix","21":"ents_methods:getMaxHealth","22":"ents_methods:getModel","23":"ents_methods:getParent","24":"ents_methods:getPos","25":"ents_methods:getRight","26":"ents_methods:getSkin","27":"ents_methods:getSubMaterial","28":"ents_methods:getUp","29":"ents_methods:getVelocity","30":"ents_methods:isNPC","31":"ents_methods:isPlayer","32":"ents_methods:isValid","33":"ents_methods:isVehicle","34":"ents_methods:isWeapon","35":"ents_methods:localToWorld","36":"ents_methods:localToWorldAngles","37":"ents_methods:lookupAttachment","38":"ents_methods:obbCenter","39":"ents_methods:obbCenterW","40":"ents_methods:obbSize","41":"ents_methods:worldToLocal","42":"ents_methods:worldToLocalAngles","ents_methods:getColor":{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = eunwrap( self )","\treturn cwrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},"ents_methods:obbCenter":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},"ents_methods:getMaterials":{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = eunwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},"ents_methods:isNPC":{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},"ents_methods:getMassCenterW":{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]},"ents_methods:getAngles":{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},"ents_methods:getPos":{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},"ents_methods:obbSize":{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},"ents_methods:getSkin":{"ret":"Skin number","comment":["--- Gets the skin number of the entity","-- @shared","-- @return Skin number"],"code":["function ents_methods:getSkin ()","    local ent = eunwrap( self )","    return ent:GetSkin()","end",""],"class":"function","summary":"\nGets the skin number of the entity ","classlib":"Entity","name":"ents_methods:getSkin","server":true,"private":false,"client":true,"description":"\nGets the skin number of the entity","param":[]},"ents_methods:getMassCenter":{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},"ents_methods:worldToLocalAngles":{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},"ents_methods:getAttachmentParent":{"ret":"number index of the attachment the entity is parented to or 0","comment":["--- Gets the attachment index the entity is parented to","-- @shared","-- @return number index of the attachment the entity is parented to or 0"],"code":["function ents_methods:getAttachmentParent()","\tlocal ent = eunwrap(self)","\treturn ent and ent:GetParentAttachment() or 0","end",""],"class":"function","summary":"\nGets the attachment index the entity is parented to ","classlib":"Entity","name":"ents_methods:getAttachmentParent","server":true,"private":false,"client":true,"description":"\nGets the attachment index the entity is parented to","param":[]},"ents_methods:getHealth":{"ret":"Health of the entity","comment":["--- Gets the health of an entity","-- @shared","-- @return Health of the entity"],"code":["function ents_methods:getHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:Health()","end",""],"class":"function","summary":"\nGets the health of an entity ","classlib":"Entity","name":"ents_methods:getHealth","server":true,"private":false,"client":true,"description":"\nGets the health of an entity","param":[]},"ents_methods:entIndex":{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},"ents_methods:obbCenterW":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},"ents_methods:getForward":{"ret":"Vector forward","comment":["--- Gets the entity's forward vector","-- @shared","-- @return Vector forward"],"code":["function ents_methods:getForward ()","\treturn vwrap( eunwrap( self ):GetForward() )","end"],"class":"function","summary":"\nGets the entity's forward vector ","classlib":"Entity","name":"ents_methods:getForward","server":true,"private":false,"client":true,"description":"\nGets the entity's forward vector","param":[]},"SF.Entities.GetPhysObject":{"ret":"The physobj, or nil if the entity isn't valid or isn't vphysics","comment":["--- Gets the physics object of the entity","-- @return The physobj, or nil if the entity isn't valid or isn't vphysics"],"code":["function SF.Entities.GetPhysObject ( ent )","\treturn ( isValid( ent ) and ent:GetMoveType() == MOVETYPE_VPHYSICS and ent:GetPhysicsObject() ) or nil","end","local getPhysObject = SF.Entities.GetPhysObject","","-- ------------------------- Library functions ------------------------- --","","function SF.DefaultEnvironment.chip ()","\tlocal ent = SF.instance.data.entity","\tif ent then ","\t\treturn ewrap( ent )","\tend","end","","function SF.DefaultEnvironment.owner ()","\treturn SF.WrapObject( SF.instance.player )","end","","if SERVER then","\tSF.DefaultEnvironment.player = SF.DefaultEnvironment.owner","else","\tfunction SF.DefaultEnvironment.player ()","\t\treturn SF.WrapObject( LocalPlayer() )","\tend","\t","\tlocal renderProperties = {","\t\t[1] = function( ent ) --Color\t","\t\t\tent:SetColor( Color( net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ) ) )","\t\tend,","\t\t[2] = function( ent ) --Nodraw","\t\t\tent:SetNoDraw( net.ReadBit() == 1 )","\t\tend,","\t\t[3] = function( ent ) --Material","\t\t\tent:SetMaterial( net.ReadString() )","\t\tend,","\t\t[4] = function( ent ) --Submaterial","\t\t\tent:SetSubMaterial( net.ReadUInt( 16 ), net.ReadString() )","\t\tend,","\t\t[5] = function( ent ) --Bodygroup","\t\t\tent:SetBodyGroup( net.ReadUInt( 16 ), net.ReadUInt ( 16 ) )","\t\tend,","\t\t[6] = function( ent ) --Skin","\t\t\tent:SetSkin( net.ReadUInt( 16 ) )","\t\tend,","\t\t[7] = function( ent ) --Rendermode","\t\t\tent:SetRenderMode( net.ReadUInt( 8 ) )","\t\tend,","\t\t[8] = function( ent ) --Renderfx","\t\t\tent:SetRenderFX( net.ReadUInt( 8 ) )","\t\tend,","\t}","\t","\t--Net function that allows the server to set the render properties of entities for specific players","\tnet.Receive( \"sf_setentityrenderproperty\", function()","\t\tlocal ent = net.ReadEntity()","\t\tif not ent:IsValid() then return end","\t\tlocal property = net.ReadUInt( 4 )","\t\tif not renderProperties[ property ] then return end","\t\t","\t\trenderProperties[ property ]( ent )","\tend)","end","","function SF.DefaultEnvironment.entity ( num )","\tSF.CheckType( num, \"number\" )","\t","\treturn SF.WrapObject( Entity( num ) )","end","","-- ------------------------- Methods ------------------------- --",""],"class":"function","name":"SF.Entities.GetPhysObject","private":false,"summary":"\nGets the physics object of the entity ","description":"\nGets the physics object of the entity","param":["ent"]},"ents_methods:getMaxHealth":{"ret":"Max Health of the entity","comment":["--- Gets the max health of an entity","-- @shared","-- @return Max Health of the entity"],"code":["function ents_methods:getMaxHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetMaxHealth()","end",""],"class":"function","summary":"\nGets the max health of an entity ","classlib":"Entity","name":"ents_methods:getMaxHealth","server":true,"private":false,"client":true,"description":"\nGets the max health of an entity","param":[]},"ents_methods:getRight":{"ret":"Vector right","comment":["--- Gets the entity's right vector","-- @shared","-- @return Vector right"],"code":["function ents_methods:getRight ()","\treturn vwrap( eunwrap( self ):GetRight() )","end",""],"class":"function","summary":"\nGets the entity's right vector ","classlib":"Entity","name":"ents_methods:getRight","server":true,"private":false,"client":true,"description":"\nGets the entity's right vector","param":[]},"ents_methods:getInertia":{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn vwrap( phys:GetInertia() )","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},"ents_methods:getParent":{"ret":"Entity's parent or nil","comment":["--- Gets the parent of an entity","-- @shared","-- @return Entity's parent or nil"],"code":["function ents_methods:getParent()","\tlocal ent = eunwrap(self)","\treturn ent and ewrap(ent:GetParent())","end",""],"class":"function","summary":"\nGets the parent of an entity ","classlib":"Entity","name":"ents_methods:getParent","server":true,"private":false,"client":true,"description":"\nGets the parent of an entity","param":[]},"ents_methods:getUp":{"ret":"Vector up","comment":["--- Gets the entity's up vector","-- @shared","-- @return Vector up"],"code":["function ents_methods:getUp ()","\treturn vwrap( eunwrap( self ):GetUp() )","end",""],"class":"function","summary":"\nGets the entity's up vector ","classlib":"Entity","name":"ents_methods:getUp","server":true,"private":false,"client":true,"description":"\nGets the entity's up vector","param":[]},"ents_methods:getModel":{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},"ents_methods:getAngleVelocity":{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( eunwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn vwrap( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},"ents_methods:getMaterial":{"ret":"String material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getMaterial ()","    local ent = eunwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},"ents_methods:getEyePos":{"ret":["Eye position of the entity","In case of a ragdoll, the position of the second eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the second eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal pos1, pos2 = ent:EyePos()","\tif pos2 then","\t\treturn vwrap( pos1 ), vwrap( pos2 )","\tend","\treturn vwrap( pos1 )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},"ents_methods:isVehicle":{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},"ents_methods:getEyeAngles":{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},"ents_methods:getMatrix":{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = eunwrap( self )","\treturn owrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},"ents_methods:getVelocity":{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn vwrap( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},"ents_methods:lookupAttachment":{"ret":"number of the attachment index, or 0 if it doesn't exist","comment":["--- Gets the attachment index via the entity and it's attachment name","-- @shared","-- @param name","-- @return number of the attachment index, or 0 if it doesn't exist"],"code":["function ents_methods:lookupAttachment(name)","\tlocal ent = eunwrap(self)","\treturn ent and ent:LookupAttachment(name) or 0","end",""],"class":"function","summary":"\nGets the attachment index via the entity and it's attachment name ","classlib":"Entity","name":"ents_methods:lookupAttachment","server":true,"private":false,"client":true,"description":"\nGets the attachment index via the entity and it's attachment name","param":{"1":"name","name":""}},"ents_methods:localToWorldAngles":{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},"ents_methods:isWeapon":{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]},"ents_methods:isPlayer":{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},"ents_methods:worldToLocal":{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},"ents_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function ents_metamethods:__tostring ()","\tlocal ent = eunwrap( self )","\tif not ent then return \"(null entity)\"","\telse return tostring( ent ) end","end",""],"class":"function","summary":"\nTo string ","name":"ents_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"ents_methods:getClass":{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},"ents_methods:getAttachment":{"ret":"vector position, and angle orientation","comment":["--- Gets the position and angle of an attachment","-- @shared","-- @param index The index of the attachment","-- @return vector position, and angle orientation"],"code":["function ents_methods:getAttachment(index)","\tlocal ent = eunwrap(self)","\tif ent then","\t\tlocal t = ent:GetAttachment(index)","\t\tif t then","\t\t\treturn vwrap(t.Pos), awrap(t.Ang)","\t\tend","\tend","end",""],"class":"function","summary":"\nGets the position and angle of an attachment ","classlib":"Entity","name":"ents_methods:getAttachment","server":true,"private":false,"client":true,"description":"\nGets the position and angle of an attachment","param":{"1":"index","index":"The index of the attachment"}},"ents_methods:localToWorld":{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},"ents_methods:getSubMaterial":{"ret":"String material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = eunwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},"ents_methods:getMass":{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},"ents_methods:isValid":{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( eunwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Shared entity library functions","-------------------------------------------------------------------------------"],"code":["","SF.Entities = {}",""],"summary":"\n \nShared entity library functions \n ","description":"\n \nShared entity library functions \n","param":[]},{"comment":["--- Entity type","-- @shared"],"code":["local ents_methods, ents_metamethods = SF.Typedef( \"Entity\" )","","local ewrap, eunwrap = SF.CreateWrapper( ents_metamethods, true, true, debug.getregistry().Entity )","local owrap, ounwrap = SF.WrapObject, SF.UnwrapObject","local ang_meta, vec_meta","local vwrap, vunwrap, awrap, aunwrap, cwrap, cunwrap","local isValid = IsValid","","SF.Libraries.AddHook(\"postload\", function()","\tang_meta = SF.Angles.Metatable","\tvec_meta = SF.Vectors.Metatable","","\tvwrap = SF.Vectors.Wrap","\tvunwrap = SF.Vectors.Unwrap","\tawrap = SF.Angles.Wrap","\taunwrap = SF.Angles.Unwrap","\tcwrap = SF.Color.Wrap","\tcunwrap = SF.Color.Unwrap","end)","","-- ------------------------- Internal functions ------------------------- --","","SF.Entities.Wrap = ewrap","SF.Entities.Unwrap = eunwrap","SF.Entities.Methods = ents_methods","SF.Entities.Metatable = ents_metamethods","",""],"typtbl":"ents_methods","summary":"\nEntity type ","fields":[],"name":"Entity","server":true,"description":"\nEntity type","client":true,"class":"class","methods":{"1":"addCollisionListener","2":"applyAngForce","3":"applyDamage","4":"applyForceCenter","5":"applyForceOffset","6":"applyTorque","7":"breakEnt","8":"emitSound","9":"enableDrag","10":"enableGravity","11":"enableMotion","12":"enableSphere","13":"entIndex","14":"extinguish","15":"getAngleVelocity","16":"getAngles","17":"getAttachment","18":"getAttachmentParent","19":"getClass","20":"getColor","21":"getEyeAngles","22":"getEyePos","23":"getForward","24":"getHealth","25":"getInertia","26":"getMass","27":"getMassCenter","28":"getMassCenterW","29":"getMaterial","30":"getMaterials","31":"getMatrix","32":"getMaxHealth","33":"getModel","34":"getOwner","35":"getParent","36":"getPos","37":"getRight","38":"getSkin","39":"getSubMaterial","40":"getUp","41":"getVelocity","42":"ignite","43":"isFrozen","44":"isNPC","45":"isPlayer","46":"isValid","47":"isVehicle","48":"isWeapon","49":"isWeldedTo","50":"linkComponent","51":"localToWorld","52":"localToWorldAngles","53":"lookupAttachment","54":"obbCenter","55":"obbCenterW","56":"obbSize","57":"remove","58":"removeTrails","59":"setAngles","60":"setBodygroup","61":"setColor","62":"setFrozen","63":"setMass","64":"setMaterial","65":"setNoDraw","66":"setNocollideAll","67":"setParent","68":"setPhysMaterial","69":"setPos","70":"setRenderFX","71":"setRenderMode","72":"setSkin","73":"setSolid","74":"setSubMaterial","75":"setTrails","76":"setVelocity","77":"unparent","78":"worldToLocal","79":"worldToLocalAngles","getRight":{"ret":"Vector right","comment":["--- Gets the entity's right vector","-- @shared","-- @return Vector right"],"code":["function ents_methods:getRight ()","\treturn vwrap( eunwrap( self ):GetRight() )","end",""],"class":"function","summary":"\nGets the entity's right vector ","classlib":"Entity","name":"ents_methods:getRight","server":true,"private":false,"client":true,"description":"\nGets the entity's right vector","param":[]},"applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"setNocollideAll":{"comment":["--- Set's the entity to collide with nothing but the world","-- @param nocollide Whether to collide with nothing except world or not."],"code":["function ents_methods:setNocollideAll ( nocollide )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tent:SetCollisionGroup ( nocollide and COLLISION_GROUP_WORLD or COLLISION_GROUP_NONE )","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend,","\t[7] = function( mode ) --Rendermode","\t\tnet.WriteUInt( mode, 8 )","\tend,","\t[8] = function( fx ) --Renderfx","\t\tnet.WriteUInt( fx, 8 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tlocal meta = debug.getmetatable( ply )","\tif meta == SF.Types[ \"Player\" ] then ","\t\tply = unwrap( ply )","\t\tif not ( IsValid( ply ) and ply:IsPlayer() ) then","\t\t\tSF.throw( \"Tried to use invalid player\", 3 )","\t\tend","\telseif meta == nil and type( ply ) == \"table\" then","\t\tlocal ply2 = ply","\t\tply = {}","\t\tfor k, v in pairs( ply2 ) do","\t\t\tlocal p = unwrap( v )","\t\t\tif IsValid( p ) and p:IsPlayer() then","\t\t\t\tply[k] = p","\t\t\telse","\t\t\t\tSF.throw ( \"Invalid player object in table of players\", 3 )","\t\t\tend","\t\tend","\telse","\t\tSF.throw( \"Expected player or table of players.\", 3 )","\tend","\t","\tnet.Start( \"sf_setentityrenderproperty\" )","\tnet.WriteEntity( ent )","\tnet.WriteUInt( func, 4 )","\trenderProperties[ func ]( ... )","\tnet.Send( ply )","end",""],"class":"function","name":"ents_methods:setNocollideAll","summary":"\nSet's the entity to collide with nothing but the world ","private":false,"classlib":"Entity","description":"\nSet's the entity to collide with nothing but the world","param":{"1":"nocollide","nocollide":"Whether to collide with nothing except world or not."}},"setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"isValid":{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( eunwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]},"addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"getAngleVelocity":{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( eunwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn vwrap( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},"getSkin":{"ret":"Skin number","comment":["--- Gets the skin number of the entity","-- @shared","-- @return Skin number"],"code":["function ents_methods:getSkin ()","    local ent = eunwrap( self )","    return ent:GetSkin()","end",""],"class":"function","summary":"\nGets the skin number of the entity ","classlib":"Entity","name":"ents_methods:getSkin","server":true,"private":false,"client":true,"description":"\nGets the skin number of the entity","param":[]},"getAttachmentParent":{"ret":"number index of the attachment the entity is parented to or 0","comment":["--- Gets the attachment index the entity is parented to","-- @shared","-- @return number index of the attachment the entity is parented to or 0"],"code":["function ents_methods:getAttachmentParent()","\tlocal ent = eunwrap(self)","\treturn ent and ent:GetParentAttachment() or 0","end",""],"class":"function","summary":"\nGets the attachment index the entity is parented to ","classlib":"Entity","name":"ents_methods:getAttachmentParent","server":true,"private":false,"client":true,"description":"\nGets the attachment index the entity is parented to","param":[]},"getClass":{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},"obbCenter":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},"getModel":{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},"getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v[1] and v[1] < math.huge and","\t\t\t-math.huge < v[2] and v[2] < math.huge and","\t\t\t-math.huge < v[3] and v[3] < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"getEyePos":{"ret":["Eye position of the entity","In case of a ragdoll, the position of the second eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the second eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal pos1, pos2 = ent:EyePos()","\tif pos2 then","\t\treturn vwrap( pos1 ), vwrap( pos2 )","\tend","\treturn vwrap( pos1 )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},"getColor":{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = eunwrap( self )","\treturn cwrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},"entIndex":{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},"getInertia":{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn vwrap( phys:GetInertia() )","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},"isPlayer":{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},"linkComponent":{"comment":["--- Links starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","-- @param e Entity to link the component to. nil to clear links."],"code":["function ents_methods:linkComponent ( e )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif e then","\t\tSF.CheckType( e, ents_metatable )","\t\tlocal link = unwrap( e )","\t\tif not isValid( link ) then SF.throw( \"Entity is not valid\", 2 ) end","\t\tif not SF.Permissions.check( SF.instance.player, link, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\tif link:GetClass()==\"starfall_processor\" and ( ent:GetClass()==\"starfall_screen\" or ent:GetClass()==\"starfall_hud\" ) then","\t\t\tent:LinkEnt( link )","\t\telseif link:IsVehicle() and ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkVehicle( link )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\telse","\t\tif ent:GetClass()==\"starfall_screen\" then","\t\t\tent:LinkEnt( nil )","\t\telseif ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkEnt( nil )","\t\t\tent:LinkVehicle( nil )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\tend","end","",""],"class":"function","name":"ents_methods:linkComponent","summary":"\nLinks starfall components to a starfall processor or vehicle.","private":false,"classlib":"Entity","description":"\nLinks starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","param":{"1":"e","e":"Entity to link the component to. nil to clear links."}},"obbSize":{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},"setRenderFX":{"comment":["--- Sets the renderfx of the entity","-- @server","-- @class function","-- @param renderfx Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderFX ( renderfx, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( renderfx, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 8, renderfx )","\telse","\t\tent:SetRenderFX( renderfx )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderFX = renderfx } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the renderfx of the entity ","name":"ents_methods:setRenderFX","classlib":"Entity","private":false,"server":true,"description":"\nSets the renderfx of the entity","param":{"1":"renderfx","2":"ply","renderfx":"Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"worldToLocal":{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},"localToWorld":{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},"getAttachment":{"ret":"vector position, and angle orientation","comment":["--- Gets the position and angle of an attachment","-- @shared","-- @param index The index of the attachment","-- @return vector position, and angle orientation"],"code":["function ents_methods:getAttachment(index)","\tlocal ent = eunwrap(self)","\tif ent then","\t\tlocal t = ent:GetAttachment(index)","\t\tif t then","\t\t\treturn vwrap(t.Pos), awrap(t.Ang)","\t\tend","\tend","end",""],"class":"function","summary":"\nGets the position and angle of an attachment ","classlib":"Entity","name":"ents_methods:getAttachment","server":true,"private":false,"client":true,"description":"\nGets the position and angle of an attachment","param":{"1":"index","index":"The index of the attachment"}},"applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"lookupAttachment":{"ret":"number of the attachment index, or 0 if it doesn't exist","comment":["--- Gets the attachment index via the entity and it's attachment name","-- @shared","-- @param name","-- @return number of the attachment index, or 0 if it doesn't exist"],"code":["function ents_methods:lookupAttachment(name)","\tlocal ent = eunwrap(self)","\treturn ent and ent:LookupAttachment(name) or 0","end",""],"class":"function","summary":"\nGets the attachment index via the entity and it's attachment name ","classlib":"Entity","name":"ents_methods:lookupAttachment","server":true,"private":false,"client":true,"description":"\nGets the attachment index via the entity and it's attachment name","param":{"1":"name","name":""}},"setTrails":{"comment":["--- Adds a trail to the entity with the specified attributes.","-- @param startSize The start size of the trail","-- @param endSize The end size of the trail","-- @param length The length size of the trail","-- @param material The material of the trail","-- @param color The color of the trail","-- @param attachmentID Optional attachmentid the trail should attach to","-- @param additive If the trail's rendering is additive"],"code":["function ents_methods:setTrails(startSize, endSize, length, material, color, attachmentID, additive)","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( material, \"string\" )","\t","\tlocal ent = unwrap( self )","","\tif string.find(material, '\"', 1, true) then SF.throw( \"Invalid Material\", 2 ) end","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal Data = {","\t\tColor = SF.Color.Unwrap( color ),","\t\tLength = length,","\t\tStartSize = math.Clamp( startSize, 0, 128 ),","\t\tEndSize = math.Clamp( endSize, 0, 128 ),","\t\tMaterial = material,","\t\tAttachmentID = attachmentID,","\t\tAdditive = additive,","\t}","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, Data)","end",""],"class":"function","name":"ents_methods:setTrails","summary":"\nAdds a trail to the entity with the specified attributes.","private":false,"classlib":"Entity","description":"\nAdds a trail to the entity with the specified attributes.","param":{"1":"startSize","2":"endSize","3":"length","4":"material","5":"color","6":"attachmentID","7":"additive","startSize":"The start size of the trail","length":"The length size of the trail","attachmentID":"Optional attachmentid the trail should attach to","color":"The color of the trail","material":"The material of the trail","endSize":"The end size of the trail","additive":"If the trail's rendering is additive"}},"getMatrix":{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = eunwrap( self )","\treturn owrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},"setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","\t","\tif not check( vel ) then SF.throw( \"infinite vector\", 2) end","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local shaderBlacklist = {","\t[ \"LightmappedGeneric\" ] = true,","}","local function invalidMaterial( material )","\tif string.find( string.lower( material ) , \"pp[%./\\\\]+copy\" ) then return true end","\tlocal mat = Material( material )","\tif mat and shaderBlacklist[ mat:GetShader() ] then return true end","end",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"isWeapon":{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]},"breakEnt":{"comment":["--- Invokes the entity's breaking animation and removes it."],"code":["function ents_methods:breakEnt ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() or ent:IsFlagSet( FL_KILLME ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:AddFlags( FL_KILLME )","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:breakEnt","summary":"\nInvokes the entity's breaking animation and removes it.","private":false,"classlib":"Entity","description":"\nInvokes the entity's breaking animation and removes it.","param":[]},"getEyeAngles":{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},"ignite":{"comment":["--- Ignites an entity","-- @param length How long the fire lasts","-- @param radius (optional) How large the fire hitbox is (entity obb is the max)"],"code":["function ents_methods:ignite( length, radius )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( length, \"number\" )","","\tlocal ent = unwrap( self )","","\tif radius then","\t\tSF.CheckType( radius, \"number\" )","\t\tlocal obbmins, obbmaxs = ent:OBBMins(), ent:OBBMaxs()","\t\tradius = math.Clamp( radius, 0, (obbmaxs.x - obbmins.x + obbmaxs.y - obbmins.y) / 2 )","\tend","","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Ignite( length, radius )","end",""],"class":"function","name":"ents_methods:ignite","summary":"\nIgnites an entity ","private":false,"classlib":"Entity","description":"\nIgnites an entity","param":{"1":"length","2":"radius","radius":"(optional) How large the fire hitbox is (entity obb is the max)","length":"How long the fire lasts"}},"getMaterials":{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = eunwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},"isVehicle":{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},"setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"worldToLocalAngles":{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},"getVelocity":{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn vwrap( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},"setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tlocal rendermode = ( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { Color = clr, RenderMode = rendermode } )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"isNPC":{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},"applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},"getForward":{"ret":"Vector forward","comment":["--- Gets the entity's forward vector","-- @shared","-- @return Vector forward"],"code":["function ents_methods:getForward ()","\treturn vwrap( eunwrap( self ):GetForward() )","end"],"class":"function","summary":"\nGets the entity's forward vector ","classlib":"Entity","name":"ents_methods:getForward","server":true,"private":false,"client":true,"description":"\nGets the entity's forward vector","param":[]},"getUp":{"ret":"Vector up","comment":["--- Gets the entity's up vector","-- @shared","-- @return Vector up"],"code":["function ents_methods:getUp ()","\treturn vwrap( eunwrap( self ):GetUp() )","end",""],"class":"function","summary":"\nGets the entity's up vector ","classlib":"Entity","name":"ents_methods:getUp","server":true,"private":false,"client":true,"description":"\nGets the entity's up vector","param":[]},"isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end","",""],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\t\tduplicator.StoreEntityModifier( ent, \"material\", { MaterialOverride = material } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","material":", string, New material name."}},"getMass":{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},"getMaxHealth":{"ret":"Max Health of the entity","comment":["--- Gets the max health of an entity","-- @shared","-- @return Max Health of the entity"],"code":["function ents_methods:getMaxHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetMaxHealth()","end",""],"class":"function","summary":"\nGets the max health of an entity ","classlib":"Entity","name":"ents_methods:getMaxHealth","server":true,"private":false,"client":true,"description":"\nGets the max health of an entity","param":[]},"extinguish":{"comment":["--- Extinguishes an entity"],"code":["function ents_methods:extinguish()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Extinguish()","end",""],"class":"function","name":"ents_methods:extinguish","summary":"\nExtinguishes an entity ","private":false,"classlib":"Entity","description":"\nExtinguishes an entity","param":[]},"setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set only for that player. Can also be table of players.","bodygroup":"Number, The ID of the bodygroup you're setting."}},"enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"getAngles":{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},"enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"enableSphere":{"comment":["--- Sets the physics of an entity to be a sphere","-- @param enabled Bool should the entity be spherical?"],"code":["function ents_methods:enableSphere ( enabled )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\t","\tif ent:GetClass() ~= \"prop_physics\" then SF.throw( \"This function only works for prop_physics\", 2 ) end","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal ismove = phys:IsMoveable()","\tlocal mass = phys:GetMass()","\t","\tif enabled then","\t\tif ent:GetMoveType() == MOVETYPE_VPHYSICS then","\t\t\tlocal OBB = ent:OBBMaxs() - ent:OBBMins()","\t\t\tlocal radius = math.max( OBB.x, OBB.y, OBB.z) / 2 ","\t\t\tent:PhysicsInitSphere( radius, phys:GetMaterial() )","\t\t\tent:SetCollisionBounds( Vector( -radius, -radius, -radius ) , Vector( radius, radius, radius ) )","\t\tend","\telse","\t\tif ent:GetMoveType() ~= MOVETYPE_VPHYSICS then","\t\t\tent:PhysicsInit( SOLID_VPHYSICS )","\t\t\tent:SetMoveType( MOVETYPE_VPHYSICS )","\t\t\tent:SetSolid( SOLID_VPHYSICS )","\t\tend","\tend","\t","\t-- New physobject after applying spherical collisions","\tlocal phys = ent:GetPhysicsObject()","\tphys:SetMass( mass )","\tphys:EnableMotion( ismove )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableSphere","summary":"\nSets the physics of an entity to be a sphere ","private":false,"classlib":"Entity","description":"\nSets the physics of an entity to be a sphere","param":{"1":"enabled","enabled":"Bool should the entity be spherical?"}},"localToWorldAngles":{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},"setPhysMaterial":{"comment":["--- Sets the physical material of the entity","-- @param mat Material to use"],"code":["function ents_methods:setPhysMaterial( mat )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( mat, \"string\" )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tconstruct.SetPhysProp( nil, ent, 0, phys, {Material = mat} ) ","end",""],"class":"function","name":"ents_methods:setPhysMaterial","summary":"\nSets the physical material of the entity ","private":false,"classlib":"Entity","description":"\nSets the physical material of the entity","param":{"1":"mat","mat":"Material to use"}},"getMaterial":{"ret":"String material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getMaterial ()","    local ent = eunwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},"getSubMaterial":{"ret":"String material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = eunwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},"emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"getParent":{"ret":"Entity's parent or nil","comment":["--- Gets the parent of an entity","-- @shared","-- @return Entity's parent or nil"],"code":["function ents_methods:getParent()","\tlocal ent = eunwrap(self)","\treturn ent and ewrap(ent:GetParent())","end",""],"class":"function","summary":"\nGets the parent of an entity ","classlib":"Entity","name":"ents_methods:getParent","server":true,"private":false,"client":true,"description":"\nGets the parent of an entity","param":[]},"removeTrails":{"comment":["--- Removes trails from the entity"],"code":["function ents_methods:removeTrails()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, nil)","end",""],"class":"function","name":"ents_methods:removeTrails","summary":"\nRemoves trails from the entity ","private":false,"classlib":"Entity","description":"\nRemoves trails from the entity","param":[]},"getMassCenter":{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},"applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\t","\tlocal ang = SF.UnwrapObject( ang )","\tlocal ent = unwrap( self )","\t","\tif not check( ang ) then SF.throw( \"infinite angle\", 2) end","\t","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to","-- @param attachment Optional string attachment name to parent to"],"code":["function ents_methods:setParent ( ent, attachment )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ent, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) and not ent:IsPlayer() then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","\tif attachment then","\t\tSF.CheckType(attachment, \"string\")","\t\tthis:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\tend","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","2":"attachment","ent":"Entity to parent to","attachment":"Optional string attachment name to parent to"}},"obbCenterW":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},"setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"getHealth":{"ret":"Health of the entity","comment":["--- Gets the health of an entity","-- @shared","-- @return Health of the entity"],"code":["function ents_methods:getHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:Health()","end",""],"class":"function","summary":"\nGets the health of an entity ","classlib":"Entity","name":"ents_methods:getHealth","server":true,"private":false,"client":true,"description":"\nGets the health of an entity","param":[]},"getPos":{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},"setRenderMode":{"comment":["--- Sets the rende mode of the entity","-- @server","-- @class function","-- @param rendermode Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderMode ( rendermode, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( rendermode, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 7, rendermode )","\telse","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderMode = rendermode } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the rende mode of the entity ","name":"ents_methods:setRenderMode","classlib":"Entity","private":false,"server":true,"description":"\nSets the rende mode of the entity","param":{"1":"rendermode","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","rendermode":"Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE"}},"getMassCenterW":{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]}}},{"ret":"The physobj, or nil if the entity isn't valid or isn't vphysics","comment":["--- Gets the physics object of the entity","-- @return The physobj, or nil if the entity isn't valid or isn't vphysics"],"code":["function SF.Entities.GetPhysObject ( ent )","\treturn ( isValid( ent ) and ent:GetMoveType() == MOVETYPE_VPHYSICS and ent:GetPhysicsObject() ) or nil","end","local getPhysObject = SF.Entities.GetPhysObject","","-- ------------------------- Library functions ------------------------- --","","function SF.DefaultEnvironment.chip ()","\tlocal ent = SF.instance.data.entity","\tif ent then ","\t\treturn ewrap( ent )","\tend","end","","function SF.DefaultEnvironment.owner ()","\treturn SF.WrapObject( SF.instance.player )","end","","if SERVER then","\tSF.DefaultEnvironment.player = SF.DefaultEnvironment.owner","else","\tfunction SF.DefaultEnvironment.player ()","\t\treturn SF.WrapObject( LocalPlayer() )","\tend","\t","\tlocal renderProperties = {","\t\t[1] = function( ent ) --Color\t","\t\t\tent:SetColor( Color( net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ) ) )","\t\tend,","\t\t[2] = function( ent ) --Nodraw","\t\t\tent:SetNoDraw( net.ReadBit() == 1 )","\t\tend,","\t\t[3] = function( ent ) --Material","\t\t\tent:SetMaterial( net.ReadString() )","\t\tend,","\t\t[4] = function( ent ) --Submaterial","\t\t\tent:SetSubMaterial( net.ReadUInt( 16 ), net.ReadString() )","\t\tend,","\t\t[5] = function( ent ) --Bodygroup","\t\t\tent:SetBodyGroup( net.ReadUInt( 16 ), net.ReadUInt ( 16 ) )","\t\tend,","\t\t[6] = function( ent ) --Skin","\t\t\tent:SetSkin( net.ReadUInt( 16 ) )","\t\tend,","\t\t[7] = function( ent ) --Rendermode","\t\t\tent:SetRenderMode( net.ReadUInt( 8 ) )","\t\tend,","\t\t[8] = function( ent ) --Renderfx","\t\t\tent:SetRenderFX( net.ReadUInt( 8 ) )","\t\tend,","\t}","\t","\t--Net function that allows the server to set the render properties of entities for specific players","\tnet.Receive( \"sf_setentityrenderproperty\", function()","\t\tlocal ent = net.ReadEntity()","\t\tif not ent:IsValid() then return end","\t\tlocal property = net.ReadUInt( 4 )","\t\tif not renderProperties[ property ] then return end","\t\t","\t\trenderProperties[ property ]( ent )","\tend)","end","","function SF.DefaultEnvironment.entity ( num )","\tSF.CheckType( num, \"number\" )","\t","\treturn SF.WrapObject( Entity( num ) )","end","","-- ------------------------- Methods ------------------------- --",""],"class":"function","name":"SF.Entities.GetPhysObject","private":false,"summary":"\nGets the physics object of the entity ","description":"\nGets the physics object of the entity","param":["ent"]},{"comment":["--- To string","-- @shared"],"code":["function ents_metamethods:__tostring ()","\tlocal ent = eunwrap( self )","\tif not ent then return \"(null entity)\"","\telse return tostring( ent ) end","end",""],"class":"function","summary":"\nTo string ","name":"ents_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"Entity's parent or nil","comment":["--- Gets the parent of an entity","-- @shared","-- @return Entity's parent or nil"],"code":["function ents_methods:getParent()","\tlocal ent = eunwrap(self)","\treturn ent and ewrap(ent:GetParent())","end",""],"class":"function","summary":"\nGets the parent of an entity ","classlib":"Entity","name":"ents_methods:getParent","server":true,"private":false,"client":true,"description":"\nGets the parent of an entity","param":[]},{"ret":"number index of the attachment the entity is parented to or 0","comment":["--- Gets the attachment index the entity is parented to","-- @shared","-- @return number index of the attachment the entity is parented to or 0"],"code":["function ents_methods:getAttachmentParent()","\tlocal ent = eunwrap(self)","\treturn ent and ent:GetParentAttachment() or 0","end",""],"class":"function","summary":"\nGets the attachment index the entity is parented to ","classlib":"Entity","name":"ents_methods:getAttachmentParent","server":true,"private":false,"client":true,"description":"\nGets the attachment index the entity is parented to","param":[]},{"ret":"number of the attachment index, or 0 if it doesn't exist","comment":["--- Gets the attachment index via the entity and it's attachment name","-- @shared","-- @param name","-- @return number of the attachment index, or 0 if it doesn't exist"],"code":["function ents_methods:lookupAttachment(name)","\tlocal ent = eunwrap(self)","\treturn ent and ent:LookupAttachment(name) or 0","end",""],"class":"function","summary":"\nGets the attachment index via the entity and it's attachment name ","classlib":"Entity","name":"ents_methods:lookupAttachment","server":true,"private":false,"client":true,"description":"\nGets the attachment index via the entity and it's attachment name","param":{"1":"name","name":""}},{"ret":"vector position, and angle orientation","comment":["--- Gets the position and angle of an attachment","-- @shared","-- @param index The index of the attachment","-- @return vector position, and angle orientation"],"code":["function ents_methods:getAttachment(index)","\tlocal ent = eunwrap(self)","\tif ent then","\t\tlocal t = ent:GetAttachment(index)","\t\tif t then","\t\t\treturn vwrap(t.Pos), awrap(t.Ang)","\t\tend","\tend","end",""],"class":"function","summary":"\nGets the position and angle of an attachment ","classlib":"Entity","name":"ents_methods:getAttachment","server":true,"private":false,"client":true,"description":"\nGets the position and angle of an attachment","param":{"1":"index","index":"The index of the attachment"}},{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = eunwrap( self )","\treturn cwrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( eunwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]},{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]},{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = eunwrap( self )","\treturn owrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]},{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn vwrap( phys:GetInertia() )","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn vwrap( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( eunwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn vwrap( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},{"ret":"Max Health of the entity","comment":["--- Gets the max health of an entity","-- @shared","-- @return Max Health of the entity"],"code":["function ents_methods:getMaxHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetMaxHealth()","end",""],"class":"function","summary":"\nGets the max health of an entity ","classlib":"Entity","name":"ents_methods:getMaxHealth","server":true,"private":false,"client":true,"description":"\nGets the max health of an entity","param":[]},{"ret":"Health of the entity","comment":["--- Gets the health of an entity","-- @shared","-- @return Health of the entity"],"code":["function ents_methods:getHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:Health()","end",""],"class":"function","summary":"\nGets the health of an entity ","classlib":"Entity","name":"ents_methods:getHealth","server":true,"private":false,"client":true,"description":"\nGets the health of an entity","param":[]},{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},{"ret":["Eye position of the entity","In case of a ragdoll, the position of the second eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the second eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal pos1, pos2 = ent:EyePos()","\tif pos2 then","\t\treturn vwrap( pos1 ), vwrap( pos2 )","\tend","\treturn vwrap( pos1 )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},{"ret":"String material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getMaterial ()","    local ent = eunwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},{"ret":"String material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = eunwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = eunwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},{"ret":"Skin number","comment":["--- Gets the skin number of the entity","-- @shared","-- @return Skin number"],"code":["function ents_methods:getSkin ()","    local ent = eunwrap( self )","    return ent:GetSkin()","end",""],"class":"function","summary":"\nGets the skin number of the entity ","classlib":"Entity","name":"ents_methods:getSkin","server":true,"private":false,"client":true,"description":"\nGets the skin number of the entity","param":[]},{"ret":"Vector up","comment":["--- Gets the entity's up vector","-- @shared","-- @return Vector up"],"code":["function ents_methods:getUp ()","\treturn vwrap( eunwrap( self ):GetUp() )","end",""],"class":"function","summary":"\nGets the entity's up vector ","classlib":"Entity","name":"ents_methods:getUp","server":true,"private":false,"client":true,"description":"\nGets the entity's up vector","param":[]},{"ret":"Vector right","comment":["--- Gets the entity's right vector","-- @shared","-- @return Vector right"],"code":["function ents_methods:getRight ()","\treturn vwrap( eunwrap( self ):GetRight() )","end",""],"class":"function","summary":"\nGets the entity's right vector ","classlib":"Entity","name":"ents_methods:getRight","server":true,"private":false,"client":true,"description":"\nGets the entity's right vector","param":[]},{"ret":"Vector forward","comment":["--- Gets the entity's forward vector","-- @shared","-- @return Vector forward"],"code":["function ents_methods:getForward ()","\treturn vwrap( eunwrap( self ):GetForward() )","end"],"class":"function","summary":"\nGets the entity's forward vector ","classlib":"Entity","name":"ents_methods:getForward","server":true,"private":false,"client":true,"description":"\nGets the entity's forward vector","param":[]}],"tables":[],"description":"\n \nShared entity library functions \n","summary":"\n \nShared entity library functions \n "},"libs_sh/team.lua":{"libraries":{"1":"team","team":{"comment":["--- Library for retreiving information about teams","-- @shared"],"functions":{"1":"bestAutoJoinTeam","2":"exists","3":"getAllTeams","4":"getColor","5":"getJoinable","6":"getName","7":"getNumDeaths","8":"getNumFrags","9":"getNumPlayers","10":"getPlayers","11":"getScore","bestAutoJoinTeam":{"ret":"index of the best team to join","description":"\nReturns team with least players","code":["team_library.bestAutoJoinTeam = team.BestAutoJoinTeam",""],"class":"function","classForced":true,"name":"team_library.bestAutoJoinTeam","summary":"\nReturns team with least players ","library":"team","comment":["--- Returns team with least players","-- @name team_library.bestAutoJoinTeam","-- @class function","-- @return index of the best team to join"],"param":[]},"getScore":{"ret":"Number score of the team","description":"\nReturns the score of a team","code":["team_library.getScore =  team.GetScore",""],"class":"function","classForced":true,"name":"team_library.getScore","summary":"\nReturns the score of a team ","library":"team","comment":["--- Returns the score of a team","-- @name team_library.getScore","-- @class function","-- @param ind Index of the team","-- @return Number score of the team"],"param":{"1":"ind","ind":"Index of the team"}},"getNumDeaths":{"ret":"number of deaths","description":"\nReturns number of deaths of all players on a team","code":["team_library.getNumDeaths = team.TotalDeaths",""],"class":"function","classForced":true,"name":"team_library.getNumDeaths","summary":"\nReturns number of deaths of all players on a team ","library":"team","comment":["--- Returns number of deaths of all players on a team","-- @name team_library.getNumDeaths","-- @class function","-- @param ind Index of the team","-- @return number of deaths"],"param":{"1":"ind","ind":"Index of the team"}},"getAllTeams":{"ret":"table containing team information","comment":["--- Returns a table containing team information","-- @return table containing team information"],"code":["function team_library.getAllTeams()","\treturn SF.Sanitize(team.GetAllTeams())","end",""],"class":"function","name":"team_library.getAllTeams","summary":"\nReturns a table containing team information ","private":false,"library":"team","description":"\nReturns a table containing team information","param":[]},"getJoinable":{"ret":"boolean","description":"\nReturns whether or not a team can be joined","code":["team_library.getJoinable = team.Joinable",""],"class":"function","classForced":true,"name":"team_library.getJoinable","summary":"\nReturns whether or not a team can be joined ","library":"team","comment":["--- Returns whether or not a team can be joined","-- @name team_library.getJoinable","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"exists":{"ret":"boolean","description":"\nReturns whether or not the team exists","code":["team_library.exists = team.Valid",""],"class":"function","classForced":true,"name":"team_library.exists","summary":"\nReturns whether or not the team exists ","library":"team","comment":["--- Returns whether or not the team exists","-- @name team_library.exists","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"getColor":{"ret":"Color of the team","comment":["--- Returns the color of a team","-- @param ind Index of the team","-- @return Color of the team"],"code":["function team_library.getColor(ind)","\treturn cwrap(team.GetColor(ind)) ","end",""],"class":"function","name":"team_library.getColor","summary":"\nReturns the color of a team ","private":false,"library":"team","description":"\nReturns the color of a team","param":{"1":"ind","ind":"Index of the team"}},"getNumFrags":{"ret":"number of frags","description":"\nReturns number of frags of all players on a team","code":["team_library.getNumFrags = team.TotalFrags",""],"class":"function","classForced":true,"name":"team_library.getNumFrags","summary":"\nReturns number of frags of all players on a team ","library":"team","comment":["--- Returns number of frags of all players on a team","-- @name team_library.getNumFrags","-- @class function","-- @param ind Index of the team","-- @return number of frags"],"param":{"1":"ind","ind":"Index of the team"}},"getNumPlayers":{"ret":"number of players","description":"\nReturns number of players on a team","code":["team_library.getNumPlayers = team.NumPlayers",""],"class":"function","classForced":true,"name":"team_library.getNumPlayers","summary":"\nReturns number of players on a team ","library":"team","comment":["--- Returns number of players on a team","-- @name team_library.getNumPlayers","-- @class function","-- @param ind Index of the team","-- @return number of players"],"param":{"1":"ind","ind":"Index of the team"}},"getPlayers":{"ret":"Table of players","comment":["--- Returns the table of players on a team","-- @param ind Index of the team","-- @return Table of players"],"code":["function team_library.getPlayers(ind)","\treturn SF.Sanitize(team.GetPlayers(ind))","end",""],"class":"function","name":"team_library.getPlayers","summary":"\nReturns the table of players on a team ","private":false,"library":"team","description":"\nReturns the table of players on a team","param":{"1":"ind","ind":"Index of the team"}},"getName":{"ret":"String name of the team","description":"\nReturns the name of a team","code":["team_library.getName = team.GetName",""],"class":"function","classForced":true,"name":"team_library.getName","summary":"\nReturns the name of a team ","library":"team","comment":["--- Returns the name of a team","-- @name team_library.getName","-- @class function","-- @param ind Index of the team","-- @return String name of the team"],"param":{"1":"ind","ind":"Index of the team"}}},"class":"library","summary":"\nLibrary for retreiving information about teams ","code":["local team_library, team_library_metamethods = SF.Libraries.Register(\"team\")","local cwrap, cunwrap","SF.Libraries.AddHook(\"postload\", function()","\tcwrap = SF.Color.Wrap","\tcunwrap = SF.Color.Unwrap","end)",""],"fields":[],"name":"team","client":true,"description":"\nLibrary for retreiving information about teams","libtbl":"team_library","tables":[],"server":true}},"type":"file","name":"libs_sh/team.lua","functions":{"1":"team_library.bestAutoJoinTeam","2":"team_library.exists","3":"team_library.getAllTeams","4":"team_library.getColor","5":"team_library.getJoinable","6":"team_library.getName","7":"team_library.getNumDeaths","8":"team_library.getNumFrags","9":"team_library.getNumPlayers","10":"team_library.getPlayers","11":"team_library.getScore","team_library.getNumPlayers":{"ret":"number of players","description":"\nReturns number of players on a team","code":["team_library.getNumPlayers = team.NumPlayers",""],"class":"function","classForced":true,"name":"team_library.getNumPlayers","summary":"\nReturns number of players on a team ","library":"team","comment":["--- Returns number of players on a team","-- @name team_library.getNumPlayers","-- @class function","-- @param ind Index of the team","-- @return number of players"],"param":{"1":"ind","ind":"Index of the team"}},"team_library.getPlayers":{"ret":"Table of players","comment":["--- Returns the table of players on a team","-- @param ind Index of the team","-- @return Table of players"],"code":["function team_library.getPlayers(ind)","\treturn SF.Sanitize(team.GetPlayers(ind))","end",""],"class":"function","name":"team_library.getPlayers","summary":"\nReturns the table of players on a team ","private":false,"library":"team","description":"\nReturns the table of players on a team","param":{"1":"ind","ind":"Index of the team"}},"team_library.getName":{"ret":"String name of the team","description":"\nReturns the name of a team","code":["team_library.getName = team.GetName",""],"class":"function","classForced":true,"name":"team_library.getName","summary":"\nReturns the name of a team ","library":"team","comment":["--- Returns the name of a team","-- @name team_library.getName","-- @class function","-- @param ind Index of the team","-- @return String name of the team"],"param":{"1":"ind","ind":"Index of the team"}},"team_library.bestAutoJoinTeam":{"ret":"index of the best team to join","description":"\nReturns team with least players","code":["team_library.bestAutoJoinTeam = team.BestAutoJoinTeam",""],"class":"function","classForced":true,"name":"team_library.bestAutoJoinTeam","summary":"\nReturns team with least players ","library":"team","comment":["--- Returns team with least players","-- @name team_library.bestAutoJoinTeam","-- @class function","-- @return index of the best team to join"],"param":[]},"team_library.getNumDeaths":{"ret":"number of deaths","description":"\nReturns number of deaths of all players on a team","code":["team_library.getNumDeaths = team.TotalDeaths",""],"class":"function","classForced":true,"name":"team_library.getNumDeaths","summary":"\nReturns number of deaths of all players on a team ","library":"team","comment":["--- Returns number of deaths of all players on a team","-- @name team_library.getNumDeaths","-- @class function","-- @param ind Index of the team","-- @return number of deaths"],"param":{"1":"ind","ind":"Index of the team"}},"team_library.getNumFrags":{"ret":"number of frags","description":"\nReturns number of frags of all players on a team","code":["team_library.getNumFrags = team.TotalFrags",""],"class":"function","classForced":true,"name":"team_library.getNumFrags","summary":"\nReturns number of frags of all players on a team ","library":"team","comment":["--- Returns number of frags of all players on a team","-- @name team_library.getNumFrags","-- @class function","-- @param ind Index of the team","-- @return number of frags"],"param":{"1":"ind","ind":"Index of the team"}},"team_library.getColor":{"ret":"Color of the team","comment":["--- Returns the color of a team","-- @param ind Index of the team","-- @return Color of the team"],"code":["function team_library.getColor(ind)","\treturn cwrap(team.GetColor(ind)) ","end",""],"class":"function","name":"team_library.getColor","summary":"\nReturns the color of a team ","private":false,"library":"team","description":"\nReturns the color of a team","param":{"1":"ind","ind":"Index of the team"}},"team_library.getAllTeams":{"ret":"table containing team information","comment":["--- Returns a table containing team information","-- @return table containing team information"],"code":["function team_library.getAllTeams()","\treturn SF.Sanitize(team.GetAllTeams())","end",""],"class":"function","name":"team_library.getAllTeams","summary":"\nReturns a table containing team information ","private":false,"library":"team","description":"\nReturns a table containing team information","param":[]},"team_library.getJoinable":{"ret":"boolean","description":"\nReturns whether or not a team can be joined","code":["team_library.getJoinable = team.Joinable",""],"class":"function","classForced":true,"name":"team_library.getJoinable","summary":"\nReturns whether or not a team can be joined ","library":"team","comment":["--- Returns whether or not a team can be joined","-- @name team_library.getJoinable","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"team_library.exists":{"ret":"boolean","description":"\nReturns whether or not the team exists","code":["team_library.exists = team.Valid",""],"class":"function","classForced":true,"name":"team_library.exists","summary":"\nReturns whether or not the team exists ","library":"team","comment":["--- Returns whether or not the team exists","-- @name team_library.exists","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"team_library.getScore":{"ret":"Number score of the team","description":"\nReturns the score of a team","code":["team_library.getScore =  team.GetScore",""],"class":"function","classForced":true,"name":"team_library.getScore","summary":"\nReturns the score of a team ","library":"team","comment":["--- Returns the score of a team","-- @name team_library.getScore","-- @class function","-- @param ind Index of the team","-- @return Number score of the team"],"param":{"1":"ind","ind":"Index of the team"}}},"doc":[{"comment":["--- Library for retreiving information about teams","-- @shared"],"functions":{"1":"bestAutoJoinTeam","2":"exists","3":"getAllTeams","4":"getColor","5":"getJoinable","6":"getName","7":"getNumDeaths","8":"getNumFrags","9":"getNumPlayers","10":"getPlayers","11":"getScore","bestAutoJoinTeam":{"ret":"index of the best team to join","description":"\nReturns team with least players","code":["team_library.bestAutoJoinTeam = team.BestAutoJoinTeam",""],"class":"function","classForced":true,"name":"team_library.bestAutoJoinTeam","summary":"\nReturns team with least players ","library":"team","comment":["--- Returns team with least players","-- @name team_library.bestAutoJoinTeam","-- @class function","-- @return index of the best team to join"],"param":[]},"getScore":{"ret":"Number score of the team","description":"\nReturns the score of a team","code":["team_library.getScore =  team.GetScore",""],"class":"function","classForced":true,"name":"team_library.getScore","summary":"\nReturns the score of a team ","library":"team","comment":["--- Returns the score of a team","-- @name team_library.getScore","-- @class function","-- @param ind Index of the team","-- @return Number score of the team"],"param":{"1":"ind","ind":"Index of the team"}},"getNumDeaths":{"ret":"number of deaths","description":"\nReturns number of deaths of all players on a team","code":["team_library.getNumDeaths = team.TotalDeaths",""],"class":"function","classForced":true,"name":"team_library.getNumDeaths","summary":"\nReturns number of deaths of all players on a team ","library":"team","comment":["--- Returns number of deaths of all players on a team","-- @name team_library.getNumDeaths","-- @class function","-- @param ind Index of the team","-- @return number of deaths"],"param":{"1":"ind","ind":"Index of the team"}},"getAllTeams":{"ret":"table containing team information","comment":["--- Returns a table containing team information","-- @return table containing team information"],"code":["function team_library.getAllTeams()","\treturn SF.Sanitize(team.GetAllTeams())","end",""],"class":"function","name":"team_library.getAllTeams","summary":"\nReturns a table containing team information ","private":false,"library":"team","description":"\nReturns a table containing team information","param":[]},"getJoinable":{"ret":"boolean","description":"\nReturns whether or not a team can be joined","code":["team_library.getJoinable = team.Joinable",""],"class":"function","classForced":true,"name":"team_library.getJoinable","summary":"\nReturns whether or not a team can be joined ","library":"team","comment":["--- Returns whether or not a team can be joined","-- @name team_library.getJoinable","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"exists":{"ret":"boolean","description":"\nReturns whether or not the team exists","code":["team_library.exists = team.Valid",""],"class":"function","classForced":true,"name":"team_library.exists","summary":"\nReturns whether or not the team exists ","library":"team","comment":["--- Returns whether or not the team exists","-- @name team_library.exists","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},"getColor":{"ret":"Color of the team","comment":["--- Returns the color of a team","-- @param ind Index of the team","-- @return Color of the team"],"code":["function team_library.getColor(ind)","\treturn cwrap(team.GetColor(ind)) ","end",""],"class":"function","name":"team_library.getColor","summary":"\nReturns the color of a team ","private":false,"library":"team","description":"\nReturns the color of a team","param":{"1":"ind","ind":"Index of the team"}},"getNumFrags":{"ret":"number of frags","description":"\nReturns number of frags of all players on a team","code":["team_library.getNumFrags = team.TotalFrags",""],"class":"function","classForced":true,"name":"team_library.getNumFrags","summary":"\nReturns number of frags of all players on a team ","library":"team","comment":["--- Returns number of frags of all players on a team","-- @name team_library.getNumFrags","-- @class function","-- @param ind Index of the team","-- @return number of frags"],"param":{"1":"ind","ind":"Index of the team"}},"getNumPlayers":{"ret":"number of players","description":"\nReturns number of players on a team","code":["team_library.getNumPlayers = team.NumPlayers",""],"class":"function","classForced":true,"name":"team_library.getNumPlayers","summary":"\nReturns number of players on a team ","library":"team","comment":["--- Returns number of players on a team","-- @name team_library.getNumPlayers","-- @class function","-- @param ind Index of the team","-- @return number of players"],"param":{"1":"ind","ind":"Index of the team"}},"getPlayers":{"ret":"Table of players","comment":["--- Returns the table of players on a team","-- @param ind Index of the team","-- @return Table of players"],"code":["function team_library.getPlayers(ind)","\treturn SF.Sanitize(team.GetPlayers(ind))","end",""],"class":"function","name":"team_library.getPlayers","summary":"\nReturns the table of players on a team ","private":false,"library":"team","description":"\nReturns the table of players on a team","param":{"1":"ind","ind":"Index of the team"}},"getName":{"ret":"String name of the team","description":"\nReturns the name of a team","code":["team_library.getName = team.GetName",""],"class":"function","classForced":true,"name":"team_library.getName","summary":"\nReturns the name of a team ","library":"team","comment":["--- Returns the name of a team","-- @name team_library.getName","-- @class function","-- @param ind Index of the team","-- @return String name of the team"],"param":{"1":"ind","ind":"Index of the team"}}},"class":"library","summary":"\nLibrary for retreiving information about teams ","code":["local team_library, team_library_metamethods = SF.Libraries.Register(\"team\")","local cwrap, cunwrap","SF.Libraries.AddHook(\"postload\", function()","\tcwrap = SF.Color.Wrap","\tcunwrap = SF.Color.Unwrap","end)",""],"fields":[],"name":"team","client":true,"description":"\nLibrary for retreiving information about teams","libtbl":"team_library","tables":[],"server":true},{"ret":"table containing team information","comment":["--- Returns a table containing team information","-- @return table containing team information"],"code":["function team_library.getAllTeams()","\treturn SF.Sanitize(team.GetAllTeams())","end",""],"class":"function","name":"team_library.getAllTeams","summary":"\nReturns a table containing team information ","private":false,"library":"team","description":"\nReturns a table containing team information","param":[]},{"ret":"Color of the team","comment":["--- Returns the color of a team","-- @param ind Index of the team","-- @return Color of the team"],"code":["function team_library.getColor(ind)","\treturn cwrap(team.GetColor(ind)) ","end",""],"class":"function","name":"team_library.getColor","summary":"\nReturns the color of a team ","private":false,"library":"team","description":"\nReturns the color of a team","param":{"1":"ind","ind":"Index of the team"}},{"ret":"Table of players","comment":["--- Returns the table of players on a team","-- @param ind Index of the team","-- @return Table of players"],"code":["function team_library.getPlayers(ind)","\treturn SF.Sanitize(team.GetPlayers(ind))","end",""],"class":"function","name":"team_library.getPlayers","summary":"\nReturns the table of players on a team ","private":false,"library":"team","description":"\nReturns the table of players on a team","param":{"1":"ind","ind":"Index of the team"}},{"ret":"index of the best team to join","description":"\nReturns team with least players","code":["team_library.bestAutoJoinTeam = team.BestAutoJoinTeam",""],"class":"function","classForced":true,"name":"team_library.bestAutoJoinTeam","summary":"\nReturns team with least players ","library":"team","comment":["--- Returns team with least players","-- @name team_library.bestAutoJoinTeam","-- @class function","-- @return index of the best team to join"],"param":[]},{"ret":"String name of the team","description":"\nReturns the name of a team","code":["team_library.getName = team.GetName",""],"class":"function","classForced":true,"name":"team_library.getName","summary":"\nReturns the name of a team ","library":"team","comment":["--- Returns the name of a team","-- @name team_library.getName","-- @class function","-- @param ind Index of the team","-- @return String name of the team"],"param":{"1":"ind","ind":"Index of the team"}},{"ret":"Number score of the team","description":"\nReturns the score of a team","code":["team_library.getScore =  team.GetScore",""],"class":"function","classForced":true,"name":"team_library.getScore","summary":"\nReturns the score of a team ","library":"team","comment":["--- Returns the score of a team","-- @name team_library.getScore","-- @class function","-- @param ind Index of the team","-- @return Number score of the team"],"param":{"1":"ind","ind":"Index of the team"}},{"ret":"boolean","description":"\nReturns whether or not a team can be joined","code":["team_library.getJoinable = team.Joinable",""],"class":"function","classForced":true,"name":"team_library.getJoinable","summary":"\nReturns whether or not a team can be joined ","library":"team","comment":["--- Returns whether or not a team can be joined","-- @name team_library.getJoinable","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}},{"ret":"number of players","description":"\nReturns number of players on a team","code":["team_library.getNumPlayers = team.NumPlayers",""],"class":"function","classForced":true,"name":"team_library.getNumPlayers","summary":"\nReturns number of players on a team ","library":"team","comment":["--- Returns number of players on a team","-- @name team_library.getNumPlayers","-- @class function","-- @param ind Index of the team","-- @return number of players"],"param":{"1":"ind","ind":"Index of the team"}},{"ret":"number of deaths","description":"\nReturns number of deaths of all players on a team","code":["team_library.getNumDeaths = team.TotalDeaths",""],"class":"function","classForced":true,"name":"team_library.getNumDeaths","summary":"\nReturns number of deaths of all players on a team ","library":"team","comment":["--- Returns number of deaths of all players on a team","-- @name team_library.getNumDeaths","-- @class function","-- @param ind Index of the team","-- @return number of deaths"],"param":{"1":"ind","ind":"Index of the team"}},{"ret":"number of frags","description":"\nReturns number of frags of all players on a team","code":["team_library.getNumFrags = team.TotalFrags",""],"class":"function","classForced":true,"name":"team_library.getNumFrags","summary":"\nReturns number of frags of all players on a team ","library":"team","comment":["--- Returns number of frags of all players on a team","-- @name team_library.getNumFrags","-- @class function","-- @param ind Index of the team","-- @return number of frags"],"param":{"1":"ind","ind":"Index of the team"}},{"ret":"boolean","description":"\nReturns whether or not the team exists","code":["team_library.exists = team.Valid",""],"class":"function","classForced":true,"name":"team_library.exists","summary":"\nReturns whether or not the team exists ","library":"team","comment":["--- Returns whether or not the team exists","-- @name team_library.exists","-- @class function","-- @param ind Index of the team","-- @return boolean"],"param":{"1":"ind","ind":"Index of the team"}}],"tables":[],"description":"\nLibrary for retreiving information about teams","summary":"\nLibrary for retreiving information about teams "},"libs_sh/globaltables.lua":{"libraries":{"1":"globaltables","globaltables":{"comment":["--- Cross-instance tables","-- @shared"],"functions":[],"class":"library","summary":"\nCross-instance tables ","code":["local gtables_library, gtables_metamethods = SF.Libraries.Register(\"globaltables\")","","SF.GlobalTables = {}","","SF.GlobalTables.Global = {}","SF.GlobalTables.Players = {}",""],"fields":[],"name":"globaltables","client":true,"description":"\nCross-instance tables","libtbl":"gtables_library","tables":{"1":"global","2":"player","global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},"player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}},"server":true}},"type":"file","name":"libs_sh/globaltables.lua","functions":[],"doc":[{"comment":["--- Cross-instance tables","-- @shared"],"functions":[],"class":"library","summary":"\nCross-instance tables ","code":["local gtables_library, gtables_metamethods = SF.Libraries.Register(\"globaltables\")","","SF.GlobalTables = {}","","SF.GlobalTables.Global = {}","SF.GlobalTables.Players = {}",""],"fields":[],"name":"globaltables","client":true,"description":"\nCross-instance tables","libtbl":"gtables_library","tables":{"1":"global","2":"player","global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},"player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}},"server":true},{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}],"tables":{"1":"gtables_library.global","2":"gtables_library.player","gtables_library.player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]},"gtables_library.global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]}},"description":"\nCross-instance tables","summary":"\nCross-instance tables "},"libs_sh/find.lua":{"libraries":{"1":"find","find":{"comment":["--- Find library. Finds entities in various shapes.","-- @shared"],"functions":{"1":"all","2":"allPlayers","3":"byClass","4":"byModel","5":"inBox","6":"inCone","7":"inSphere","inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},"byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}}},"class":"library","summary":"\nFind library.","code":["local find_library, _ = SF.Libraries.Register(\"find\")","","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"find\", \"Find\", \"Allows the user to access the find library\" )","end","","local function convert(results, func)","\tif func then SF.CheckType(func,\"function\") end","\tlocal wrap = SF.WrapObject","\t","\tlocal t = {}","\tlocal count = 1","\tfor i=1,#results do","\t\tlocal e = wrap(results[i])","\t\tif not func or func(e) then","\t\t\tt[count] = e","\t\t\tcount = count + 1","\t\tend","\tend","\treturn t","end",""],"fields":[],"name":"find","client":true,"description":"\nFind library. Finds entities in various shapes.","libtbl":"find_library","tables":[],"server":true}},"type":"file","name":"libs_sh/find.lua","functions":{"1":"find_library.all","2":"find_library.allPlayers","3":"find_library.byClass","4":"find_library.byModel","5":"find_library.inBox","6":"find_library.inCone","7":"find_library.inSphere","find_library.inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}},"find_library.inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"find_library.all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"find_library.byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"find_library.byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"find_library.allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"find_library.inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}}},"doc":[{"summary":"\n \nFind functions \n ","description":"\n \nFind functions \n","comment":["-------------------------------------------------------------------------------","-- Find functions","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Find library. Finds entities in various shapes.","-- @shared"],"functions":{"1":"all","2":"allPlayers","3":"byClass","4":"byModel","5":"inBox","6":"inCone","7":"inSphere","inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},"byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}}},"class":"library","summary":"\nFind library.","code":["local find_library, _ = SF.Libraries.Register(\"find\")","","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"find\", \"Find\", \"Allows the user to access the find library\" )","end","","local function convert(results, func)","\tif func then SF.CheckType(func,\"function\") end","\tlocal wrap = SF.WrapObject","\t","\tlocal t = {}","\tlocal count = 1","\tfor i=1,#results do","\t\tlocal e = wrap(results[i])","\t\tif not func or func(e) then","\t\t\tt[count] = e","\t\t\tcount = count + 1","\t\tend","\tend","\treturn t","end",""],"fields":[],"name":"find","client":true,"description":"\nFind library. Finds entities in various shapes.","libtbl":"find_library","tables":[],"server":true},{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}},{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}}],"tables":[],"description":"\n \nFind functions \n","summary":"\n \nFind functions \n "},"libs_sh/angles.lua":{"libraries":[],"type":"file","name":"libs_sh/angles.lua","functions":{"1":"ang_metamethods.__add","2":"ang_metamethods.__div","3":"ang_metamethods.__eq","4":"ang_metamethods.__index","5":"ang_metamethods.__mul","6":"ang_metamethods.__newindex","7":"ang_metamethods.__sub","8":"ang_metamethods.__tostring","9":"ang_metamethods.__unm","10":"ang_methods.getForward","11":"ang_methods.getNormalized","12":"ang_methods.getRight","13":"ang_methods.getUp","14":"ang_methods.isZero","15":"ang_methods.normalize","16":"ang_methods.rotateAroundAxis","17":"ang_methods.set","18":"ang_methods.setZero","ang_metamethods.__tostring":{"ret":"string representing the angle.","comment":["--- tostring metamethod","-- @return string representing the angle."],"code":["function ang_metamethods.__tostring ( a )","\treturn table_concat( a, ' ', 1, 3 )","end",""],"class":"function","name":"ang_metamethods.__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":["a"]},"ang_methods.setZero":{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end"],"class":"function","name":"ang_methods.setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":["a"]},"ang_metamethods.__index":{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function ang_metamethods.__index ( t, k )","\tif pyr[ k ] then","\t\treturn rawget( t, pyr[ k ] )","\telse","\t\treturn _p[k]","\tend","end","","local table_concat = table.concat","","local math_nAng = math.NormalizeAngle","local function normalizedAngTable( tbl )","\treturn { math_nAng( tbl[1] ), math_nAng( tbl[2] ), math_nAng( tbl[3] ) }","end",""],"private":false,"class":"function","name":"ang_metamethods.__index","param":["t","k"]},"ang_methods.getUp":{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getUp ( a )","\treturn SF.WrapObject( unwrap( a ):Up() )","end",""],"class":"function","name":"ang_methods.getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":["a"]},"ang_metamethods.__div":{"ret":"resultant angle.","comment":["--- __div metamethod ang1 / n.","-- @param n Number to divided by.","-- @return resultant angle."],"code":["function ang_metamethods.__div ( a, n )","\tSF.CheckType( a, ang_metamethods )","\tSF.CheckType( n, \"number\" )","","\treturn wrap( { a[1]/n, a[2]/n, a[3]/n } )","end",""],"class":"function","name":"ang_metamethods.__div","private":false,"summary":"\n__div metamethod ang1 / n.","description":"\n__div metamethod ang1 / n.","param":{"1":"a","2":"n","n":"Number to divided by."}},"ang_metamethods.__eq":{"ret":"bool","comment":["--- __eq metamethod ang1 == ang2.","-- @param a Angle to check against.","-- @return bool"],"code":["function ang_metamethods.__eq ( a, b )","\treturn a[1]==b[1] and a[2]==b[2] and a[3]==b[3]","end",""],"class":"function","name":"ang_metamethods.__eq","private":false,"summary":"\n__eq metamethod ang1 == ang2.","description":"\n__eq metamethod ang1 == ang2.","param":{"1":"a","2":"b","a":"Angle to check against."}},"ang_metamethods.__mul":{"ret":"resultant angle.","comment":["--- __mul metamethod ang1 * n.","-- @param n Number to multiply by.","-- @return resultant angle."],"code":["function ang_metamethods.__mul ( a, n )","\tSF.CheckType( n, \"number\" )","","\treturn wrap( { a[1]*n, a[2]*n, a[3]*n } )","end",""],"class":"function","name":"ang_metamethods.__mul","private":false,"summary":"\n__mul metamethod ang1 * n.","description":"\n__mul metamethod ang1 * n.","param":{"1":"a","2":"n","n":"Number to multiply by."}},"ang_metamethods.__sub":{"ret":"resultant angle.","comment":["--- __sub metamethod ang1 - ang2.","-- @param a Angle to subtract.","-- @return resultant angle."],"code":["function ang_metamethods.__sub ( a, b )","\tSF.CheckType( a, ang_metamethods )","\tSF.CheckType( b, ang_metamethods )","","\treturn wrap( { a[1]-b[1], a[2]-b[2], a[3]-b[3] } )","end","",""],"class":"function","name":"ang_metamethods.__sub","private":false,"summary":"\n__sub metamethod ang1 - ang2.","description":"\n__sub metamethod ang1 - ang2.","param":{"1":"a","2":"b","a":"Angle to subtract."}},"ang_methods.getRight":{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getRight ( a )","\treturn SF.WrapObject( unwrap( a ):Right() )","end",""],"class":"function","name":"ang_methods.getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":["a"]},"ang_methods.getForward":{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods.getForward ( a )","\treturn SF.WrapObject( unwrap( a ):Forward() )","end",""],"class":"function","name":"ang_methods.getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":["a"]},"ang_methods.isZero":{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"ang_methods.isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":["a"]},"ang_methods.set":{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods.set ( a, b )","\tSF.CheckType( b, ang_metamethods )","","\ta[1] = (b[1] or 0)","\ta[2] = (b[2] or 0)","\ta[3] = (b[3] or 0)","end",""],"class":"function","name":"ang_methods.set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","2":"b","a":"Angle to copy from."}},"ang_methods.rotateAroundAxis":{"ret":"The modified angle","comment":["--- Return Rotated angle around the specified axis.","-- @param v Vector axis","-- @param deg Number of degrees or nil if radians.","-- @param rad Number of radians or nil if degrees.","-- @return The modified angle"],"code":["function ang_methods.rotateAroundAxis ( a, v, deg, rad )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","","\tif rad then","\t\tSF.CheckType( rad, \"number\" )","\t\tdeg = math.deg( rad )","\telse","\t\tSF.CheckType( deg, \"number\" )","\tend","","\tlocal ret = Angle()","","\tret:Set( unwrap( a ) )","\tret:RotateAroundAxis( SF.UnwrapObject( v ), deg )","","\treturn awrap( ret )","end",""],"class":"function","name":"ang_methods.rotateAroundAxis","summary":"\nReturn Rotated angle around the specified axis.","private":false,"classlib":"Angle","description":"\nReturn Rotated angle around the specified axis.","param":{"1":"a","2":"v","3":"deg","4":"rad","rad":"Number of radians or nil if degrees.","deg":"Number of degrees or nil if radians.","v":"Vector axis"}},"ang_metamethods.__newindex":{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function ang_metamethods.__newindex ( t, k, v )","\tif pyr[ k ] then","\t\trawset( t, pyr[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = ang_metamethods.__methods",""],"private":false,"class":"function","name":"ang_metamethods.__newindex","param":["t","k","v"]},"ang_metamethods.__add":{"ret":"resultant angle.","comment":["--- __add metamethod ang1 + ang2.","-- @param a Angle to add.","-- @return resultant angle."],"code":["function ang_metamethods.__add ( a, b )","\tSF.CheckType( a, ang_metamethods )","\tSF.CheckType( b, ang_metamethods )","","\treturn wrap( { a[1]+b[1], a[2]+b[2], a[3]+b[3] } )","end",""],"class":"function","name":"ang_metamethods.__add","private":false,"summary":"\n__add metamethod ang1 + ang2.","description":"\n__add metamethod ang1 + ang2.","param":{"1":"a","2":"b","a":"Angle to add."}},"ang_methods.getNormalized":{"ret":"Normalized angle table","comment":["--- Returnes a normalized angle","-- @return Normalized angle table"],"code":["function ang_methods.getNormalized ( a )","\tSF.CheckType( a, ang_metamethods )","\treturn wrap( normalizedAngTable( a ) )","end",""],"class":"function","name":"ang_methods.getNormalized","summary":"\nReturnes a normalized angle ","private":false,"classlib":"Angle","description":"\nReturnes a normalized angle","param":["a"]},"ang_methods.normalize":{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods.normalize ( a )","\ta[1] = math_nAng( a[1] )","\ta[2] = math_nAng( a[2] )","\ta[3] = math_nAng( a[3] )","end",""],"class":"function","name":"ang_methods.normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":["a"]},"ang_metamethods.__unm":{"ret":"resultant angle.","comment":["--- __unm metamethod -ang.","-- @return resultant angle."],"code":["function ang_metamethods.__unm ( a )","\treturn wrap( { -a[1], -a[2], -a[3] } )","end",""],"class":"function","name":"ang_metamethods.__unm","private":false,"summary":"\n__unm metamethod -ang.","description":"\n__unm metamethod -ang.","param":["a"]}},"doc":[{"comment":["--- Angle Type","-- @shared"],"code":["local ang_methods, ang_metamethods = SF.Typedef( \"Angle\" )","","local function wrap( tbl )","\treturn setmetatable( tbl, ang_metamethods )","end","","local function unwrap( obj )","\treturn Angle( obj[1], obj[2], obj[3] )","end","","local function awrap( ang )","\treturn wrap( { ang.pitch, ang.yaw, ang.roll } )","end","","SF.AddObjectWrapper( debug.getregistry().Angle, ang_metamethods, awrap )","SF.AddObjectUnwrapper( ang_metamethods, unwrap )","","SF.DefaultEnvironment.Angle = function ( p, y, r )","\treturn wrap( { p or 0, y or 0, r or 0 } )","end","","SF.Angles.Wrap \t= awrap","SF.Angles.Unwrap = unwrap","SF.Angles.Methods = ang_methods","SF.Angles.Metatable = ang_metamethods","","local dgetmeta = debug.getmetatable","","-- Lookup table.","-- Index 1->6 have associative pyr for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","local pyr = { p = 1, y = 2, r = 3, pitch = 1, yaw = 2, roll = 3 }",""],"typtbl":"ang_methods","summary":"\nAngle Type ","fields":[],"name":"Angle","server":true,"description":"\nAngle Type","client":true,"class":"class","methods":{"1":"getForward","2":"getNormalized","3":"getRight","4":"getUp","5":"isZero","6":"normalize","7":"rotateAroundAxis","8":"set","9":"setZero","getRight":{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getRight ( a )","\treturn SF.WrapObject( unwrap( a ):Right() )","end",""],"class":"function","name":"ang_methods.getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":["a"]},"set":{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods.set ( a, b )","\tSF.CheckType( b, ang_metamethods )","","\ta[1] = (b[1] or 0)","\ta[2] = (b[2] or 0)","\ta[3] = (b[3] or 0)","end",""],"class":"function","name":"ang_methods.set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","2":"b","a":"Angle to copy from."}},"isZero":{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"ang_methods.isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":["a"]},"getNormalized":{"ret":"Normalized angle table","comment":["--- Returnes a normalized angle","-- @return Normalized angle table"],"code":["function ang_methods.getNormalized ( a )","\tSF.CheckType( a, ang_metamethods )","\treturn wrap( normalizedAngTable( a ) )","end",""],"class":"function","name":"ang_methods.getNormalized","summary":"\nReturnes a normalized angle ","private":false,"classlib":"Angle","description":"\nReturnes a normalized angle","param":["a"]},"normalize":{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods.normalize ( a )","\ta[1] = math_nAng( a[1] )","\ta[2] = math_nAng( a[2] )","\ta[3] = math_nAng( a[3] )","end",""],"class":"function","name":"ang_methods.normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":["a"]},"getForward":{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods.getForward ( a )","\treturn SF.WrapObject( unwrap( a ):Forward() )","end",""],"class":"function","name":"ang_methods.getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":["a"]},"setZero":{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end"],"class":"function","name":"ang_methods.setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":["a"]},"getUp":{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getUp ( a )","\treturn SF.WrapObject( unwrap( a ):Up() )","end",""],"class":"function","name":"ang_methods.getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":["a"]},"rotateAroundAxis":{"ret":"The modified angle","comment":["--- Return Rotated angle around the specified axis.","-- @param v Vector axis","-- @param deg Number of degrees or nil if radians.","-- @param rad Number of radians or nil if degrees.","-- @return The modified angle"],"code":["function ang_methods.rotateAroundAxis ( a, v, deg, rad )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","","\tif rad then","\t\tSF.CheckType( rad, \"number\" )","\t\tdeg = math.deg( rad )","\telse","\t\tSF.CheckType( deg, \"number\" )","\tend","","\tlocal ret = Angle()","","\tret:Set( unwrap( a ) )","\tret:RotateAroundAxis( SF.UnwrapObject( v ), deg )","","\treturn awrap( ret )","end",""],"class":"function","name":"ang_methods.rotateAroundAxis","summary":"\nReturn Rotated angle around the specified axis.","private":false,"classlib":"Angle","description":"\nReturn Rotated angle around the specified axis.","param":{"1":"a","2":"v","3":"deg","4":"rad","rad":"Number of radians or nil if degrees.","deg":"Number of degrees or nil if radians.","v":"Vector axis"}}}},{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function ang_metamethods.__newindex ( t, k, v )","\tif pyr[ k ] then","\t\trawset( t, pyr[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = ang_metamethods.__methods",""],"private":false,"class":"function","name":"ang_metamethods.__newindex","param":["t","k","v"]},{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function ang_metamethods.__index ( t, k )","\tif pyr[ k ] then","\t\treturn rawget( t, pyr[ k ] )","\telse","\t\treturn _p[k]","\tend","end","","local table_concat = table.concat","","local math_nAng = math.NormalizeAngle","local function normalizedAngTable( tbl )","\treturn { math_nAng( tbl[1] ), math_nAng( tbl[2] ), math_nAng( tbl[3] ) }","end",""],"private":false,"class":"function","name":"ang_metamethods.__index","param":["t","k"]},{"ret":"string representing the angle.","comment":["--- tostring metamethod","-- @return string representing the angle."],"code":["function ang_metamethods.__tostring ( a )","\treturn table_concat( a, ' ', 1, 3 )","end",""],"class":"function","name":"ang_metamethods.__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":["a"]},{"ret":"resultant angle.","comment":["--- __mul metamethod ang1 * n.","-- @param n Number to multiply by.","-- @return resultant angle."],"code":["function ang_metamethods.__mul ( a, n )","\tSF.CheckType( n, \"number\" )","","\treturn wrap( { a[1]*n, a[2]*n, a[3]*n } )","end",""],"class":"function","name":"ang_metamethods.__mul","private":false,"summary":"\n__mul metamethod ang1 * n.","description":"\n__mul metamethod ang1 * n.","param":{"1":"a","2":"n","n":"Number to multiply by."}},{"ret":"resultant angle.","comment":["--- __div metamethod ang1 / n.","-- @param n Number to divided by.","-- @return resultant angle."],"code":["function ang_metamethods.__div ( a, n )","\tSF.CheckType( a, ang_metamethods )","\tSF.CheckType( n, \"number\" )","","\treturn wrap( { a[1]/n, a[2]/n, a[3]/n } )","end",""],"class":"function","name":"ang_metamethods.__div","private":false,"summary":"\n__div metamethod ang1 / n.","description":"\n__div metamethod ang1 / n.","param":{"1":"a","2":"n","n":"Number to divided by."}},{"ret":"resultant angle.","comment":["--- __unm metamethod -ang.","-- @return resultant angle."],"code":["function ang_metamethods.__unm ( a )","\treturn wrap( { -a[1], -a[2], -a[3] } )","end",""],"class":"function","name":"ang_metamethods.__unm","private":false,"summary":"\n__unm metamethod -ang.","description":"\n__unm metamethod -ang.","param":["a"]},{"ret":"bool","comment":["--- __eq metamethod ang1 == ang2.","-- @param a Angle to check against.","-- @return bool"],"code":["function ang_metamethods.__eq ( a, b )","\treturn a[1]==b[1] and a[2]==b[2] and a[3]==b[3]","end",""],"class":"function","name":"ang_metamethods.__eq","private":false,"summary":"\n__eq metamethod ang1 == ang2.","description":"\n__eq metamethod ang1 == ang2.","param":{"1":"a","2":"b","a":"Angle to check against."}},{"ret":"resultant angle.","comment":["--- __add metamethod ang1 + ang2.","-- @param a Angle to add.","-- @return resultant angle."],"code":["function ang_metamethods.__add ( a, b )","\tSF.CheckType( a, ang_metamethods )","\tSF.CheckType( b, ang_metamethods )","","\treturn wrap( { a[1]+b[1], a[2]+b[2], a[3]+b[3] } )","end",""],"class":"function","name":"ang_metamethods.__add","private":false,"summary":"\n__add metamethod ang1 + ang2.","description":"\n__add metamethod ang1 + ang2.","param":{"1":"a","2":"b","a":"Angle to add."}},{"ret":"resultant angle.","comment":["--- __sub metamethod ang1 - ang2.","-- @param a Angle to subtract.","-- @return resultant angle."],"code":["function ang_metamethods.__sub ( a, b )","\tSF.CheckType( a, ang_metamethods )","\tSF.CheckType( b, ang_metamethods )","","\treturn wrap( { a[1]-b[1], a[2]-b[2], a[3]-b[3] } )","end","",""],"class":"function","name":"ang_metamethods.__sub","private":false,"summary":"\n__sub metamethod ang1 - ang2.","description":"\n__sub metamethod ang1 - ang2.","param":{"1":"a","2":"b","a":"Angle to subtract."}},{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods.getForward ( a )","\treturn SF.WrapObject( unwrap( a ):Forward() )","end",""],"class":"function","name":"ang_methods.getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":["a"]},{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"ang_methods.isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":["a"]},{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods.normalize ( a )","\ta[1] = math_nAng( a[1] )","\ta[2] = math_nAng( a[2] )","\ta[3] = math_nAng( a[3] )","end",""],"class":"function","name":"ang_methods.normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":["a"]},{"ret":"Normalized angle table","comment":["--- Returnes a normalized angle","-- @return Normalized angle table"],"code":["function ang_methods.getNormalized ( a )","\tSF.CheckType( a, ang_metamethods )","\treturn wrap( normalizedAngTable( a ) )","end",""],"class":"function","name":"ang_methods.getNormalized","summary":"\nReturnes a normalized angle ","private":false,"classlib":"Angle","description":"\nReturnes a normalized angle","param":["a"]},{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getRight ( a )","\treturn SF.WrapObject( unwrap( a ):Right() )","end",""],"class":"function","name":"ang_methods.getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":["a"]},{"ret":"The modified angle","comment":["--- Return Rotated angle around the specified axis.","-- @param v Vector axis","-- @param deg Number of degrees or nil if radians.","-- @param rad Number of radians or nil if degrees.","-- @return The modified angle"],"code":["function ang_methods.rotateAroundAxis ( a, v, deg, rad )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","","\tif rad then","\t\tSF.CheckType( rad, \"number\" )","\t\tdeg = math.deg( rad )","\telse","\t\tSF.CheckType( deg, \"number\" )","\tend","","\tlocal ret = Angle()","","\tret:Set( unwrap( a ) )","\tret:RotateAroundAxis( SF.UnwrapObject( v ), deg )","","\treturn awrap( ret )","end",""],"class":"function","name":"ang_methods.rotateAroundAxis","summary":"\nReturn Rotated angle around the specified axis.","private":false,"classlib":"Angle","description":"\nReturn Rotated angle around the specified axis.","param":{"1":"a","2":"v","3":"deg","4":"rad","rad":"Number of radians or nil if degrees.","deg":"Number of degrees or nil if radians.","v":"Vector axis"}},{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods.set ( a, b )","\tSF.CheckType( b, ang_metamethods )","","\ta[1] = (b[1] or 0)","\ta[2] = (b[2] or 0)","\ta[3] = (b[3] or 0)","end",""],"class":"function","name":"ang_methods.set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","2":"b","a":"Angle to copy from."}},{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getUp ( a )","\treturn SF.WrapObject( unwrap( a ):Up() )","end",""],"class":"function","name":"ang_methods.getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":["a"]},{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end"],"class":"function","name":"ang_methods.setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":["a"]}],"tables":[],"description":"\nAngle Type","summary":"\nAngle Type "}},"classes":{"1":"Angle","2":"Bass","3":"Color","4":"Entity","5":"Hologram","6":"Npc","7":"Player","8":"Quaternion","9":"Sound","10":"VMatrix","11":"Vector","12":"Vehicle","13":"Weapon","14":"Wirelink","Quaternion":{"comment":["--- Quaternion type"],"code":["local quat_methods, quat_metamethods = SF.Typedef(\"Quaternion\")","--[[quat_metamethods = {__index = quat_lib}","quat_lib.__metatable = quat_metamethods","quat_metamethods.__type = \"Quaternion\"","setmetatable(quat_lib, quat_metamethods)]]","","--****************************** Helper functions ******************************--","","local function quicknew(r, i, j, k)","\tlocal new = {r, i, j, k}","\tsetmetatable( new, quat_metamethods )","\treturn new","end","","local function qmul(lhs, rhs)","\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\treturn quicknew(","\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t)","end","","local function qexp(q)","\tlocal m = sqrt(q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tlocal u","\tif m ~= 0 then","\t\tu = { q[2]*sin(m)/m, q[3]*sin(m)/m, q[4]*sin(m)/m }","\telse","\t\tu = { 0, 0, 0 }","\tend","\tlocal r = exp(q[1])","\treturn quicknew( r*cos(m), r*u[1], r*u[2], r*u[3] )","end","","local function qlog(q)","\tlocal l = sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tif l == 0 then return { -1e+100, 0, 0, 0 } end","\tlocal u = { q[1]/l, q[2]/l, q[3]/l, q[4]/l }","\tlocal a = acos(u[1])","\tlocal m = sqrt(u[2]*u[2] + u[3]*u[3] + u[4]*u[4])","\tif abs(m) > delta then","\t\treturn quicknew( log(l), a*u[2]/m, a*u[3]/m, a*u[4]/m )","\telse","\t\treturn quicknew( log(l), 0, 0, 0 )  --when m is 0, u[2], u[3] and u[4] are 0 too","\tend","end","","--******************************************************************************--","","local argTypesToQuat = {}"],"typtbl":"quat_methods","fields":[],"name":"Quaternion","summary":"\nQuaternion type ","description":"\nQuaternion type","class":"class","methods":{"1":"conj","2":"forward","3":"i","4":"j","5":"k","6":"r","7":"real","8":"right","9":"up","conj":{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},"r":{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},"right":{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},"real":{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},"i":{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},"k":{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},"j":{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},"forward":{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},"up":{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]}}},"Hologram":{"comment":["--- Hologram type"],"code":["local hologram_methods, hologram_metamethods = SF.Typedef(\"Hologram\", SF.Entities.Metatable)","local wrap, unwrap = SF.CreateWrapper( hologram_metamethods, true, false, nil, SF.Entities.Metatable )","","local ang_meta, vec_meta, ent_meta","local vunwrap, aunwrap, ewrap, eunwrap","","SF.Libraries.AddHook(\"postload\", function()","\tang_meta = SF.Angles.Metatable","\tvec_meta = SF.Vectors.Metatable","\tent_meta = SF.Entities.Metatable","","\tvunwrap = SF.Vectors.Unwrap","\taunwrap = SF.Angles.Unwrap","\tewrap = SF.Entities.Wrap","\teunwrap = SF.Entities.Unwrap","end)","","SF.Holograms = {}","","SF.Holograms.personalquota = CreateConVar( \"sf_holograms_personalquota\", \"100\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of holograms allowed to spawn via Starfall scripts for a single instance\" )","","SF.Holograms.Methods = hologram_methods","SF.Holograms.Metatable = hologram_metamethods","SF.Holograms.Wrap = wrap","SF.Holograms.Unwrap = unwrap","","-- Table with player keys that automatically cleans when player leaves.","local plyCount = SF.EntityTable(\"playerHolos\")","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.holograms = {","\t\tholos = {},","\t\tcount = 0","\t}","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tlocal holos = inst.data.holograms.holos","\tlocal holo = next(holos)","\twhile holo do","\t\tif IsValid(holo) then","\t\t\tholo:Remove()","\t\tend","\t\tholo = next(holos, holo)","\tend","end)","","local function hologramOnDestroy(holoent, holodata, ply)","\tholodata.holos[holoent] = nil","\tif plyCount[ply] then","\t\tplyCount[ply] = plyCount[ply] - 1","\tend","end",""],"typtbl":"hologram_methods","fields":[],"name":"Hologram","summary":"\nHologram type ","description":"\nHologram type","class":"class","methods":{"1":"getAnimationLength","2":"getAnimationNumber","3":"getFlexes","4":"getPose","5":"setAngVel","6":"setAnimation","7":"setClip","8":"setFlexScale","9":"setFlexWeight","10":"setModel","11":"setPose","12":"setScale","13":"setVel","14":"suppressEngineLighting","setScale":{"comment":["--- Sets the hologram scale","-- @param scale Vector new scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, vec_meta )","\tlocal scale = vunwrap( scale )","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"Vector new scale"}},"getFlexes":{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},"setFlexWeight":{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},"getPose":{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},"setAngVel":{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, ang_meta )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( aunwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},"getAnimationNumber":{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},"setAnimation":{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},"setFlexScale":{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},"setPose":{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},"setVel":{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, vec_meta )","\tlocal vel = vunwrap( vel )","\tlocal holo = unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},"getAnimationLength":{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},"suppressEngineLighting":{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","\tSF.CheckType( suppress, \"boolean\" )","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetNetworkedBool( \"suppressEngineLighting\", suppress )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},"setModel":{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","\tSF.CheckType( model, \"string\" )","\tif not util.IsValidModel( model ) then SF.throw( \"Model is invalid\", 2 ) end","","\tlocal this = unwrap( self )","\tif IsValid( this ) then","\t\tthis:SetModel( model )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},"setClip":{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, vec_meta )","\tSF.CheckType(normal, vec_meta )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]}}},"Bass":{"comment":["--- Bass type","-- @client"],"code":["local bass_methods, bass_metamethods = SF.Typedef( \"Bass\" )","local wrap, unwrap = SF.CreateWrapper( bass_metamethods, true, false, debug.getregistry().IGModAudioChannel )",""],"typtbl":"bass_methods","fields":[],"name":"Bass","summary":"\nBass type ","description":"\nBass type","client":true,"class":"class","methods":{"1":"getFFT","2":"getLength","3":"getTime","4":"play","5":"setFade","6":"setLooping","7":"setPitch","8":"setPos","9":"setTime","10":"setVolume","11":"stop","setLooping":{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},"setFade":{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},"getFFT":{"ret":"FFT table of the sound","comment":["--- Gets the FFT of a sound","-- @param n Sample size of the hamming window. Must be power of 2","-- @return FFT table of the sound"],"code":["function bass_methods:getFFT ( n )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tlocal arr = {}","\t\tuw:FFT( arr, n )","\t\treturn arr","\tend","end","",""],"class":"function","name":"bass_methods:getFFT","summary":"\nGets the FFT of a sound ","private":false,"classlib":"Bass","description":"\nGets the FFT of a sound","param":{"1":"n","n":"Sample size of the hamming window. Must be power of 2"}},"getTime":{"ret":"Current time in seconds of the sound","comment":["--- Gets the current time of a sound","-- @return Current time in seconds of the sound"],"code":["function bass_methods:getTime ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetTime()","\tend","end",""],"class":"function","name":"bass_methods:getTime","summary":"\nGets the current time of a sound ","private":false,"classlib":"Bass","description":"\nGets the current time of a sound","param":[]},"setPos":{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},"stop":{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tSF.CheckType( self, bass_metamethods )","\tlocal uw =  unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},"setTime":{"comment":["--- Sets the current time of a sound","-- @param time Time to set a sound in seconds"],"code":["function bass_methods:setTime ( time )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( time, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetTime( time )","\tend","end",""],"class":"function","name":"bass_methods:setTime","summary":"\nSets the current time of a sound ","private":false,"classlib":"Bass","description":"\nSets the current time of a sound","param":{"1":"time","time":"Time to set a sound in seconds"}},"getLength":{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},"play":{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tSF.CheckType( self, bass_metamethods )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\tlocal uw = unwrap( self )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}}}},"Color":{"comment":["--- Color type","--@shared"],"code":["local color_methods, color_metatable = SF.Typedef( \"Color\", {} )","","local function wrap( tbl )","\treturn setmetatable( tbl, color_metatable )","end","","local function unwrap( obj )","\treturn Color( (tonumber(obj[1]) or 255), (tonumber(obj[2]) or 255), (tonumber(obj[3]) or 255), (tonumber(obj[4]) or 255) )","end","","local function cwrap( clr )","\treturn wrap( { clr.r, clr.g, clr.b, clr.a } )","end","","SF.AddObjectWrapper( debug.getregistry().Color, color_metatable, cwrap )","SF.AddObjectUnwrapper( color_metatable, unwrap )","","SF.Color.Methods = color_methods","SF.Color.Metatable = color_metatable","SF.Color.Wrap = cwrap","SF.Color.Unwrap = unwrap","","local dgetmeta = debug.getmetatable"],"typtbl":"color_methods","summary":"\nColor type ","fields":[],"name":"Color","server":true,"description":"\nColor type","client":true,"class":"class","methods":{"1":"hsvToRGB","2":"rgbToHSV","rgbToHSV":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\tlocal h, s, v = ColorToHSV( self )","\treturn wrap( { h, s, v, 255 } )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},"hsvToRGB":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\tlocal rgb = HSVToColor( self[1], self[2], self[3] )","\treturn wrap( { rgb.r, rgb.g, rgb.b, (rgb.a or 255) } )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]}}},"Npc":{"comment":["--- Npc type"],"code":["local npc_methods, npc_metatable = SF.Typedef(\"Npc\", SF.Entities.Metatable)","","SF.Npcs.Methods = npc_methods","SF.Npcs.Metatable = npc_metatable","","local dsetmeta = debug.setmetatable","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","local wrap, unwrap, ents_metatable","","SF.Libraries.AddHook(\"postload\", function()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","\tents_metatable = SF.Entities.Metatable","\t","\tSF.AddObjectWrapper( debug.getregistry().NPC, npc_metatable, function( object )","\t\tobject = wrap( object )","\t\tdsetmeta( object, npc_metatable )","\t\treturn object","\tend )","\tSF.AddObjectUnwrapper( npc_metatable, unwrap )","end)","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"npcs.modify\", \"Modify\", \"Allows the user to modify npcs\" )","end","","-- ------------------------------------------------------------------------- --","function npc_metatable:__tostring()","\tlocal ent = unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end",""],"typtbl":"npc_methods","fields":[],"name":"Npc","summary":"\nNpc type ","description":"\nNpc type","class":"class","methods":{"1":"addEntityRelationship","2":"addRelationship","3":"attackMelee","4":"attackRange","5":"getEnemy","6":"getRelationship","7":"goRun","8":"goWalk","9":"setEnemy","10":"stop","goWalk":{"comment":["--- Makes the npc walk to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goWalk(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO )","end",""],"class":"function","name":"npc_methods:goWalk","summary":"\nMakes the npc walk to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc walk to a destination","param":{"1":"vec","vec":"The position of the destination"}},"addEntityRelationship":{"comment":["--- Adds a relationship to the npc with an entity","-- @param ent The target entity","-- @param disp String of the relationship. (hate fear like neutral)","-- @param priority number how strong the relationship is. Higher number is stronger"],"code":["function npc_methods:addEntityRelationship(ent, disp, priority)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tlocal relation = dispositions[disp]","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not relation then SF.throw( \"Invalid relationship specified\" ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddEntityRelationship(target, relation, priority)","end",""],"class":"function","name":"npc_methods:addEntityRelationship","summary":"\nAdds a relationship to the npc with an entity ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc with an entity","param":{"1":"ent","2":"disp","3":"priority","priority":"number how strong the relationship is. Higher number is stronger","disp":"String of the relationship. (hate fear like neutral)","ent":"The target entity"}},"attackRange":{"comment":["--- Makes the npc do a ranged attack"],"code":["function npc_methods:attackRange()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_RANGE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackRange","summary":"\nMakes the npc do a ranged attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a ranged attack","param":[]},"getRelationship":{"ret":"string relationship of the npc with the target","comment":["--- Gets the npc's relationship to the target","-- @param ent Target entity","-- @return string relationship of the npc with the target"],"code":["function npc_methods:getRelationship(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\treturn dispositions[npc:Disposition()]","end",""],"class":"function","name":"npc_methods:getRelationship","summary":"\nGets the npc's relationship to the target ","private":false,"classlib":"Npc","description":"\nGets the npc's relationship to the target","param":{"1":"ent","ent":"Target entity"}},"stop":{"comment":["--- Stops the npc"],"code":["function npc_methods:stop()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_NONE )","end",""],"class":"function","name":"npc_methods:stop","summary":"\nStops the npc ","private":false,"classlib":"Npc","description":"\nStops the npc","param":[]},"getEnemy":{"ret":"Entity the npc is fighting","comment":["--- Gets what the npc is fighting","-- @return Entity the npc is fighting"],"code":["function npc_methods:getEnemy()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\treturn vwrap(npc:GetEnemy())","end",""],"class":"function","name":"npc_methods:getEnemy","summary":"\nGets what the npc is fighting ","private":false,"classlib":"Npc","description":"\nGets what the npc is fighting","param":[]},"goRun":{"comment":["--- Makes the npc run to a destination","-- @param vec The position of the destination"],"code":["function npc_methods:goRun(vec)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetLastPosition( vunwrap(vec) )","\tnpc:SetSchedule( SCHED_FORCED_GO_RUN )","end",""],"class":"function","name":"npc_methods:goRun","summary":"\nMakes the npc run to a destination ","private":false,"classlib":"Npc","description":"\nMakes the npc run to a destination","param":{"1":"vec","vec":"The position of the destination"}},"attackMelee":{"comment":["--- Makes the npc do a melee attack"],"code":["function npc_methods:attackMelee()","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetSchedule( SCHED_MELEE_ATTACK1 )","end",""],"class":"function","name":"npc_methods:attackMelee","summary":"\nMakes the npc do a melee attack ","private":false,"classlib":"Npc","description":"\nMakes the npc do a melee attack","param":[]},"addRelationship":{"comment":["--- Adds a relationship to the npc","-- @param str The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"],"code":["function npc_methods:addRelationship(str)","\tSF.CheckType( self, npc_metatable )","\tlocal npc = unwrap(self)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:AddRelationship(str)","end","","local dispositions = {","\terror = D_ER,","\thate = D_HT,","\tfear = D_FR,","\tlike = D_LI,","\tneutral = D_NU,","\t[D_ER] = \"error\",","\t[D_HT] = \"hate\",","\t[D_FR] = \"fear\",","\t[D_LI] = \"like\",","\t[D_NU] = \"neutral\",","}"],"class":"function","name":"npc_methods:addRelationship","summary":"\nAdds a relationship to the npc ","private":false,"classlib":"Npc","description":"\nAdds a relationship to the npc","param":{"1":"str","str":"The relationship string. http://wiki.garrysmod.com/page/NPC/AddRelationship"}},"setEnemy":{"comment":["--- Tell the npc to fight this","-- @param ent Target entity"],"code":["function npc_methods:setEnemy(ent)","\tSF.CheckType( self, npc_metatable )","\tSF.CheckType( ent, ents_metatable )","\tlocal npc = unwrap(self)","\tlocal target = unwrap(ent)","\tif not npc:IsValid() then SF.throw( \"NPC is invalid\", 2 ) end","\tif not target:IsValid() then SF.throw( \"Target is invalid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, npc, \"npcs.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tnpc:SetTarget(target)","end",""],"class":"function","name":"npc_methods:setEnemy","summary":"\nTell the npc to fight this ","private":false,"classlib":"Npc","description":"\nTell the npc to fight this","param":{"1":"ent","ent":"Target entity"}}}},"Wirelink":{"comment":["--- Wirelink type","-- @server"],"code":["local wirelink_methods, wirelink_metatable = SF.Typedef(\"Wirelink\")","local wlwrap, wlunwrap = SF.CreateWrapper(wirelink_metatable,true,true)","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"wire.setOutputs\", \"Set outputs\", \"Allows the user to specify the set of outputs\" )","\tP.registerPrivilege( \"wire.setInputs\", \"Set inputs\", \"Allows the user to specify the set of inputs\" )","\tP.registerPrivilege( \"wire.output\", \"Output\", \"Allows the user to set the value of an output\" )","\tP.registerPrivilege( \"wire.input\", \"Input\", \"Allows the user to read the value of an input\" )","\tP.registerPrivilege( \"wire.wirelink.read\", \"Wirelink Read\", \"Allows the user to read from wirelink\" )","\tP.registerPrivilege( \"wire.wirelink.write\", \"Wirelink Write\", \"Allows the user to write to wirelink\" )","\tP.registerPrivilege( \"wire.createWire\", \"Create Wire\", \"Allows the user to create a wire between two entities\" )","\tP.registerPrivilege( \"wire.deleteWire\", \"Delete Wire\", \"Allows the user to delete a wire between two entities\" )","\tP.registerPrivilege( \"wire.getInputs\", \"Get Inputs\", \"Allows the user to get Inputs of an entity\" )","\tP.registerPrivilege( \"wire.getOutputs\", \"Get Outputs\", \"Allows the user to get Outputs of an entity\" )","end",""],"typtbl":"wirelink_methods","fields":[],"name":"Wirelink","summary":"\nWirelink type ","server":true,"description":"\nWirelink type","class":"class","methods":{"1":"entity","2":"getWiredTo","3":"getWiredToName","4":"inputType","5":"inputs","6":"isValid","7":"isWired","8":"outputType","9":"outputs","isValid":{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},"outputType":{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},"getWiredTo":{"ret":"The entity the wirelink is wired to","comment":["--- Returns what an input of the wirelink is wired to.","-- @param name Name of the input","-- @return The entity the wirelink is wired to"],"code":["function wirelink_methods:getWiredTo(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn SF.Entities.Wrap( input.Src )","\tend","end",""],"class":"function","name":"wirelink_methods:getWiredTo","summary":"\nReturns what an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns what an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input"}},"inputType":{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},"isWired":{"comment":["--- Checks if an input is wired.","-- @param name Name of the input to check"],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":{"1":"name","name":"Name of the input to check"}},"entity":{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},"getWiredToName":{"ret":"String name of the output that the input is wired to.","comment":["--- Returns the name of the output an input of the wirelink is wired to.","-- @param name Name of the input of the wirelink.","-- @return String name of the output that the input is wired to."],"code":["function wirelink_methods:getWiredToName(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then","\t\treturn input.SrcId","\tend","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:getWiredToName","summary":"\nReturns the name of the output an input of the wirelink is wired to.","private":false,"classlib":"Wirelink","description":"\nReturns the name of the output an input of the wirelink is wired to.","param":{"1":"name","name":"Name of the input of the wirelink."}},"inputs":{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},"outputs":{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]}}},"VMatrix":{"comment":["--- VMatrix type"],"code":["local vmatrix_methods, vmatrix_metamethods = SF.Typedef( \"VMatrix\" )","local wrap, unwrap = SF.CreateWrapper( vmatrix_metamethods, true, false, debug.getregistry().VMatrix )","local vec_meta, vwrap, vunwrap, ang_meta, awrap, aunwrap","","SF.Libraries.AddHook(\"postload\", function()","\tvec_meta = SF.Vectors.Metatable","\tvwrap = SF.Vectors.Wrap","\tvunwrap = SF.Vectors.Unwrap","\t","\tang_meta = SF.Angles.Metatable","\tawrap = SF.Angles.Wrap","\taunwrap = SF.Angles.Unwrap","end)","","SF.VMatrix.Methods = vmatrix_methods","SF.VMatrix.Metatable = vmatrix_metamethods","SF.VMatrix.Wrap = wrap","SF.VMatrix.Unwrap = unwrap","","local dgetmeta = debug.getmetatable",""],"typtbl":"vmatrix_methods","fields":[],"name":"VMatrix","summary":"\nVMatrix type ","description":"\nVMatrix type","class":"class","methods":{"1":"getAngles","2":"getInverse","3":"getInverseTR","4":"getScale","5":"getTranslation","6":"rotate","7":"scale","8":"scaleTranslation","9":"setAngles","10":"setTranslation","11":"translate","scale":{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},"getScale":{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn vwrap( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},"getAngles":{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn awrap( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},"translate":{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\tSF.CheckType( lhs, vmatrix_metamethods )","\tlocal rhsmeta = dgetmeta( rhs )","\tif rhsmeta == vmatrix_metamethods then","\t\treturn wrap( unwrap( lhs ) * unwrap( rhs ) )","\telseif rhsmeta == vec_meta then","\t\treturn vwrap( unwrap( lhs ) * vunwrap( rhs ) )","\telse","\t\tSF.throw(\"Matrix must be multiplied with another matrix or vector on right hand side\",2)","\tend","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}},"getTranslation":{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn vwrap( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},"setTranslation":{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, vec_meta )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},"getInverse":{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},"setAngles":{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},"rotate":{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, ang_meta )","","\tlocal v = unwrap( self )","\tv:Rotate( aunwrap( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},"getInverseTR":{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]},"scaleTranslation":{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}}}},"Player":{"comment":["--- Player type"],"code":["local player_methods, player_metamethods = SF.Typedef(\"Player\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Players.Methods = player_methods","SF.Players.Metatable = player_metamethods","","","local dsetmeta = debug.setmetatable","","local ewrap, eunwrap, ents_metatable","","SF.Libraries.AddHook(\"postload\", function()","\tewrap = SF.Entities.Wrap","\teunwrap = SF.Entities.Unwrap","\tents_metatable = SF.Entities.Metatable","\t","\tSF.AddObjectWrapper( debug.getregistry().Player, player_metamethods, function( object )","\t\tobject = ewrap( object )","\t\tdsetmeta( object, player_metamethods )","\t\treturn object","\tend )","\tSF.AddObjectUnwrapper( player_metamethods, eunwrap )","end)",""],"typtbl":"player_methods","fields":[],"name":"Player","summary":"\nPlayer type ","description":"\nPlayer type","class":"class","methods":{"1":"getActiveWeapon","2":"getAimVector","3":"getArmor","4":"getDeaths","5":"getEyeTrace","6":"getFOV","7":"getFrags","8":"getFriendStatus","9":"getJumpPower","10":"getMaxSpeed","11":"getName","12":"getPing","13":"getRunSpeed","14":"getShootPos","15":"getSteamID","16":"getSteamID64","17":"getTeam","18":"getTeamName","19":"getUniqueID","20":"getUserID","21":"getViewEntity","22":"getWeapon","23":"getWeapons","24":"inVehicle","25":"isAdmin","26":"isAlive","27":"isBot","28":"isConnected","29":"isCrouching","30":"isFlashlightOn","31":"isFrozen","32":"isMuted","33":"isNPC","34":"isNoclipped","35":"isPlayer","36":"isSuperAdmin","37":"isUserGroup","38":"keyDown","39":"setViewEntity","isUserGroup":{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},"isBot":{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},"setViewEntity":{"comment":["\t--- Sets the view entity of the player. Only works if they are linked to a hud.","\t-- @server","\t-- @param e Entity to set the player's view entity to"],"code":["\tfunction player_methods:setViewEntity ( e )","\t\tlocal pl = eunwrap( self )","\t\tlocal ent = eunwrap( e )","\t\tif not (ent and ent:IsValid()) then SF.throw(\"Invalid Entity\", 2) end","\t\t","\t\tif IsValid(pl.sfhudenabled) and pl.sfhudenabled.link == SF.instance.data.entity then","\t\t\tpl:SetViewEntity( ent )","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the view entity of the player.","name":"player_methods:setViewEntity","classlib":"Player","private":false,"server":true,"description":"\nSets the view entity of the player. Only works if they are linked to a hud.","param":{"1":"e","e":"Entity to set the player's view entity to"}},"isNoclipped":{"ret":"true if the player is noclipped","comment":["--- Returns true if the player is noclipped","-- @shared","-- @return true if the player is noclipped"],"code":["function player_methods:isNoclipped()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMoveType() == MOVETYPE_NOCLIP","end",""],"class":"function","summary":"\nReturns true if the player is noclipped ","classlib":"Player","name":"player_methods:isNoclipped","server":true,"private":false,"client":true,"description":"\nReturns true if the player is noclipped","param":[]},"getJumpPower":{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},"inVehicle":{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},"keyDown":{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = eunwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},"getFOV":{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},"getShootPos":{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},"getTeam":{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},"getViewEntity":{"ret":"Player's current view entity","comment":["--- Returns the player's current view entity","-- @shared","-- @return Player's current view entity"],"code":["function player_methods:getViewEntity ()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetViewEntity() )","end",""],"class":"function","summary":"\nReturns the player's current view entity ","classlib":"Player","name":"player_methods:getViewEntity","server":true,"private":false,"client":true,"description":"\nReturns the player's current view entity","param":[]},"getArmor":{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},"getSteamID":{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},"isConnected":{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},"getUserID":{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},"getMaxSpeed":{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]},"getSteamID64":{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},"getRunSpeed":{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},"getAimVector":{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},"getUniqueID":{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},"getFriendStatus":{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},"getFrags":{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},"isMuted":{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = eunwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]},"isPlayer":{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},"getPing":{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},"getWeapon":{"ret":"weapon","comment":["--- Returns the specified weapon or nil if the player doesn't have it","-- @shared","-- @param wep String weapon class","-- @return weapon"],"code":["function player_methods:getWeapon( wep )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( wep, \"string\" )","\treturn ewrap( eunwrap( self ):GetWeapon( wep ) )","end","","-- Returns the entity that the player is standing on","-- @shared","-- @return Ground entity","function player_methods:getGroundEntity()","\tSF.CheckType( self, player_metamethods )","\treturn ewrap( eunwrap( self ):GetGroundEntity() )","end","","if SERVER then"],"class":"function","summary":"\nReturns the specified weapon or nil if the player doesn't have it ","classlib":"Player","name":"player_methods:getWeapon","server":true,"private":false,"client":true,"description":"\nReturns the specified weapon or nil if the player doesn't have it","param":{"1":"wep","wep":"String weapon class"}},"getWeapons":{"ret":"Table of weapons","comment":["--- Returns a table of weapons the player is carrying","-- @shared","-- @return Table of weapons"],"code":["function player_methods:getWeapons()","\tSF.CheckType( self, player_metamethods )","\treturn SF.Sanitize( eunwrap( self ):GetWeapons() )","end",""],"class":"function","summary":"\nReturns a table of weapons the player is carrying ","classlib":"Player","name":"player_methods:getWeapons","server":true,"private":false,"client":true,"description":"\nReturns a table of weapons the player is carrying","param":[]},"isAlive":{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},"isFlashlightOn":{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},"getName":{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},"isNPC":{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},"isAdmin":{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},"isSuperAdmin":{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},"getTeamName":{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},"isCrouching":{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},"getEyeTrace":{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, eunwrap( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal data = eunwrap( self ):GetEyeTrace()","\treturn setmetatable({}, {","\t\t__index=function(t,k)","\t\t\treturn vwrap( data[k] )","\t\tend","\t})","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},"getDeaths":{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},"isFrozen":{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]},"getActiveWeapon":{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]}}},"Vector":{"comment":["--- Vector type","-- @shared"],"code":["local vec_methods, vec_metamethods = SF.Typedef( \"Vector\" )","","local function wrap( tbl )","\treturn setmetatable( tbl, vec_metamethods )","end","","local function unwrap( obj )","\treturn Vector( obj[1], obj[2], obj[3] )","end","","local function vwrap( vec )","\treturn wrap( { vec.x, vec.y, vec.z } )","end","","SF.AddObjectWrapper( debug.getregistry().Vector, vec_metamethods, vwrap )","SF.AddObjectUnwrapper( vec_metamethods, unwrap )","","SF.DefaultEnvironment.Vector = function ( x, y, z )","\treturn wrap( { x or 0, y or 0, z or 0 } )","end","","SF.Vectors.Wrap = vwrap","SF.Vectors.Unwrap = unwrap","SF.Vectors.Methods = vec_methods","SF.Vectors.Metatable = vec_metamethods","","local dgetmeta = debug.getmetatable","","-- Lookup table.","-- Index 1->3 have associative xyz for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","local xyz = { x = 1, y = 2, z = 3 }",""],"typtbl":"vec_methods","summary":"\nVector type ","fields":[],"name":"Vector","server":true,"description":"\nVector type","client":true,"class":"class","methods":{"1":"add","2":"cross","3":"div","4":"dot","5":"getAngle","6":"getAngleEx","7":"getDistance","8":"getDistanceSqr","9":"getLength","10":"getLength2D","11":"getLength2DSqr","12":"getLengthSqr","13":"getNormalized","14":"isEqualTol","15":"isZero","16":"mul","17":"normalize","18":"rotate","19":"rotateAroundAxis","20":"set","21":"setZero","22":"sub","23":"toScreen","24":"vdiv","25":"vmul","26":"withinAABox","isEqualTol":{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods.isEqualTol ( a, v, t )","\tSF.CheckType( v, vec_metamethods )","\tSF.CheckType( t, \"number\" )","","\treturn unwrap( a ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods.isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"a","2":"v","3":"t","t":"Tolerance number.","v":"Second Vector"}},"getAngle":{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods.getAngle ( a )","\treturn SF.WrapObject( unwrap( a ):Angle() )","end",""],"class":"function","name":"vec_methods.getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":["a"]},"getLength2D":{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods.getLength2D ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":["a"]},"getLength":{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods.getLength ( a )","\treturn math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":["a"]},"normalize":{"ret":"nil","comment":["--- Normalise the vector, same direction, length 1. Self-Modifies.","-- @return nil"],"code":["function vec_methods.normalize ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\ta[1] = a[1] / len","\ta[2] = a[2] / len","\ta[3] = a[3] / len","end",""],"class":"function","name":"vec_methods.normalize","summary":"\nNormalise the vector, same direction, length 1.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 1. Self-Modifies.","param":["a"]},"dot":{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.dot ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ( a[1]*v[1] + a[2]*v[2] + a[3]*v[3] )","end",""],"class":"function","name":"vec_methods.dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"a","2":"v","v":"Second Vector"}},"getDistance":{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistance ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn math_sqrt( (v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2 )","end",""],"class":"function","name":"vec_methods.getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"a","2":"v","v":"Second Vector"}},"setZero":{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end",""],"class":"function","name":"vec_methods.setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":["a"]},"getLength2DSqr":{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods.getLength2DSqr ( a )","\treturn ( a[1]^2 + a[2]^2 )","end",""],"class":"function","name":"vec_methods.getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":["a"]},"rotateAroundAxis":{"ret":"Rotated vector","comment":["--- Return rotated vector by an axis","-- @param axis Axis the rotate around","-- @param degrees Angle to rotate by in degrees or nil if radians.","-- @param radians Angle to rotate by in radians or nil if degrees.","-- @return Rotated vector"],"code":["function vec_methods.rotateAroundAxis( a, axis, degrees, radians )","\tSF.CheckType( axis, vec_metamethods )","","\tif degrees then","\t\tSF.CheckType( degrees, \"number\" )","\t\tradians = math.rad(degrees)","\telse","\t\tSF.CheckType( radians, \"number\" )","\tend","","\tlocal ca, sa = math.cos(radians), math.sin(radians)","\tlocal x,y,z,x2,y2,z2 = axis[1], axis[2], axis[3], a[1], a[2], a[3]","\tlocal length = (x*x+y*y+z*z)^0.5","\tx,y,z = x/length, y/length, z/length","","\treturn wrap( { (ca + (x^2)*(1-ca)) * x2 + (x*y*(1-ca) - z*sa) * y2 + (x*z*(1-ca) + y*sa) * z2,","\t\t\t(y*x*(1-ca) + z*sa) * x2 + (ca + (y^2)*(1-ca)) * y2 + (y*z*(1-ca) - x*sa) * z2,","\t\t\t(z*x*(1-ca) - y*sa) * x2 + (z*y*(1-ca) + x*sa) * y2 + (ca + (z^2)*(1-ca)) * z2 } )","end",""],"class":"function","name":"vec_methods.rotateAroundAxis","summary":"\nReturn rotated vector by an axis ","private":false,"classlib":"Vector","description":"\nReturn rotated vector by an axis","param":{"1":"a","2":"axis","3":"degrees","4":"radians","radians":"Angle to rotate by in radians or nil if degrees.","degrees":"Angle to rotate by in degrees or nil if radians.","axis":"Axis the rotate around"}},"sub":{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods.sub ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] - v[1]","\ta[2] = a[2] - v[2]","\ta[3] = a[3] - v[3]","end",""],"class":"function","name":"vec_methods.sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector."}},"withinAABox":{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods.withinAABox ( a, v1, v2 )","\tSF.CheckType( v1, vec_metamethods )","\tSF.CheckType( v2, vec_metamethods )","","\tif a[1] < v1[1] or a[1] > v2[1] then return false end","\tif a[2] < v1[2] or a[2] > v2[2] then return false end","\tif a[3] < v1[3] or a[3] > v2[3] then return false end","","\treturn true","end"],"class":"function","name":"vec_methods.withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"a","2":"v1","3":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}},"toScreen":{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods.toScreen ( a )","\treturn unwrap( a ):ToScreen()","end",""],"class":"function","name":"vec_methods.toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":["a"]},"set":{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods.set ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = v[1]","\ta[2] = v[2]","\ta[3] = v[3]","end",""],"class":"function","name":"vec_methods.set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"a","2":"v","v":"Second Vector"}},"isZero":{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"vec_methods.isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":["a"]},"getNormalized":{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods.getNormalized ( a )","\tlocal len = math_sqrt( a[1]^2 + a[2]^2 + a[3]^2 )","","\treturn wrap( { a[1] / len, a[2] / len, a[3] / len } )","end",""],"class":"function","name":"vec_methods.getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":["a"]},"mul":{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods.mul ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] * n","\ta[2] = a[2] * n","\ta[3] = a[3] * n","end",""],"class":"function","name":"vec_methods.mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to multiply with."}},"vdiv":{"comment":["--- Divide self by a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to divide by"],"code":["function vec_methods.vdiv ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] / v[1]","\ta[2] = a[2] / v[2]","\ta[3] = a[3] / v[3]","end",""],"class":"function","name":"vec_methods.vdiv","summary":"\nDivide self by a Vector.","private":false,"classlib":"Vector","description":"\nDivide self by a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to divide by"}},"div":{"ret":"nil","comment":["--- \"Scalar Division\" of the vector. Self-Modifies.","-- @param n Scalar to divide by.","-- @return nil"],"code":["function vec_methods.div ( a, n )","\tSF.CheckType( n, \"number\" )","","\ta[1] = a[1] / n","\ta[2] = a[2] / n","\ta[3] = a[3] / n","end",""],"class":"function","name":"vec_methods.div","summary":"\n\"Scalar Division\" of the vector.","private":false,"classlib":"Vector","description":"\n\"Scalar Division\" of the vector. Self-Modifies.","param":{"1":"a","2":"n","n":"Scalar to divide by."}},"getLengthSqr":{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods.getLengthSqr ( a )","\treturn ( a[1]^2 + a[2]^2 + a[3]^2 )","end",""],"class":"function","name":"vec_methods.getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":["a"]},"vmul":{"comment":["--- Multiply self with a Vector. Self-Modifies. ( convenience function )","-- @param v Vector to multiply with"],"code":["function vec_methods.vmul ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] * v[1]","\ta[2] = a[2] * v[2]","\ta[3] = a[3] * v[3]","end",""],"class":"function","name":"vec_methods.vmul","summary":"\nMultiply self with a Vector.","private":false,"classlib":"Vector","description":"\nMultiply self with a Vector. Self-Modifies. ( convenience function )","param":{"1":"a","2":"v","v":"Vector to multiply with"}},"cross":{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods.cross ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn wrap( { a[2]*v[3] - a[3]*v[2], a[3]*v[1] - a[1]*v[3], a[1]*v[2] - a[2]*v[1] } )","end","","local math_sqrt = math.sqrt",""],"class":"function","name":"vec_methods.cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},"getAngleEx":{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods.getAngleEx ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn SF.WrapObject( unwrap( a ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods.getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"a","2":"v","v":"Second Vector"}},"rotate":{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods.rotate ( a, b )","\tSF.CheckType( b, SF.Types[ \"Angle\" ] )","","\tlocal vec = unwrap( a )","\tvec:Rotate( SF.UnwrapObject( b ) )","","\ta[1] = vec.x","\ta[2] = vec.y","\ta[3] = vec.z","end",""],"class":"function","name":"vec_methods.rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","2":"b","a":"Angle to rotate by."}},"getDistanceSqr":{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods.getDistanceSqr ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\treturn ((v[1]-a[1])^2 + (v[2]-a[2])^2 + (v[3]-a[3])^2)","end",""],"class":"function","name":"vec_methods.getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"a","2":"v","v":"Second Vector"}},"add":{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods.add ( a, v )","\tSF.CheckType( v, vec_metamethods )","","\ta[1] = a[1] + v[1]","\ta[2] = a[2] + v[2]","\ta[3] = a[3] + v[3]","end",""],"class":"function","name":"vec_methods.add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"a","2":"v","v":"Vector to add"}}}},"Vehicle":{"comment":["--- Vehicle type"],"code":["local vehicle_methods, vehicle_metamethods = SF.Typedef(\"Vehicle\", SF.Entities.Metatable)","","SF.Vehicles.Methods = vehicle_methods","SF.Vehicles.Metatable = vehicle_metamethods",""],"typtbl":"vehicle_methods","fields":[],"name":"Vehicle","summary":"\nVehicle type ","description":"\nVehicle type","class":"class","methods":{"1":"ejectDriver","2":"getDriver","3":"getPassenger","getDriver":{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},"ejectDriver":{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},"getPassenger":{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param n The index of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","n":"The index of the passenger to get"}}}},"Entity":{"comment":["--- Entity type","-- @shared"],"code":["local ents_methods, ents_metamethods = SF.Typedef( \"Entity\" )","","local ewrap, eunwrap = SF.CreateWrapper( ents_metamethods, true, true, debug.getregistry().Entity )","local owrap, ounwrap = SF.WrapObject, SF.UnwrapObject","local ang_meta, vec_meta","local vwrap, vunwrap, awrap, aunwrap, cwrap, cunwrap","local isValid = IsValid","","SF.Libraries.AddHook(\"postload\", function()","\tang_meta = SF.Angles.Metatable","\tvec_meta = SF.Vectors.Metatable","","\tvwrap = SF.Vectors.Wrap","\tvunwrap = SF.Vectors.Unwrap","\tawrap = SF.Angles.Wrap","\taunwrap = SF.Angles.Unwrap","\tcwrap = SF.Color.Wrap","\tcunwrap = SF.Color.Unwrap","end)","","-- ------------------------- Internal functions ------------------------- --","","SF.Entities.Wrap = ewrap","SF.Entities.Unwrap = eunwrap","SF.Entities.Methods = ents_methods","SF.Entities.Metatable = ents_metamethods","",""],"typtbl":"ents_methods","summary":"\nEntity type ","fields":[],"name":"Entity","server":true,"description":"\nEntity type","client":true,"class":"class","methods":{"1":"addCollisionListener","2":"applyAngForce","3":"applyDamage","4":"applyForceCenter","5":"applyForceOffset","6":"applyTorque","7":"breakEnt","8":"emitSound","9":"enableDrag","10":"enableGravity","11":"enableMotion","12":"enableSphere","13":"entIndex","14":"extinguish","15":"getAngleVelocity","16":"getAngles","17":"getAttachment","18":"getAttachmentParent","19":"getClass","20":"getColor","21":"getEyeAngles","22":"getEyePos","23":"getForward","24":"getHealth","25":"getInertia","26":"getMass","27":"getMassCenter","28":"getMassCenterW","29":"getMaterial","30":"getMaterials","31":"getMatrix","32":"getMaxHealth","33":"getModel","34":"getOwner","35":"getParent","36":"getPos","37":"getRight","38":"getSkin","39":"getSubMaterial","40":"getUp","41":"getVelocity","42":"ignite","43":"isFrozen","44":"isNPC","45":"isPlayer","46":"isValid","47":"isVehicle","48":"isWeapon","49":"isWeldedTo","50":"linkComponent","51":"localToWorld","52":"localToWorldAngles","53":"lookupAttachment","54":"obbCenter","55":"obbCenterW","56":"obbSize","57":"remove","58":"removeTrails","59":"setAngles","60":"setBodygroup","61":"setColor","62":"setFrozen","63":"setMass","64":"setMaterial","65":"setNoDraw","66":"setNocollideAll","67":"setParent","68":"setPhysMaterial","69":"setPos","70":"setRenderFX","71":"setRenderMode","72":"setSkin","73":"setSolid","74":"setSubMaterial","75":"setTrails","76":"setVelocity","77":"unparent","78":"worldToLocal","79":"worldToLocalAngles","getRight":{"ret":"Vector right","comment":["--- Gets the entity's right vector","-- @shared","-- @return Vector right"],"code":["function ents_methods:getRight ()","\treturn vwrap( eunwrap( self ):GetRight() )","end",""],"class":"function","summary":"\nGets the entity's right vector ","classlib":"Entity","name":"ents_methods:getRight","server":true,"private":false,"client":true,"description":"\nGets the entity's right vector","param":[]},"applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"setNocollideAll":{"comment":["--- Set's the entity to collide with nothing but the world","-- @param nocollide Whether to collide with nothing except world or not."],"code":["function ents_methods:setNocollideAll ( nocollide )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tent:SetCollisionGroup ( nocollide and COLLISION_GROUP_WORLD or COLLISION_GROUP_NONE )","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend,","\t[7] = function( mode ) --Rendermode","\t\tnet.WriteUInt( mode, 8 )","\tend,","\t[8] = function( fx ) --Renderfx","\t\tnet.WriteUInt( fx, 8 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tlocal meta = debug.getmetatable( ply )","\tif meta == SF.Types[ \"Player\" ] then ","\t\tply = unwrap( ply )","\t\tif not ( IsValid( ply ) and ply:IsPlayer() ) then","\t\t\tSF.throw( \"Tried to use invalid player\", 3 )","\t\tend","\telseif meta == nil and type( ply ) == \"table\" then","\t\tlocal ply2 = ply","\t\tply = {}","\t\tfor k, v in pairs( ply2 ) do","\t\t\tlocal p = unwrap( v )","\t\t\tif IsValid( p ) and p:IsPlayer() then","\t\t\t\tply[k] = p","\t\t\telse","\t\t\t\tSF.throw ( \"Invalid player object in table of players\", 3 )","\t\t\tend","\t\tend","\telse","\t\tSF.throw( \"Expected player or table of players.\", 3 )","\tend","\t","\tnet.Start( \"sf_setentityrenderproperty\" )","\tnet.WriteEntity( ent )","\tnet.WriteUInt( func, 4 )","\trenderProperties[ func ]( ... )","\tnet.Send( ply )","end",""],"class":"function","name":"ents_methods:setNocollideAll","summary":"\nSet's the entity to collide with nothing but the world ","private":false,"classlib":"Entity","description":"\nSet's the entity to collide with nothing but the world","param":{"1":"nocollide","nocollide":"Whether to collide with nothing except world or not."}},"setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"isValid":{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( eunwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]},"addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"getAngleVelocity":{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( eunwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn vwrap( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},"getSkin":{"ret":"Skin number","comment":["--- Gets the skin number of the entity","-- @shared","-- @return Skin number"],"code":["function ents_methods:getSkin ()","    local ent = eunwrap( self )","    return ent:GetSkin()","end",""],"class":"function","summary":"\nGets the skin number of the entity ","classlib":"Entity","name":"ents_methods:getSkin","server":true,"private":false,"client":true,"description":"\nGets the skin number of the entity","param":[]},"getAttachmentParent":{"ret":"number index of the attachment the entity is parented to or 0","comment":["--- Gets the attachment index the entity is parented to","-- @shared","-- @return number index of the attachment the entity is parented to or 0"],"code":["function ents_methods:getAttachmentParent()","\tlocal ent = eunwrap(self)","\treturn ent and ent:GetParentAttachment() or 0","end",""],"class":"function","summary":"\nGets the attachment index the entity is parented to ","classlib":"Entity","name":"ents_methods:getAttachmentParent","server":true,"private":false,"client":true,"description":"\nGets the attachment index the entity is parented to","param":[]},"getClass":{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},"obbCenter":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},"getModel":{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},"getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v[1] and v[1] < math.huge and","\t\t\t-math.huge < v[2] and v[2] < math.huge and","\t\t\t-math.huge < v[3] and v[3] < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"getEyePos":{"ret":["Eye position of the entity","In case of a ragdoll, the position of the second eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the second eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal pos1, pos2 = ent:EyePos()","\tif pos2 then","\t\treturn vwrap( pos1 ), vwrap( pos2 )","\tend","\treturn vwrap( pos1 )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},"getColor":{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = eunwrap( self )","\treturn cwrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},"entIndex":{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},"getInertia":{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn vwrap( phys:GetInertia() )","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},"isPlayer":{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},"linkComponent":{"comment":["--- Links starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","-- @param e Entity to link the component to. nil to clear links."],"code":["function ents_methods:linkComponent ( e )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif e then","\t\tSF.CheckType( e, ents_metatable )","\t\tlocal link = unwrap( e )","\t\tif not isValid( link ) then SF.throw( \"Entity is not valid\", 2 ) end","\t\tif not SF.Permissions.check( SF.instance.player, link, \"entities.canTool\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\tif link:GetClass()==\"starfall_processor\" and ( ent:GetClass()==\"starfall_screen\" or ent:GetClass()==\"starfall_hud\" ) then","\t\t\tent:LinkEnt( link )","\t\telseif link:IsVehicle() and ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkVehicle( link )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\telse","\t\tif ent:GetClass()==\"starfall_screen\" then","\t\t\tent:LinkEnt( nil )","\t\telseif ent:GetClass()==\"starfall_hud\" then","\t\t\tent:LinkEnt( nil )","\t\t\tent:LinkVehicle( nil )","\t\telse","\t\t\tSF.throw( \"Invalid Link Entity\", 2 )","\t\tend","\tend","end","",""],"class":"function","name":"ents_methods:linkComponent","summary":"\nLinks starfall components to a starfall processor or vehicle.","private":false,"classlib":"Entity","description":"\nLinks starfall components to a starfall processor or vehicle. Screen can only connect to processor. HUD can connect to processor and vehicle.","param":{"1":"e","e":"Entity to link the component to. nil to clear links."}},"obbSize":{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},"setRenderFX":{"comment":["--- Sets the renderfx of the entity","-- @server","-- @class function","-- @param renderfx Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderFX ( renderfx, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( renderfx, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 8, renderfx )","\telse","\t\tent:SetRenderFX( renderfx )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderFX = renderfx } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the renderfx of the entity ","name":"ents_methods:setRenderFX","classlib":"Entity","private":false,"server":true,"description":"\nSets the renderfx of the entity","param":{"1":"renderfx","2":"ply","renderfx":"Number, renderfx to use. http://wiki.garrysmod.com/page/Enums/kRenderFx","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"worldToLocal":{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},"localToWorld":{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, vec_meta )","\tlocal ent = eunwrap( self )","\t","\treturn vwrap( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},"getAttachment":{"ret":"vector position, and angle orientation","comment":["--- Gets the position and angle of an attachment","-- @shared","-- @param index The index of the attachment","-- @return vector position, and angle orientation"],"code":["function ents_methods:getAttachment(index)","\tlocal ent = eunwrap(self)","\tif ent then","\t\tlocal t = ent:GetAttachment(index)","\t\tif t then","\t\t\treturn vwrap(t.Pos), awrap(t.Ang)","\t\tend","\tend","end",""],"class":"function","summary":"\nGets the position and angle of an attachment ","classlib":"Entity","name":"ents_methods:getAttachment","server":true,"private":false,"client":true,"description":"\nGets the position and angle of an attachment","param":{"1":"index","index":"The index of the attachment"}},"applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"lookupAttachment":{"ret":"number of the attachment index, or 0 if it doesn't exist","comment":["--- Gets the attachment index via the entity and it's attachment name","-- @shared","-- @param name","-- @return number of the attachment index, or 0 if it doesn't exist"],"code":["function ents_methods:lookupAttachment(name)","\tlocal ent = eunwrap(self)","\treturn ent and ent:LookupAttachment(name) or 0","end",""],"class":"function","summary":"\nGets the attachment index via the entity and it's attachment name ","classlib":"Entity","name":"ents_methods:lookupAttachment","server":true,"private":false,"client":true,"description":"\nGets the attachment index via the entity and it's attachment name","param":{"1":"name","name":""}},"setTrails":{"comment":["--- Adds a trail to the entity with the specified attributes.","-- @param startSize The start size of the trail","-- @param endSize The end size of the trail","-- @param length The length size of the trail","-- @param material The material of the trail","-- @param color The color of the trail","-- @param attachmentID Optional attachmentid the trail should attach to","-- @param additive If the trail's rendering is additive"],"code":["function ents_methods:setTrails(startSize, endSize, length, material, color, attachmentID, additive)","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( material, \"string\" )","\t","\tlocal ent = unwrap( self )","","\tif string.find(material, '\"', 1, true) then SF.throw( \"Invalid Material\", 2 ) end","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal Data = {","\t\tColor = SF.Color.Unwrap( color ),","\t\tLength = length,","\t\tStartSize = math.Clamp( startSize, 0, 128 ),","\t\tEndSize = math.Clamp( endSize, 0, 128 ),","\t\tMaterial = material,","\t\tAttachmentID = attachmentID,","\t\tAdditive = additive,","\t}","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, Data)","end",""],"class":"function","name":"ents_methods:setTrails","summary":"\nAdds a trail to the entity with the specified attributes.","private":false,"classlib":"Entity","description":"\nAdds a trail to the entity with the specified attributes.","param":{"1":"startSize","2":"endSize","3":"length","4":"material","5":"color","6":"attachmentID","7":"additive","startSize":"The start size of the trail","length":"The length size of the trail","attachmentID":"Optional attachmentid the trail should attach to","color":"The color of the trail","material":"The material of the trail","endSize":"The end size of the trail","additive":"If the trail's rendering is additive"}},"getMatrix":{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = eunwrap( self )","\treturn owrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},"setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","\t","\tif not check( vel ) then SF.throw( \"infinite vector\", 2) end","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local shaderBlacklist = {","\t[ \"LightmappedGeneric\" ] = true,","}","local function invalidMaterial( material )","\tif string.find( string.lower( material ) , \"pp[%./\\\\]+copy\" ) then return true end","\tlocal mat = Material( material )","\tif mat and shaderBlacklist[ mat:GetShader() ] then return true end","end",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"isWeapon":{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]},"breakEnt":{"comment":["--- Invokes the entity's breaking animation and removes it."],"code":["function ents_methods:breakEnt ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() or ent:IsFlagSet( FL_KILLME ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:AddFlags( FL_KILLME )","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:breakEnt","summary":"\nInvokes the entity's breaking animation and removes it.","private":false,"classlib":"Entity","description":"\nInvokes the entity's breaking animation and removes it.","param":[]},"getEyeAngles":{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},"ignite":{"comment":["--- Ignites an entity","-- @param length How long the fire lasts","-- @param radius (optional) How large the fire hitbox is (entity obb is the max)"],"code":["function ents_methods:ignite( length, radius )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( length, \"number\" )","","\tlocal ent = unwrap( self )","","\tif radius then","\t\tSF.CheckType( radius, \"number\" )","\t\tlocal obbmins, obbmaxs = ent:OBBMins(), ent:OBBMaxs()","\t\tradius = math.Clamp( radius, 0, (obbmaxs.x - obbmins.x + obbmaxs.y - obbmins.y) / 2 )","\tend","","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Ignite( length, radius )","end",""],"class":"function","name":"ents_methods:ignite","summary":"\nIgnites an entity ","private":false,"classlib":"Entity","description":"\nIgnites an entity","param":{"1":"length","2":"radius","radius":"(optional) How large the fire hitbox is (entity obb is the max)","length":"How long the fire lasts"}},"getMaterials":{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = eunwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},"isVehicle":{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},"setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"worldToLocalAngles":{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},"getVelocity":{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn vwrap( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},"setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tlocal rendermode = ( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { Color = clr, RenderMode = rendermode } )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set only for that player. Can also be table of players."}},"isNPC":{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn eunwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},"applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},"getForward":{"ret":"Vector forward","comment":["--- Gets the entity's forward vector","-- @shared","-- @return Vector forward"],"code":["function ents_methods:getForward ()","\treturn vwrap( eunwrap( self ):GetForward() )","end"],"class":"function","summary":"\nGets the entity's forward vector ","classlib":"Entity","name":"ents_methods:getForward","server":true,"private":false,"client":true,"description":"\nGets the entity's forward vector","param":[]},"getUp":{"ret":"Vector up","comment":["--- Gets the entity's up vector","-- @shared","-- @return Vector up"],"code":["function ents_methods:getUp ()","\treturn vwrap( eunwrap( self ):GetUp() )","end",""],"class":"function","summary":"\nGets the entity's up vector ","classlib":"Entity","name":"ents_methods:getUp","server":true,"private":false,"client":true,"description":"\nGets the entity's up vector","param":[]},"isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end","",""],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if invalidMaterial( material ) then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\t\tduplicator.StoreEntityModifier( ent, \"material\", { MaterialOverride = material } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","material":", string, New material name."}},"getMass":{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},"getMaxHealth":{"ret":"Max Health of the entity","comment":["--- Gets the max health of an entity","-- @shared","-- @return Max Health of the entity"],"code":["function ents_methods:getMaxHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:GetMaxHealth()","end",""],"class":"function","summary":"\nGets the max health of an entity ","classlib":"Entity","name":"ents_methods:getMaxHealth","server":true,"private":false,"client":true,"description":"\nGets the max health of an entity","param":[]},"extinguish":{"comment":["--- Extinguishes an entity"],"code":["function ents_methods:extinguish()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.ignite\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Extinguish()","end",""],"class":"function","name":"ents_methods:extinguish","summary":"\nExtinguishes an entity ","private":false,"classlib":"Entity","description":"\nExtinguishes an entity","param":[]},"setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set only for that player. Can also be table of players.","bodygroup":"Number, The ID of the bodygroup you're setting."}},"enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"getAngles":{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn awrap( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},"enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"enableSphere":{"comment":["--- Sets the physics of an entity to be a sphere","-- @param enabled Bool should the entity be spherical?"],"code":["function ents_methods:enableSphere ( enabled )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\t","\tif ent:GetClass() ~= \"prop_physics\" then SF.throw( \"This function only works for prop_physics\", 2 ) end","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tlocal ismove = phys:IsMoveable()","\tlocal mass = phys:GetMass()","\t","\tif enabled then","\t\tif ent:GetMoveType() == MOVETYPE_VPHYSICS then","\t\t\tlocal OBB = ent:OBBMaxs() - ent:OBBMins()","\t\t\tlocal radius = math.max( OBB.x, OBB.y, OBB.z) / 2 ","\t\t\tent:PhysicsInitSphere( radius, phys:GetMaterial() )","\t\t\tent:SetCollisionBounds( Vector( -radius, -radius, -radius ) , Vector( radius, radius, radius ) )","\t\tend","\telse","\t\tif ent:GetMoveType() ~= MOVETYPE_VPHYSICS then","\t\t\tent:PhysicsInit( SOLID_VPHYSICS )","\t\t\tent:SetMoveType( MOVETYPE_VPHYSICS )","\t\t\tent:SetSolid( SOLID_VPHYSICS )","\t\tend","\tend","\t","\t-- New physobject after applying spherical collisions","\tlocal phys = ent:GetPhysicsObject()","\tphys:SetMass( mass )","\tphys:EnableMotion( ismove )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableSphere","summary":"\nSets the physics of an entity to be a sphere ","private":false,"classlib":"Entity","description":"\nSets the physics of an entity to be a sphere","param":{"1":"enabled","enabled":"Bool should the entity be spherical?"}},"localToWorldAngles":{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, ang_meta )","\tlocal ent = eunwrap( self )","\tlocal data = aunwrap( data )","\t","\treturn awrap( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},"setPhysMaterial":{"comment":["--- Sets the physical material of the entity","-- @param mat Material to use"],"code":["function ents_methods:setPhysMaterial( mat )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( mat, \"string\" )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tconstruct.SetPhysProp( nil, ent, 0, phys, {Material = mat} ) ","end",""],"class":"function","name":"ents_methods:setPhysMaterial","summary":"\nSets the physical material of the entity ","private":false,"classlib":"Entity","description":"\nSets the physical material of the entity","param":{"1":"mat","mat":"Material to use"}},"getMaterial":{"ret":"String material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getMaterial ()","    local ent = eunwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},"getSubMaterial":{"ret":"String material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return String material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = eunwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},"emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"getParent":{"ret":"Entity's parent or nil","comment":["--- Gets the parent of an entity","-- @shared","-- @return Entity's parent or nil"],"code":["function ents_methods:getParent()","\tlocal ent = eunwrap(self)","\treturn ent and ewrap(ent:GetParent())","end",""],"class":"function","summary":"\nGets the parent of an entity ","classlib":"Entity","name":"ents_methods:getParent","server":true,"private":false,"client":true,"description":"\nGets the parent of an entity","param":[]},"removeTrails":{"comment":["--- Removes trails from the entity"],"code":["function ents_methods:removeTrails()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tif not IsValid(ent) then SF.throw( \"Invalid Entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tduplicator.EntityModifiers.trail(SF.instance.player, ent, nil)","end",""],"class":"function","name":"ents_methods:removeTrails","summary":"\nRemoves trails from the entity ","private":false,"classlib":"Entity","description":"\nRemoves trails from the entity","param":[]},"getMassCenter":{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},"applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\t","\tlocal ang = SF.UnwrapObject( ang )","\tlocal ent = unwrap( self )","\t","\tif not check( ang ) then SF.throw( \"infinite angle\", 2) end","\t","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to","-- @param attachment Optional string attachment name to parent to"],"code":["function ents_methods:setParent ( ent, attachment )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ent, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) and not ent:IsPlayer() then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","\tif attachment then","\t\tSF.CheckType(attachment, \"string\")","\t\tthis:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\tend","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","2":"attachment","ent":"Entity to parent to","attachment":"Optional string attachment name to parent to"}},"obbCenterW":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},"setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"getHealth":{"ret":"Health of the entity","comment":["--- Gets the health of an entity","-- @shared","-- @return Health of the entity"],"code":["function ents_methods:getHealth ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn ent:Health()","end",""],"class":"function","summary":"\nGets the health of an entity ","classlib":"Entity","name":"ents_methods:getHealth","server":true,"private":false,"client":true,"description":"\nGets the health of an entity","param":[]},"getPos":{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\treturn vwrap( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},"setRenderMode":{"comment":["--- Sets the rende mode of the entity","-- @server","-- @class function","-- @param rendermode Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE","-- @param ply Optional player arguement to set only for that player. Can also be table of players."],"code":["function ents_methods:setRenderMode ( rendermode, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( rendermode, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 7, rendermode )","\telse","\t\tent:SetRenderMode( rendermode )","\t\tduplicator.StoreEntityModifier( ent, \"colour\", { RenderMode = rendermode } )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the rende mode of the entity ","name":"ents_methods:setRenderMode","classlib":"Entity","private":false,"server":true,"description":"\nSets the rende mode of the entity","param":{"1":"rendermode","2":"ply","ply":"Optional player arguement to set only for that player. Can also be table of players.","rendermode":"Number, rendermode to use. http://wiki.garrysmod.com/page/Enums/RENDERMODE"}},"getMassCenterW":{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = eunwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn vwrap( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]}}},"Angle":{"comment":["--- Angle Type","-- @shared"],"code":["local ang_methods, ang_metamethods = SF.Typedef( \"Angle\" )","","local function wrap( tbl )","\treturn setmetatable( tbl, ang_metamethods )","end","","local function unwrap( obj )","\treturn Angle( obj[1], obj[2], obj[3] )","end","","local function awrap( ang )","\treturn wrap( { ang.pitch, ang.yaw, ang.roll } )","end","","SF.AddObjectWrapper( debug.getregistry().Angle, ang_metamethods, awrap )","SF.AddObjectUnwrapper( ang_metamethods, unwrap )","","SF.DefaultEnvironment.Angle = function ( p, y, r )","\treturn wrap( { p or 0, y or 0, r or 0 } )","end","","SF.Angles.Wrap \t= awrap","SF.Angles.Unwrap = unwrap","SF.Angles.Methods = ang_methods","SF.Angles.Metatable = ang_metamethods","","local dgetmeta = debug.getmetatable","","-- Lookup table.","-- Index 1->6 have associative pyr for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","local pyr = { p = 1, y = 2, r = 3, pitch = 1, yaw = 2, roll = 3 }",""],"typtbl":"ang_methods","summary":"\nAngle Type ","fields":[],"name":"Angle","server":true,"description":"\nAngle Type","client":true,"class":"class","methods":{"1":"getForward","2":"getNormalized","3":"getRight","4":"getUp","5":"isZero","6":"normalize","7":"rotateAroundAxis","8":"set","9":"setZero","getRight":{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getRight ( a )","\treturn SF.WrapObject( unwrap( a ):Right() )","end",""],"class":"function","name":"ang_methods.getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":["a"]},"set":{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods.set ( a, b )","\tSF.CheckType( b, ang_metamethods )","","\ta[1] = (b[1] or 0)","\ta[2] = (b[2] or 0)","\ta[3] = (b[3] or 0)","end",""],"class":"function","name":"ang_methods.set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","2":"b","a":"Angle to copy from."}},"isZero":{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods.isZero ( a )","\tif a[1] ~= 0 then return false","\telseif a[2] ~= 0 then return false","\telseif a[3] ~= 0 then return false","\tend","","\treturn true","end",""],"class":"function","name":"ang_methods.isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":["a"]},"getNormalized":{"ret":"Normalized angle table","comment":["--- Returnes a normalized angle","-- @return Normalized angle table"],"code":["function ang_methods.getNormalized ( a )","\tSF.CheckType( a, ang_metamethods )","\treturn wrap( normalizedAngTable( a ) )","end",""],"class":"function","name":"ang_methods.getNormalized","summary":"\nReturnes a normalized angle ","private":false,"classlib":"Angle","description":"\nReturnes a normalized angle","param":["a"]},"normalize":{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods.normalize ( a )","\ta[1] = math_nAng( a[1] )","\ta[2] = math_nAng( a[2] )","\ta[3] = math_nAng( a[3] )","end",""],"class":"function","name":"ang_methods.normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":["a"]},"getForward":{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods.getForward ( a )","\treturn SF.WrapObject( unwrap( a ):Forward() )","end",""],"class":"function","name":"ang_methods.getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":["a"]},"setZero":{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods.setZero ( a )","\ta[1] = 0","\ta[2] = 0","\ta[3] = 0","end"],"class":"function","name":"ang_methods.setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":["a"]},"getUp":{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods.getUp ( a )","\treturn SF.WrapObject( unwrap( a ):Up() )","end",""],"class":"function","name":"ang_methods.getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":["a"]},"rotateAroundAxis":{"ret":"The modified angle","comment":["--- Return Rotated angle around the specified axis.","-- @param v Vector axis","-- @param deg Number of degrees or nil if radians.","-- @param rad Number of radians or nil if degrees.","-- @return The modified angle"],"code":["function ang_methods.rotateAroundAxis ( a, v, deg, rad )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","","\tif rad then","\t\tSF.CheckType( rad, \"number\" )","\t\tdeg = math.deg( rad )","\telse","\t\tSF.CheckType( deg, \"number\" )","\tend","","\tlocal ret = Angle()","","\tret:Set( unwrap( a ) )","\tret:RotateAroundAxis( SF.UnwrapObject( v ), deg )","","\treturn awrap( ret )","end",""],"class":"function","name":"ang_methods.rotateAroundAxis","summary":"\nReturn Rotated angle around the specified axis.","private":false,"classlib":"Angle","description":"\nReturn Rotated angle around the specified axis.","param":{"1":"a","2":"v","3":"deg","4":"rad","rad":"Number of radians or nil if degrees.","deg":"Number of degrees or nil if radians.","v":"Vector axis"}}}},"Sound":{"comment":["--- Sound type","-- @shared"],"code":["local sound_methods, sound_metamethods = SF.Typedef( \"Sound\" )","local wrap, unwrap = SF.CreateWrapper( sound_metamethods, true, false, debug.getregistry().CSoundPatch )",""],"typtbl":"sound_methods","summary":"\nSound type ","fields":[],"name":"Sound","server":true,"description":"\nSound type","client":true,"class":"class","methods":{"1":"isPlaying","2":"play","3":"setPitch","4":"setSoundLevel","5":"setVolume","6":"stop","setSoundLevel":{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}},"stop":{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},"isPlaying":{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},"play":{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}}}},"Weapon":{"comment":["--- Weapon type"],"code":["local weapon_methods, weapon_metamethods = SF.Typedef(\"Weapon\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Weapons.Methods = weapon_methods","SF.Weapons.Metatable = weapon_metamethods",""],"typtbl":"weapon_methods","fields":[],"name":"Weapon","summary":"\nWeapon type ","description":"\nWeapon type","class":"class","methods":{"1":"clip1","2":"clip2","3":"getActivity","4":"getHoldType","5":"getNextPrimaryFire","6":"getNextSecondaryFire","7":"getPrimaryAmmoType","8":"getPrintName","9":"getSecondaryAmmoType","10":"isCarriedByLocalPlayer","11":"isWeaponVisible","12":"lastShootTime","lastShootTime":{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},"getNextPrimaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},"clip2":{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},"isCarriedByLocalPlayer":{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]},"getSecondaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},"clip1":{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]},"getActivity":{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},"getPrintName":{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},"getPrimaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},"getNextSecondaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},"getHoldType":{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},"isWeaponVisible":{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]}}}},"examples":{"fireplace.lua":"--@name Fireplace\n--@author INP - Radon\n--@include lib/class.txt\n\nif SERVER then return end\n\n-- Credits to Natty for original fireplace idea as an example\n-- Credits to funkake for working out the kinks\n\n-- We'll require our Class library, courtesy of Xandaros\n-- Latest version of Class Lib: https://gist.github.com/Xandaros/ea8756e4c4ba00218855\n\n-- It makes a global called Class()\nrequire( \"lib/class.txt\" )\n\n-- We'll call Particle as our constructor\nlocal Particle = Class()\n\n-- Let's add our constructor definition\nfunction Particle:constructor ( x, y, scale, xv, yv, clr )\n    -- Just standard assignment, we want to make sure we get all the properties.\n    -- If one of the params is nil, then the default value, 0, will be assigned.\n    self.x = x or 0\n    self.y = y or 0\n    self.scale = scale or 0\n    self.x_vel = xv or 0\n    self.y_vel = yv or 0\n    self.color = clr or Color( 0, 0, 0 )\nend\n\n-- A think method, we'll use this to change particle states.\nfunction Particle:think ()\n    -- We draw first, then change state.\n\n    self:draw()\n\n    self.x = self.x + self.x_vel\n    self.y = self.y + self.y_vel\n\n    self.y_vel = self.y_vel - math.random( 0, 0.04 )\n\n    self.color.a = self.color.a - math.random( 1.5, 3 )\n\n    local c = self.color.g - math.random( 0.65, 0.95 )\n    self.color.g = c > 0 and c or 0\n\n    local c = self.color.r + math.random( 0.4, 0.6 )\n    self.color.r = c < 255 and c or 255\n\n    self.scale = self.scale - math.random( 0.20, 0.30 )\nend\n\n-- draw method so that each pixel can be drawn by itself.\nfunction Particle:draw ()\n    render.setColor( self.color )\n    render.drawRect( self.x + 256, self.y + 480, self.scale, self.scale )\nend\n\n-- Little table to store some information about the display.\nlocal game = {}\ngame.particles = {}\n\n-- Timers, we'll use these to spawn new particles and to draw our current ones.\n-- This helps us keep constant time when rendering.\nlocal t = timer.systime()\nlocal t2 = timer.systime()\n\nhook.add( \"render\", \"\", function ()\n\n    if timer.systime() > t then\n        for i = 1, math.random( 4, 10 ) do\n\n            -- Make a new particle using our constructor.\n            local nP = Particle(\n                math.random( -256, 256 ),\n                math.random( -64, 32 ),\n                math.random( 40, 80 ),\n                math.random() * 5 - 2,\n                -math.random() * 3,\n                Color( math.random( 200, 230 ), math.random( 100, 130 ), 0, math.random( 120, 255 ) )\n                )\n\n            -- Add our newly made particle to a table of game particles\n            table.insert( game.particles, nP )\n\n        end\n\n        -- Increase our timer for our next spawn time.\n        t = timer.systime() + ( 1 / 20 )\n    end\n\n    if timer.systime() > t2 then\n\n        game.relVel = entities.self():worldToLocal( entities.self():getPos() + entities.self():getVelocity() )\n\n        -- Clear the board before rendering anything new\n        render.clear( Color( 5, 5, 16 ) )\n\n        for k, v in pairs( game.particles ) do\n            -- Now iterate over all our particles and check if they should be removed.\n            if v.color.a <= 0 then table.remove( game.particles, k ) continue end\n\n            -- This is responsible for moving our flames if we shake our screen.\n            -- Moves sprites based upon their scale.\n            v.x_vel = v.x_vel - ( game.relVel.y * ( 1/ 5000 ) * ( 80 / v.scale ) )\n            v.y_vel = v.y_vel - ( game.relVel.x * ( 1/ 2000 ) * ( 80 / v.scale ) )\n\n            -- We only need to think.\n            -- Our function draws before thinking, so we're fine.\n            v:think()\n        end\n\n        -- Increase our timer for our next draw time.\n        t2 = timer.systime() + ( 1 / 120 )\n    end\nend )\n","coroutine.lua":"--@name Coroutine Example\n--@author Radon\n\nif not SERVER then return end\n\n-- Some functions for checking our quota usage.\nlocal function checkQ ( n )\n    return quotaUsed() < quotaMax() * n\nend\n\n-- Check if we should yield\nlocal function yieldCheck ()\n    if not checkQ( 0.95 ) then\n        coroutine.yield()\n    end\nend\n\n-- Create the coroutine\n-- The Function here is \"Sieve of Eratosthenes\" and is used to find Primes up to a given integer.\nlocal erato = coroutine.create( function ( n )\n\n        local time = timer.systime()\n        if n < 2 then return {} end\n        local t = { 0 } -- clears '1'\n        local sqrtlmt = math.sqrt( n )\n\n        for i = 2, n do\n            -- Because we're in a for loop, best make sure we check to yield.\n            yieldCheck()\n            t[ i ] = 1\n        end\n\n        for i = 2, sqrtlmt do\n            if t[ i ] ~= 0 then\n                -- Because we're in a for loop, best make sure we check to yield.\n                yieldCheck()\n                for j = i * i, n, i do\n                    -- Because we're in a for loop, best make sure we check to yield.\n                    yieldCheck()\n                    t[ j ] = 0\n                end\n            end\n        end\n\n        local primes = {}\n        for i = 2, n do\n            -- Because we're in a for loop, best make sure we check to yield.\n            yieldCheck()\n            if t[ i ] ~= 0 then\n                table.insert( primes, i )\n            end\n        end\n\n        -- Finally we want to return our table of primes we've generated.\n        -- Therefore we yield but pass it the table to yield back.\n        print( ( timer.systime() - time ) .. \" seconds to complete\" )\n        coroutine.yield( primes )\nend )\n\nhook.add( \"think\", \"primeNumbers\", function ()\n    -- If the coroutine isn't running and hasn't died, then we need to start it or resume it.\n    if coroutine.status( erato ) ~= \"running\" and coroutine.status( erato ) ~= \"dead\" then\n        -- Make sure we're sufficiently below quota to resume\n        if checkQ( 0.1 ) then\n            -- r will be nil until the final yield which gives us our primes.\n            -- This will start / resume the coroutine.\n            local r = coroutine.resume( erato, 5000000 )\n\n            -- Therefore we check if it's not nil, and print the highest prime.\n            if r then\n                print( \"Highest prime: \" .. r[ #r ] )\n            end\n        end\n    end\n\n    -- Since we've finished calculating all our primes, remove our think hook.\n    if coroutine.status( erato ) == \"dead\" then\n        hook.remove( \"think\", \"primeNumbers\" )\n    end\nend )\n","include.lua":"--@name Include\n--@author INP\n--@include examples/processor/lib/included.txt\n\nlocal value = require( \"examples/processor/lib/included.txt\" ) -- Note the include above\nprintHelloWorld() -- Call global function from included file\nprint( value ) -- Print returned value\n","console.lua":"--@name Console\n--@author Sparky\n\nif SERVER then\n    \n    wire.adjustInputs({\"Keyboard\",\"Console\"},{\"Wirelink\",\"Wirelink\"})\n    \n    hook.add(\"input\",\"getwirelinks\",function(name, val)\n        if name == \"Console\" then\n            Console = val\n        elseif name == \"Keyboard\" then\n            Keyboard = val\n        end\n    end)\n    \n    local ConsolePos = 0\n    local ConsoleInit = false\n    \n    local function updateCursor()\n        Console[2045] = ConsolePos\n        Console[2046] = 1\n    end\n    local function cls()\n        Console[2041] = 1\n        ConsolePos = 0\n        updateCursor()\n    end\n    local function cout(str, color)\n        for I=1, #str do\n            if str[I] == \"\\n\" then\n                while ConsolePos % 60 ~= 0 do\n                    Console[ConsolePos] = 0\n                    ConsolePos = ConsolePos + 2\n                end\n            else\n                Console[ConsolePos] = str:byte(I)\n                Console[ConsolePos+1] = color or 999\n                ConsolePos = ConsolePos + 2\n            end\n        end\n        updateCursor()\n    end\n    local cincb, cinstart\n    local function cin(cb)\n        cinstart = ConsolePos\n        cincb = cb\n    end\n    local function getcin()\n        local chars = {}\n        for I=cinstart, ConsolePos-2, 2 do\n            chars[#chars + 1] = string.char(Console[I])\n        end\n        return table.concat(chars)\n    end\n    \n    key_funcs = {\n        [127] = function()\n            Console[ConsolePos] = 0\n            updateCursor()\n            ConsolePos = math.max(ConsolePos - 2, cinstart)\n        end,\n        [9] = function() end,\n        [13] = function() \n            if cincb then\n                local str = getcin()\n                cout(\"\\n\")\n                cincb(str)\n                cincb = nil\n            end\n        end,\n        [154] = function() end,\n        [155] = function() end,\n        [158] = function() end,\n        [159] = function() end,\n    }\n    key_funcs[142] = key_funcs[13]\n    \n    local function main_loop()\n        if not Keyboard or not Console then\n            Initialized = false\n        else\n            if not Initialized then\n                Initialized = true\n                cls()\n                main()\n            end\n            while Keyboard[0] > 0 do\n                if cincb then\n                    if key_funcs[Keyboard[1]] then key_funcs[Keyboard[1]]()\n                    else\n                        --print(Keyboard[1])\n                        Console[ConsolePos] = Keyboard[1]\n                        Console[ConsolePos+1] = 999\n                        \n                        ConsolePos = ConsolePos + 2\n                        updateCursor()\n                    end\n                end\n            \n                Keyboard[0] = 0\n            end\n        end\n    end\n    hook.add(\"Think\",\"Mainloop\",main_loop)\n\n    function main()\n        cout(\"Type hello: \")\n        cin(function(str)\n            if str == \"hello\" then\n                cout(\"Hi!\\n\")\n            else\n                cout(\"WRONG!!!\\n\",800999)\n            end\n            timer.simple(0,main)\n        end)\n    end\nend\n","screencpuTime.lua":"--@name cpuTime Example\n--@author INP - Radon + Sparky\n\nif SERVER then return end\n\n-- This function helps us check if we can run.\n-- Use a mixture of quotaUsed() and quotaAverage()\n-- quotaUsed() returns the value of the current buffer.\n-- quotaAverage() gives the cpuTime average across the whole buffer.\n-- You chip will quota if quotaAverage() > quotaMax()\n-- n is a parameter between 0 and 1 that represents the percent. 0.8 = 80%.\nlocal function quotaCheck ( n )\n    return ( quotaUsed() < quotaMax() * n ) and ( quotaAverage() < quotaMax() )\nend\n\n-- Round function to certain dp.\nlocal function round ( num, idp )\n  local mult = 10 ^ ( idp or 0 )\n  return math.floor( num * mult + 0.5 ) / mult\nend\n\nlocal rt = render.createRenderTarget( \"Background\" )\n-- Standard render hook, see hooks.\nhook.add( \"render\", \"\", function ()\n    render.setColor( Color( 255, 255, 255 ) )    \n    -- Print some stats to the screen\n    render.drawText( 10, 10, \"Quota Used: \" .. round( quotaUsed()*1000000 ) .. \"us\" )\n    render.drawText( 10, 30, \"Quota Avg: \" .. round( quotaAverage()*1000000 ) .. \"us\" )\n    render.drawText( 10, 50, \"Quota Max: \" .. round( quotaMax()*1000000 ) .. \"us\" )\n    render.drawText( 10, 70, \"Percent: \" .. round( quotaAverage() / quotaMax() * 100, 2 ) .. \"%\" )\n    \n\t-- Set the rendertarget to our background so that we can make a bluring effect\n\trender.selectRenderTarget( \"Background\" )\n    render.setColor( Color( 0, 0, 0, 50 ) )\n    render.drawRect( 0, 0, 1024, 1024 )\n\t\n    -- While our quota is less than 2 percent.\n    -- This will result in higher FPS, thus more render calls.\n    -- You'd think this would affect the rendering of the cube, it doesn't.\n    -- If you increase this check to 99%, FPS will significantly drop, and the movement would be slower.\n    -- Play with this value and see the effects on percentage and your FPS.\n    while( quotaCheck( 0.01 ) ) do\n        -- Now we can draw a funky box that oscillates back and forth in the middle of the screen.\n        render.setColor( Color( math.random( 100, 255 ), math.random( 100, 255 ), math.random( 100, 255 ) ) )\n        render.drawRect( math.sin( timer.curtime()*2 ) * 380 + ( 512 - 100 ), 512 / 2, 200, 400 )\n    end\n    render.selectRenderTarget( nil )\n    \n\t-- Draw the resulting rendertarget\n    render.setRenderTargetTexture( \"Background\" )\n    render.setColor( Color( 255, 255, 255 ) )\n    render.drawTexturedRect( 0, 128, 512, 384 )\nend)\n","class.lua":"--@name Class\n--@author Xandaros\n\n--Class library, most recent version can be found here: https://gist.github.com/Xandaros/ea8756e4c4ba00218855\n\nlocal function callConstructor(class, obj, ...)\n    local meta = getmetatable(class)\n    if meta.__super then\n        if class.superArgs then\n            callConstructor(meta.__super, obj, class.superArgs(...))\n        else\n            callConstructor(meta.__super, obj)\n        end\n    end\n    if class.constructor then\n        class.constructor(obj, ...)\n    end\nend\n\nlocal function instantiate(class, ...)\n    local ret = setmetatable({}, {\n        __index = class\n    })\n    callConstructor(class, ret, ...)\n    return ret\nend\n\nfunction Class(name, superclass)\n    local ret = {}\n    setmetatable(ret, {\n        __index = function(self, key)\n            if key ~= \"constructor\" and superclass then\n                return superclass[key]\n            end\n            return nil\n        end,\n        __super = superclass,\n        __call = instantiate,\n        __tostring = function() return name or \"unknown\" end\n    })\n    return ret\nend\n","sync.lua":"--@name Sync\n--@author INP\n\nif SERVER then\n    -- Code only executed on the server\n    local randomNumber = math.floor( math.random() * 100 )\n\n    hook.add( \"net\", \"uniqueHookNameHere\", function ( name, len, ply )\n        -- ply being the client that sent the net message\n        -- A client is asking for the number\n        if name == \"request\" then\n            -- Send it to the client\n            net.start( \"number\" )\n                -- 8 is the amount of bits to use for the transmission\n                net.writeInt( randomNumber, 8 )\n            net.send( ply )\n        end\n    end )\nelse\n    -- Code only executed on the client\n    local randomNumber\n\n    local font = render.createFont( \"Default\", 62 )\n\n    -- Send a request for the number to the server\n    net.start( \"request\" )\n    net.send()\n\n    hook.add( \"net\", \"uniqueHookNameHerev2\", function ( name, len )\n        -- No client argument, since it can only come from the server\n        -- The server is sending us the number\n        if name == \"number\" then\n            randomNumber = net.readInt( 8 )\n        end\n    end )\n\n    -- The render hook is called every frame the client requires the screen to be rendered\n    -- If the client has 120 FPS then this hook will be called 120 in a second.\n    hook.add( \"render\", \"renderHook\", function ()\n        render.clear()\n        if randomNumber then\n            render.setColor( Color( 0,255,255,255 ) )\n            render.setFont( font )\n            render.drawText( 20, 20, tostring( randomNumber ) )\n        end\n    end )\nend\n","music_player.lua":"--@name MusicPlayer\n--@author Sparky\n--@model models/props_lab/citizenradio.mdl\n\nif SERVER then \n    hook.add(\"PlayerSay\",\"Hey\",function(ply,txt)\n        if ply==entities.owner() and txt:sub(1,6)==\"!song \" then\n            net.start(\"playSong\")\n            net.writeString(txt:sub(7))\n            net.send()\n            \n            return \"\"\n        end\n    end)\nelse\n    hook.add(\"net\",\"songs\",function(name, len, pl)\n        if name~=\"playSong\" then return end\n        \n        if song then song:stop() end\n        bass.loadURL(net.readString(),\"3d noblock\",function(snd, err, errtxt)\n            if snd then\n                song = snd\n                snd:setFade(500,100000)\n                snd:setLooping(true)\n                snd:setVolume(2)\n                hook.add(\"think\",\"snd\",function()\n                    snd:setPos(entities.self():getPos())\n                end)\n            else\n                print(errtxt)\n            end\n        end)\n    end)\nend\n","Filetransfer.lua":"--@name Filetransfer\n--@author Sparky\n--@shared\n\n--File transfer library. Allows sending strings much larger than the limit size.\n--Example usage\n---------------------\n----SERVER\n---------------------\n--local filetransfer = require(\"filetransfer.txt\")\n--\n--net.start(\"myfile\")\n--filetransfer.write(\"mydata\")\n--net.send()\n\n---------------------\n----CLIENT\n---------------------\n--hook.add(\"net\",\"\",function(name,len)\n--\tif name==\"myfile\" then\n--\t\tfiletransfer.read(function(data)\n--\t\t\tif data then\n--\t\t\t\tprint(data)\n--\t\t\tend\n--\t\tend)\n--\tend\n--end)\n\nlocal filetransfer = {}\nfiletransfer.uploadcache = {}\nfiletransfer.downloadqueue = {}\n\nlocal packetsize = 1000\n\nlocal function duelSend(ply)\n    if SERVER then\n        net.send(ply)\n    else\n        net.send()\n    end\nend\n\nlocal function processQueue()\n    local item = filetransfer.downloadqueue[1]\n    if not item then return end\n    \n    net.start(\"ftreqdata\")\n    net.writeUInt(item.index, 16)\n    net.writeUInt(#item.pieces, 16)\n    duelSend(item.ply)\n    \n    if timer.exists(\"ftdownloadtimeout\"..item.index) then\n        timer.adjust(\"ftdownloadtimeout\"..item.index, 10, 1)\n    else\n        timer.create(\"ftdownloadtimeout\"..item.index, 10, 1, function()\n            item.callback(nil)\n            table.remove(filetransfer.downloadqueue, 1)\n\t\t\ttimer.remove(\"ftkeepalive\"..item.index)\n            processQueue()\n        end)\n    end\nend\n\nlocal function sendData(index, ply)\n    local part = net.readUInt(16)\n    local function timetosend()\n        local data = filetransfer.uploadcache[index]\n        if not data then return end\n        local senddata = string.sub(data, part*packetsize+1, math.min(part*packetsize+packetsize, #data))\n            \n        if net.getBytesLeft()<#senddata+100 then\n            timer.simple(0.1, timetosend)\n            return\n        end\n        \n        net.start(\"ftrecvdata\")\n        net.writeUInt(index, 16)\n        net.writeData(senddata, #senddata)\n        duelSend(ply)\n    end\n    timetosend()\nend\n\nlocal function gotData(index, ply)\n    local item = filetransfer.downloadqueue[1]\n    if not item then return end\n    \n    item.pieces[#item.pieces+1] = net.readData(packetsize)\n    \n    if #item.pieces == item.numpieces then\n        local data = fastlz.decompress(table.concat(item.pieces))\n        item.callback(data)\n        table.remove(filetransfer.downloadqueue, 1)\n        timer.remove(\"ftdownloadtimeout\"..item.index)\n\t\ttimer.remove(\"ftkeepalive\"..item.index)\n    end\n    processQueue()\nend\n\nfunction filetransfer.write(data)\n    local compressed = fastlz.compress(data)\n    local index = 1\n    while filetransfer.uploadcache[index] do\n        index = index + 1\n    end\n    filetransfer.uploadcache[index] = compressed\n    \n    timer.create(\"ftcachetimeout\"..index,10,1,function() filetransfer.uploadcache[index] = nil end)\n    \n    net.writeUInt(index, 16)\n    net.writeUInt(math.ceil(#compressed/packetsize),16)\nend\n\nfunction filetransfer.read(callback, ply)\n    local index = net.readUInt(16)\n    local numpieces = net.readUInt(16)\n    local item = {\n        index = index,\n        numpieces = numpieces,\n        pieces = {},\n        ply = ply,\n        callback = callback\n    }\n    \n    local queuelen = #filetransfer.downloadqueue\n    filetransfer.downloadqueue[queuelen+1] = item\n    if queuelen == 0 then\n        processQueue()\n    end\n\ttimer.create(\"ftkeepalive\"..index, 3, 0, function()\n\t\tnet.start(\"ftkeepalive\")\n\t\tnet.writeUInt(index,16)\n\t\tduelSend(ply)\n\tend)\nend\n\nhook.add(\"net\",\"filetransfer\",function(name,len,ply)\n    \n    local index = net.readUInt(16)\n    if CLIENT then ply = nil end\n    \n    if name == \"ftrecvdata\" then\n        gotData(index, ply)\n    elseif name == \"ftkeepalive\" then\n        timer.adjust(\"ftcachetimeout\"..index,10,1)\n    elseif name == \"ftreqdata\" then\n        timer.adjust(\"ftcachetimeout\"..index,10,1)\n        sendData(index, ply)\n    end\n    \nend)\n\nreturn filetransfer\n","screenhelloworld.lua":"--@name Hello World\n--@author INP\n\nif CLIENT then\n\t\n\tlocal font = render.createFont( \"Default\", 30 )\n\t\n\thook.add( \"render\", \"helloworld_render\", function ()\n\t\trender.clear() -- Clear the screen to allow for easy refresh (comment it out and see what happens)\n\t\trender.setColor( Color( 255, 0, 0, 255 ) ) -- Set colour to red, the alpha argument is optional and will default to 255\n\t\trender.setFont( font ) -- \"Activate\" font\n\t\trender.drawText( 20, 20, \"Hello World!\" ) -- Draw text at 20, 20\n\tend )\n\nend\n","included.lua":"-- This file gets included in the include example\n\nfunction printHelloWorld () -- Define a global function\n    print( \"Hello World!\" )\nend\n\nreturn 5 -- Return a value\n","helloworld.lua":"--@name Hello World\n--@author INP\n\nprint( \"Hello World!\" )\n","cpuTime.lua":"--@name cpuTime Example\n--@author INP - Radon\n\nif CLIENT then return end\n\n-- This function helps us check if we can run.\n-- Use a mixture of quotaUsed() and quotaAverage()\n-- quotaUsed() returns the value of the current buffer.\n-- quotaAverage() gives the cpuTime average across the whole buffer.\n-- You chip will quota if quotaAverage() > quotaMax()\n-- n is a parameter between 0 and 1 that represents the percent. 0.8 = 80%.\nlocal function quotaCheck ( n )\n    return ( quotaUsed() < quotaMax() * n ) and ( quotaAverage() < quotaMax() )\nend\n\n-- Standard think hook, see hook example for this.\nhook.add( \"think\", \"\", function ()\n    -- Simple incrementer inside a while loop\n    local i = 0\n    while( quotaCheck( 0.95 ) ) do\n        -- We'll increment until we reach 95%\n        i = i + 1\n    end\n    -- Then print the final counter, this is how many times the while loop executed this think\n    print( i )\nend )\n"},"directives":{"1":"client","2":"include","3":"includedir","4":"model","5":"name","6":"server","include":{"description":"\nMark a file to be included in the upload. \nThis is required to use the file in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"include","summary":"\nMark a file to be included in the upload.","usage":"\n--@include lib/someLibrary.txt \n \nrequire( \"lib/someLibrary.txt\" ) \n-- CODE","comment":["--- Mark a file to be included in the upload.","-- This is required to use the file in require() and dofile()","-- @name include","-- @class directive","-- @param path Path to the file","-- @usage","-- \\--@include lib/someLibrary.txt","-- ","-- require( \"lib/someLibrary.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the file"}},"includedir":{"description":"\nMark a directory to be included in the upload. \nThis is optional to include all files in the directory in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"includedir","summary":"\nMark a directory to be included in the upload.","usage":"\n--@includedir lib \n \nrequire( \"lib/someLibraryInLib.txt\" ) \nrequire( \"lib/someOtherLibraryInLib.txt\" ) \n-- CODE","comment":["--- Mark a directory to be included in the upload.","-- This is optional to include all files in the directory in require() and dofile()","-- @name includedir","-- @class directive","-- @param path Path to the directory","-- @usage","-- \\--@includedir lib","--","-- require( \"lib/someLibraryInLib.txt\" )","-- require( \"lib/someOtherLibraryInLib.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the directory"}},"model":{"description":"\nSet the model of the processor entity. \nThis does not set the model of the screen entity","code":[""],"class":"directive","classForced":true,"name":"model","summary":"\nSet the model of the processor entity.","usage":"\n--@model models/props_junk/watermelon01.mdl \n-- CODE","comment":["--- Set the model of the processor entity.","-- This does not set the model of the screen entity","-- @name model","-- @class directive","-- @param model String of the model","-- @usage","-- \\--@model models/props_junk/watermelon01.mdl","-- -- CODE"],"param":{"1":"model","model":"String of the model"}},"client":{"description":"\nSet the processor to only run on the client. Shared is default","code":[],"class":"directive","classForced":true,"name":"client","summary":"\nSet the processor to only run on the client.","usage":"\n--@client \n-- CODE","comment":["--- Set the processor to only run on the client. Shared is default","-- @name client","-- @class directive","-- @usage","-- \\--@client","-- -- CODE"],"param":[]},"name":{"description":"\nSet the name of the script. \nThis will become the name of the tab and will show on the overlay of the processor","code":["","--","-- if SERVER then","-- \\\t-- Do important calculations","-- \\\t-- Send net message","-- else","-- \\\t-- Display result of important calculations","-- end",""],"class":"directive","classForced":true,"name":"name","summary":"\nSet the name of the script.","usage":"\n--@name Awesome script \n-- CODE","comment":["--- Set the name of the script.","-- This will become the name of the tab and will show on the overlay of the processor","-- @name name","-- @class directive","-- @param name Name of the script","-- @usage","-- \\--@name Awesome script","-- -- CODE"],"param":{"1":"name","name":"Name of the script"}},"server":{"description":"\nSet the processor to only run on the server. Shared is default","code":[""],"class":"directive","classForced":true,"name":"server","summary":"\nSet the processor to only run on the server.","usage":"\n--@server \n-- CODE","comment":["--- Set the processor to only run on the server. Shared is default","-- @name server","-- @class directive","-- @usage","-- \\--@server","-- -- CODE"],"param":[]}}}